use strict;
use threads;
use Getopt::Long;

my $version = 'C_alpha1.2.2';
my ($help, $in, $fa, $anno, $out, $target_ID, $num_thread, $mapq_cutoff, $keep_tmp, $proc_num_cutoff, $is_stranded,
	$cont_del_max, $chrM, $inserted_cont_cutoff, $first_exon_diff_cutoff, $SJFS_dist, $SJFS_dist_add, $align_length_ratio_cutoff, $fold_end_length_lost_cutoff,
	$correct_suggest_SJ_distance_max, $confirm_prob_fold_cutoff, $evalue_cor, $second_exon_align_length_ratio_cutoff, $length4nhmmer_max,
	$END_dist_add, $blast_score_difference_cutoff, $additional_candidate_prob_fold_cutoff, $directly_approve_length_additional, $max_overlap_SJ_group);


Getopt::Long::GetOptions (

	'in|I=s'					=>	\$in,
	'fa|F=s'					=>	\$fa,
	'target_ID|X=s'				=>	\$target_ID,

	'help|H!'					=>	\$help,
	'keep_tmp|K!'				=>	\$keep_tmp,
	'num_thread|T=i'			=>	\$num_thread,

	'first_exon_diff_cutoff=i'	=>	\$first_exon_diff_cutoff,
	'SJFS_dist=i'				=>	\$SJFS_dist,
	'SJFS_dist_add=i'			=>	\$SJFS_dist_add,
	'END_dist_add=i'			=>	\$END_dist_add,
	'align_length_ratio_cutoff=f'				=>	\$align_length_ratio_cutoff,
	'correct_suggest_SJ_distance_max=i'			=>	\$correct_suggest_SJ_distance_max,
	'confirm_prob_fold_cutoff=f'				=>	\$confirm_prob_fold_cutoff,
	'evalue_cor=f'								=>	\$evalue_cor,

	'second_exon_align_length_ratio_cutoff=f'	=>	\$second_exon_align_length_ratio_cutoff,
	'blast_score_difference_cutoff=f'			=>	\$blast_score_difference_cutoff,
	'additional_candidate_prob_fold_cutoff=f'	=>	\$additional_candidate_prob_fold_cutoff,
	'directly_approve_length_additional=i'		=>	\$directly_approve_length_additional,
	'proc_num_cutoff=i'							=>	\$proc_num_cutoff,
	'length4nhmmer_max=i'							=>	\$length4nhmmer_max,

);

if (defined($help)) {
	print "
Program:  ESPRESSO (Error Statistics PRomoted Evaluator of Splice Site Options)
Version:  $version
Contact:  Yuan Gao <gaoy\@email.chop.edu, gy.james\@163.com>

Usage:    perl ESPRESSO_C.pl -I work_dir -F ref.fa -X target_ID

Arguments:

    -I, --in
          work directory (generated by ESPRESSO_S)
    -F, --fa
          FASTA file of all reference sequences. Please make sure this file is
          the same one provided to mapper. (required)
    -X, --target_ID
          ID of sample to process (required)

    -H, --help
          show this help information

    -T, --num_thread
          thread number (default: 5)

";
} elsif ( !defined($in) or !defined($fa) or !defined($target_ID) ) {
	print "The following parameter(s) are required:\n";
	if (!defined($in)) {
		print "\t--in/-I";
	} if (!defined($fa)) {
		print "\t--fa/-F";
	} if (!defined($target_ID)) {
		print "\t--target_ID/-X";
	}
	print "\nPlease use the --help or -H option to get usage information.\n";
} else {

	$first_exon_diff_cutoff = 30 if !defined $first_exon_diff_cutoff;
	$SJFS_dist = 10 if !defined $SJFS_dist;
	$SJFS_dist_add = 15 if !defined $SJFS_dist_add;
	$align_length_ratio_cutoff = 0.7 if !defined $align_length_ratio_cutoff;
	$correct_suggest_SJ_distance_max = 20 if !defined $correct_suggest_SJ_distance_max;
	$confirm_prob_fold_cutoff = 10 if !defined $confirm_prob_fold_cutoff;
	$evalue_cor = 10 if !defined $evalue_cor;

	$second_exon_align_length_ratio_cutoff = 0.8 if !defined $second_exon_align_length_ratio_cutoff;
	$END_dist_add = 50 if !defined $END_dist_add;
	$blast_score_difference_cutoff = 2 if !defined $blast_score_difference_cutoff;
	$additional_candidate_prob_fold_cutoff = 0.1 if !defined $additional_candidate_prob_fold_cutoff;
	$directly_approve_length_additional = 50 if !defined $directly_approve_length_additional;
	$num_thread = 5 if !defined $num_thread;
	$fold_end_length_lost_cutoff = 1.5;
	$max_overlap_SJ_group = 100;
	$length4nhmmer_max = 200 if !defined $length4nhmmer_max;

	$proc_num_cutoff = 20_000 if !defined $proc_num_cutoff;

	$chrM = 'chrM' if !defined $chrM;
	my @ends = ('start','end');

	my @warn_reason;
	my @die_reason;

	if($num_thread < 2){
		push @die_reason, " Please designate at least 2 threads\n";
	}

	my @blast_versions = qx(blastn -version);
	my $tag_blast = 0;
	if (@blast_versions > 0) {
		my @line = split /\s+/, $blast_versions[0];
		my @version_tiny = split /[.]/, $line[1];
		$tag_blast = 1 if $version_tiny[0] >= 2 and ($version_tiny[1] > 8 or ($version_tiny[1] == 8 and $version_tiny[2] >= 1));
	}
	push @die_reason, "Please make sure BLAST 2.8.1 or higher version is installed and included in \$PATH!" if $tag_blast == 0;

	my @nhmmer_versions = qx(nhmmer -h | head -2);
	my $tag_nhmmer = 0;
	if (@nhmmer_versions == 2) {
		my @line = split /\s+/, $nhmmer_versions[1];
		my @version_tiny = split /[.]/, $line[2];
		$tag_nhmmer = 1 if $version_tiny[0] == 3 and $version_tiny[1] == 3 and $version_tiny[2] == 1;
	}
	push @die_reason, "Please make sure nhmmer 3.3.1 is installed and included in \$PATH!" if $nhmmer_versions[1]=='HMMER' and $tag_nhmmer == 0;

	if ( @warn_reason >= 1 ) {
		print @warn_reason;
	}
	if ( @die_reason >= 1 ) {
		die @die_reason;
	}

	my $sep_end_blast = '/';
	my $sep_SJ = ':';

	opendir DIR, "$in/$target_ID" or die "cannot opendir $in/$target_ID: $!";

	for my $file (readdir DIR) {
		if ( -d "$in/$target_ID/$file" and ($file =~ /^blast_\d+$/ or $file eq 'all') ) {
			opendir DIR2, "$in/$target_ID/$file" or die "cannot opendir $in/$target_ID/$file: $!";
			for my $file2 (readdir DIR2) {
				if (-f "$in/$target_ID/$file/$file2"){
					unlink "$in/$target_ID/$file/$file2";
				}
			}
			closedir DIR2;
			rmdir "$in/$target_ID/$file";
		} elsif (-f "$in/$target_ID/$file" and ($file =~ /^sam\.list3[a-z]+$/ or $file =~ /_read_final\.txt$/)) {
			unlink "$in/$target_ID/$file";
		}
	}
	closedir DIR;

	mkdir "$in/$target_ID/all";

	printf  '['.scalar(localtime)."] Loading splice junction info\n";
	#my %group_all_SJ;

	my %necessary_groups;
	open LIST3, "<", "$in/$target_ID/sam.list3" or die "cannot open $in/$target_ID/sam.list3: $!";
	while (<LIST3>) {
		s/\r\n//;
		chomp;
		my @line = split /\t/;
		$necessary_groups{$line[0]} ++;
	}
	close LIST3;
	
	my @SJ_simplified = glob("$in/*_SJ_simplified.list");
	my %group_ID_mkdir;
	for my $SJ_file (@SJ_simplified) {
		open SJ_SIM, "<", "$SJ_file" or die "cannot open $SJ_file: $!";
		my ($last_group_ID);
		while (<SJ_SIM>) {
			s/\r\n//;
			chomp;
			if (/^SJ_cluster/) {
				my @line = split /\s+/;
				my $group_ID = $line[1];
				my $chr = $line[4];
				if ($group_ID ne $last_group_ID) {
					close SJ_SIM_GROUP if exists $necessary_groups{$last_group_ID};
					if (exists $necessary_groups{$group_ID}) {
						my $output_dir = "$in/$target_ID/blast_$group_ID";
						$group_ID_mkdir{$group_ID} = [1, $chr];
						mkdir "$in/$target_ID/blast_$group_ID";
						open SJ_SIM_GROUP, ">$output_dir/SJ_info.txt" or die "cannot write $output_dir/SJ_info.txt: $!";
					}
				}

				$last_group_ID = $group_ID;
			}
			print SJ_SIM_GROUP "$_\n";

			#push @{$group_all_SJ{$line[0]}{$line[-1]}}, $line[1].$sep_SJ.$line[2].$sep_SJ.$line[3].$sep_SJ.$line[4]; # if $line[-2] == 1
		}
		close SJ_SIM_GROUP;
		close SJ_SIM;
	}
	

	open SJ_FA, "<", "$in/SJ_group_all.fa" or die "cannot open $in/SJ_group_all.fa: $!";
	my ($last_group_ID); 
	while (<SJ_FA>) {
		s/\r\n//;
		chomp;
		if (/^>/) {
			my @line = split /\s+/;
			my $group_ID = substr($line[-1], 6, length($line[-1])-7);
			if ($group_ID ne $last_group_ID) {
				close SJ_FA_GROUP if exists $necessary_groups{$last_group_ID};
				if (exists $necessary_groups{$group_ID}) {
					my $output_dir = "$in/$target_ID/blast_$group_ID";
					die "$group_ID was not recorded:$_" if !exists $group_ID_mkdir{$group_ID};
					$group_ID_mkdir{$group_ID}[0] = 2;
					#mkdir "$in/$target_ID/blast_$group_ID";
					open SJ_FA_GROUP, ">$output_dir/SJ_group.fa" or die "cannot write $output_dir/SJ_group.fa: $!";
				}
			} 

			$last_group_ID = $group_ID;
		}
		print SJ_FA_GROUP "$_\n";

		#push @{$group_all_SJ{$line[0]}{$line[-1]}}, $line[1].$sep_SJ.$line[2].$sep_SJ.$line[3].$sep_SJ.$line[4]; # if $line[-2] == 1
	}
	close SJ_FA_GROUP;
	close SJ_FA;

	%necessary_groups=();

	printf  '['.scalar(localtime)."] Requesting system to split SAMLIST into %g pieces\n", int($num_thread);
	my $split_list_first_read = &split_sam_file("$in/$target_ID/sam.list3", int($num_thread), "$in/$target_ID/", 'group');
	
	print  '[', scalar(localtime), "] Loading references\n";


	my %chr_seq;
	my %chr_seq_len;
	my $current_chr;

	open FA, "<", $fa or die "cannot open $fa: $!";
	while (<FA>) {
		s/\r\n//;
		chomp;
		if (/^>/) {
			my $info = substr($_, 1, length($_)-1);
			($current_chr, undef) = split /\s+/, $info;
		} else {
			$chr_seq{$current_chr} .= uc($_);
			$chr_seq_len{$current_chr} += length($_);
		}
	}
	close FA;

	#open READ_SUMM, ">", $out."/read_summary.txt" or die "cannot write $out/read_summary.txt: $!";

	my @output_titles = ('group_ID', 'line_num','readID','read_length','flag','chr','start','mapq','end','notSameStrand','mappedGenome','clip_ends','exonIntronRef','IDS_SJ_ref','NM_num','insNumBg','delNumBg','substNumBg','totalNumBg','SJcorSeqRef','readSeq'); #'SAM', 
	#21
	printf  '['.scalar(localtime)."] Scanning SAMLIST by %g workers\n", int($num_thread/2);

	my @split_list_sort = sort {$a cmp $b} keys %{$split_list_first_read};
	my @ths;
	for my $file (@split_list_sort){
		my $th = threads -> new({'context' => 'void'}, \&parallel_scan_samlist, [$file, ${$split_list_first_read}{$file}, scalar(@ths)]);
		my $th_id = $th->tid();
		print " Worker $th_id begins to scan $file.\n";
		unshift @ths, $th;
	}
	for (@ths) {
		my $th_id = $_->tid();
		$_ -> join();
		print " Worker $th_id finished reporting.\n";
	}
	@ths = ();

	while (my ($chr, $len) = each %chr_seq_len) {
		my @read_finals = glob("$in/$target_ID/all/*_thread_${chr}_read_final.txt");
		if (@read_finals > 0) {
			my $exit_cat = system("cat @read_finals > $in/$target_ID/${chr}_read_final.txt");
			if ($exit_cat != 0) {
				warn "Failed to run \"cat @read_finals > $in/$target_ID/${chr}_read_final.txt\". Exit code is $exit_cat";
			}
		}
		if (!defined $keep_tmp) {
			unlink "$_" for @read_finals;
			rmdir "$in/$target_ID/all";
		}
	}

	if (!defined $keep_tmp) {
		opendir DIR, "$in/$target_ID" or die "cannot opendir $in/$target_ID: $!";

		for my $file (readdir DIR) {
			if ( -d "$in/$target_ID/$file" and ($file =~ /^blast_\d+$/ or $file eq 'all') ) {
				opendir DIR2, "$in/$target_ID/$file" or die "cannot opendir $in/$target_ID/$file: $!";
				for my $file2 (readdir DIR2) {
					if (-f "$in/$target_ID/$file/$file2"){
						unlink "$in/$target_ID/$file/$file2";
					}
				}
				closedir DIR2;
				rmdir "$in/$target_ID/$file";
			} elsif (-f "$in/$target_ID/$file" and $file =~ /^sam\.list3[a-z]+$/) {
				unlink "$in/$target_ID/$file";
			}
		}
		closedir DIR;
	}

	print  '[', scalar(localtime), "] ESPRESSO_C finished its work.\n";

	sub parallel_scan_samlist {
		my ($file, $key_read, $thread_ID) = @{$_[0]};
		my ($pinhead, $n, @all_info_read, $last_n);
		my ($same_group_count) = (0); #, $accu_num
		my %pre_read_align_length;
		my (%group_SJ_cluster, %group_SJ_cluster_ends);
		open IN, "<", "$in/$target_ID/$file" or die "cannot open $in/$target_ID/$file: $!";
		#open OUT, ">", "$out/$file.size" or die "cannot write $out/$file.size: $!" if $time == 2;
		while (<IN>) {
			chomp;
			my @line = split /\t/;
			if ($line[0] eq $key_read and @line == @output_titles) {
				$pinhead = 1;
			}
			if (defined $pinhead) {
				die scalar(@output_titles)."\t@line" if @line != @output_titles;
				if ( defined $n and ($n ne $line[0] or @all_info_read >= $proc_num_cutoff) ) {
					my $chr0 = $all_info_read[0]{'chr'};
					if (!defined $last_n or $n ne $last_n) {
						if ($n ne $last_n and !defined $keep_tmp) {
							unlink "$in/$target_ID/blast_$last_n/SJ_info.txt";
							unlink "$in/$target_ID/blast_$last_n/SJ_group.fa";
							rmdir "$in/$target_ID/blast_$last_n";
						}
						$same_group_count = 0;
						%group_SJ_cluster = ();
						%group_SJ_cluster_ends = ();
						if ($group_ID_mkdir{$n}[0] == 2){
							my $SJ_list = "$in/$target_ID/blast_$n/SJ_info.txt";
							open SJ_LIST, "<", $SJ_list or die "cannot open $SJ_list: $!";
							while (<SJ_LIST>) {
								chomp;
								my @line_SJ = split /\t/;
								if ($line_SJ[0] eq 'SJ_cluster') {
									$group_SJ_cluster_ends{$line_SJ[2]} = [$line_SJ[5], $line_SJ[6], $line_SJ[3]];
								} else {
									push @{$group_SJ_cluster{$line_SJ[-1]}}, [$line_SJ[1], $line_SJ[-3], $line_SJ[-2]];
								}
							}
							close SJ_LIST;
						}
						printf "$n\t%g\n", scalar(keys %group_SJ_cluster_ends), scalar(@all_info_read);

					}
					
					$same_group_count ++;
					if (scalar(%group_SJ_cluster) > 0) {
						&blast_prep(\@all_info_read, \%group_SJ_cluster, \%group_SJ_cluster_ends, "$in/$target_ID/blast", $n, $same_group_count, $thread_ID, $chr0); #, $time
					} else {
						open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
						for my $read_ID (0 .. $#all_info_read){
							my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
							my $out = &summary_final_output($all_info_read[$read_ID], $n, $read_ID_update, {});
							print READ_FINAL $out;
						}
						close READ_FINAL;
					}
					@all_info_read = ();
					$last_n = $n;
					#$accu_num = 0;
				}
				my %tmp_info_read;
				$tmp_info_read{$output_titles[$_]} = $line[$_] for 1 .. $#output_titles;

				my %current_read_info;

				while (my ($key, $info) = each %tmp_info_read) {
					if ( $key eq 'clip_ends' or $key eq 'exonIntronRef' ) {
						my @array_refs = split ',', $tmp_info_read{$key};
						$current_read_info{$key} = \@array_refs;
					} elsif ( $key eq 'IDS_SJ_ref' or $key eq 'SJcorSeqRef' ) {
						if ($tmp_info_read{$key} eq 'NA'){
							$current_read_info{$key} = [];
						} else {
							my @array_refs = split ',', $tmp_info_read{$key};

							for my $array_string2 (@array_refs) {
								my @array_refs2 = split ';', $array_string2;
								push @{$current_read_info{$key}}, \@array_refs2;
							}
						}
					} else {
						$current_read_info{$key} = $tmp_info_read{$key} unless $key eq 'readSeq' and $tmp_info_read{'IDS_SJ_ref'} eq 'NA';
					}
				}
				#$accu_num ++;

				unshift @all_info_read, \%current_read_info;

				$n = $line[0];
			}
		}
					my $chr0 = $all_info_read[0]{'chr'};
					if (!defined $last_n or $n ne $last_n) {
						if ($n ne $last_n and !defined $keep_tmp) {
							unlink "$in/$target_ID/blast_$last_n/SJ_info.txt";
							unlink "$in/$target_ID/blast_$last_n/SJ_group.fa";
							rmdir "$in/$target_ID/blast_$last_n";
						}
						$same_group_count = 0;
						%group_SJ_cluster = ();
						%group_SJ_cluster_ends = ();
						if ($group_ID_mkdir{$n}[0] == 2){
							my $SJ_list = "$in/$target_ID/blast_$n/SJ_info.txt";
							open SJ_LIST, "<", $SJ_list or die "cannot open $SJ_list: $!";
							while (<SJ_LIST>) {
								chomp;
								my @line_SJ = split /\t/;
								if ($line_SJ[0] eq 'SJ_cluster') {
									$group_SJ_cluster_ends{$line_SJ[2]} = [$line_SJ[5], $line_SJ[6], $line_SJ[3]];
								} else {
									push @{$group_SJ_cluster{$line_SJ[-1]}}, [$line_SJ[1], $line_SJ[-3], $line_SJ[-2]];
								}
							}
							close SJ_LIST;
						}
						printf "$n\t%g\n", scalar(keys %group_SJ_cluster_ends), scalar(@all_info_read);

					}
					
					$same_group_count ++;
					if (scalar(%group_SJ_cluster) > 0) {
						&blast_prep(\@all_info_read, \%group_SJ_cluster, \%group_SJ_cluster_ends, "$in/$target_ID/blast", $n, $same_group_count, $thread_ID, $chr0); #, $time
					} else {
						open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
						for my $read_ID (0 .. $#all_info_read){
							my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
							my $out = &summary_final_output($all_info_read[$read_ID], $n, $read_ID_update, {});
							print READ_FINAL $out;
						}
						close READ_FINAL;
					}
					@all_info_read = ();
					$last_n = $n;
					if (!defined $keep_tmp) {
						unlink "$in/$target_ID/blast_$last_n/SJ_info.txt";
						unlink "$in/$target_ID/blast_$last_n/SJ_group.fa";
						rmdir "$in/$target_ID/blast_$last_n";
					}

		close IN;
		if (!defined $keep_tmp) {
			unlink "$in/$target_ID/$file";
		}

	}

	sub summary_final_output {
		my ($info_ref, $n, $read_ID_update, $hc_SJ_ref) = @_;
		my $out;

		#my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+${$info_ref}{'readID'};
		$out .= "${$info_ref}{'readID'}\tgroup_ID\t$n\t${n}_$read_ID_update\n";
		$out .= "${$info_ref}{'readID'}\tstrand_isoform\tunknown\n";
		$out .= "${$info_ref}{'readID'}\tstrand_read\t${$info_ref}{'notSameStrand'}\n";
		$out .= "${$info_ref}{'readID'}\tchr\t${$info_ref}{'chr'}\n";
		$out .= "${$info_ref}{'readID'}\tmapq\t${$info_ref}{'mapq'}\n";
		$out .= "${$info_ref}{'readID'}\tflag\t${$info_ref}{'flag'}\n";					
		
		my $out_line = "${$info_ref}{'readID'}\tSJ";
		my $read_length = ${$info_ref}{'read_length'};

		for my $i(0 .. $#{${$info_ref}{'SJcorSeqRef'}}){
			my $j = $i + 1;
			my $SJ_info = ${$info_ref}{'SJcorSeqRef'}[$i];
			my @SJ_cor = split $sep_SJ, ${$SJ_info}[1];
			my $other_dist = $read_length-${$SJ_info}[0];
			$out .= "$out_line\t$j\t${$SJ_info}[1]\t${$SJ_info}[0]\t$other_dist\t";
			$out .= "fail2\tNA\tNA\tNA\tNA\t";
			if (exists ${$hc_SJ_ref}{${$SJ_info}[1]}) {
				$out .= "${$hc_SJ_ref}{${$SJ_info}[1]}[1]\tNA\n";
			} else {
				$out .= "no\tNA\n";
			}
			
		}

		my @unmapped_ends_raw = @{${$info_ref}{'clip_ends'}};
		my @mapped_genome_range_raw = (${$info_ref}{$ends[0]}, ${$info_ref}{$ends[1]});
		my $mapped_length_read;

		for my $i (0 .. $#ends){
			$out .= "${$info_ref}{'readID'}\t$ends[$i]\tNA\t";
			my $output_raw = "$mapped_genome_range_raw[$i]\t";
			if ($i == 0){
				$output_raw .= $unmapped_ends_raw[0]. "\t". ($read_length-$unmapped_ends_raw[0]). "\t";
				$mapped_length_read -= $unmapped_ends_raw[0];
			} else {
				$output_raw .= ($read_length-$unmapped_ends_raw[1]). "\t". $unmapped_ends_raw[1]. "\t";
				$mapped_length_read += ($read_length-$unmapped_ends_raw[1]);
			}
			$out .= $output_raw;
			my $output_correct = $output_raw."NA\tNA\tNA\n";
			if ($unmapped_ends_raw[$i] <= $directly_approve_length_additional){
				$out .= "pass2\t".$output_correct;
			} else {
				$out .= "fail2\t".$output_correct;
			}
			
		}
		$out .= join '', ("${$info_ref}{'readID'}\tmapped_length_read\t",$mapped_length_read,"\n");
		$out;
	}

	sub blast_prep {
		my ($all_info_read_ref, $group_SJ_cluster_ref, $group_SJ_cluster_ends_ref, $output_pre, $n, $same_group_count, $thread_ID, $chr0) = @_;
		###my $chr0 = $group_ID_mkdir{$n}[1];
		#my $out_dir = "${output_pre}_$n";
		my $out_dir = "$in/$target_ID/blast_$n/";

		#mkdir $out_dir or die "cannot mkdir $out_dir: $!";
		if (defined $keep_tmp) {
			open BACKUP, ">", "$in/$target_ID/blast_$n/backup_$same_group_count.txt" or die "cannot write to $in/$target_ID/blast_$n/backup_$same_group_count.fa";
		}
		print BACKUP "$n\t$same_group_count\n";
		my (%SJ_read, %read_no_SJ, @recorded_index);
		for my $read_ID (0 .. $#{$all_info_read_ref}){
			#$read_ID = ($same_group_count-1)*$proc_num_cutoff+$read_ID_raw;
			my $read_info_ref = ${$all_info_read_ref}[$read_ID];
			
			if (@{${$read_info_ref}{'IDS_SJ_ref'}}>0){
				my $notSameStrand = ${$read_info_ref}{'notSameStrand'};
				for my $i (0 .. $#{${$read_info_ref}{'IDS_SJ_ref'}}){
					my $j = $i+1;
					my ($insert_num, $deletion_num, $subst_num) = @{${$read_info_ref}{'IDS_SJ_ref'}[$i]};
					my ($pos_read, $SJ, undef) = @{${$read_info_ref}{'SJcorSeqRef'}[$i]};
					my ($chr, $SJ_start, $SJ_end, $notSameStrand_SJ) = split $sep_SJ, $SJ;

					if ( exists $SJ_read{$SJ} ) {
						$SJ_read{$SJ}[-1]{$read_ID} = [$j, $#{${$read_info_ref}{'IDS_SJ_ref'}}-$i+1, $insert_num, $deletion_num, $subst_num];#, $SJ_seq];
					} else {
						$SJ_read{$SJ} = [$chr, $SJ_start, $SJ_end, $SJ_end-$SJ_start, {$read_ID => [$j, $#{${$read_info_ref}{'IDS_SJ_ref'}}-$i+1, $insert_num, $deletion_num, $subst_num]} ];#, $SJ_seq]} ];
					}
					print BACKUP "$SJ, $read_ID, $j, ",$#{${$read_info_ref}{'IDS_SJ_ref'}}-$i+1, ", $insert_num, $deletion_num, $subst_num\n";
				}
			} else {
				$read_no_SJ{$read_ID} = 1;
			}
			
		}


		my @SJ_cluster_r_index_sort = sort { ${$group_SJ_cluster_ends_ref}{$a}[1] <=> ${$group_SJ_cluster_ends_ref}{$b}[1] } keys %{$group_SJ_cluster_ref};
		my @SJ_cluster_f_index_sort = sort { ${$group_SJ_cluster_ends_ref}{$b}[0] <=> ${$group_SJ_cluster_ends_ref}{$a}[0] } keys %{$group_SJ_cluster_ref};


		my (%max_length_cluster, %read_seq_pos, %hc_SJ);
		my $num_mt0_index_ori = 0;
		for my $l (0 .. $#SJ_cluster_r_index_sort) {
			my $index_ori = $SJ_cluster_r_index_sort[$l];
			my @SJs_current_cluster = @{${$group_SJ_cluster_ref}{$index_ori}};

			$max_length_cluster{$index_ori} = [0, 0, 0, 0];
			$read_seq_pos{$index_ori} = [];
			
			
			for my $SJ_isHC (@SJs_current_cluster) {
				my ($SJ, $isAnno, $isHC) = @{$SJ_isHC};
				my @SJ_info = split $sep_SJ, $SJ;
				if ($isHC == 1) {
					$hc_SJ{$SJ} = [$SJ_info[-1], $isAnno];
				}
				printf BACKUP "SJ_isHC: $SJ, $isHC\t";
				my @perfect_reads;
				if (exists $SJ_read{$SJ}) {
					print BACKUP scalar(keys %{$SJ_read{$SJ}[-1]}),"\n";
					my $SJ_info_ref = $SJ_read{$SJ};
					my ($chr, $SJ_start, $SJ_end, $gap, $read_hash_ref) = @{$SJ_info_ref};
					while ( my ($read_ID, $info_ref) = each %{$read_hash_ref} ) {
						my $i = ${$info_ref}[0]-1;
						my $read_info_ref = ${$all_info_read_ref}[$read_ID];
						my @SJs_read_info = @{${$read_info_ref}{'SJcorSeqRef'}};
						my $SJ_read_info_ref = $SJs_read_info[$i];
						die "cannot correspond $SJ of cluster $l of read group $n to ${$all_info_read_ref}[$read_ID]{'readID'}: ${$SJ_read_info_ref}[1]" if ${$SJ_read_info_ref}[1] ne $SJ;
						my ($length_r, $length_f) = (${$SJ_read_info_ref}[0], ${$read_info_ref}{'read_length'} - ${$SJ_read_info_ref}[0]);
						my $strand_adapted_SJ_pos;
						if( ${$read_info_ref}{'notSameStrand'} == 1 ) {
							$strand_adapted_SJ_pos = $length_f;
						} else {
							$strand_adapted_SJ_pos = $length_r;
						}
						push @{$read_seq_pos{$index_ori}}, [$read_ID, $strand_adapted_SJ_pos, 0, 0];
						if ($i == 0){
							$read_seq_pos{$index_ori}[-1][-2] = $length_r;
							$max_length_cluster{$index_ori}[0] = $length_r if $max_length_cluster{$index_ori}[0] < $length_r;
						} if ($i == $#SJs_read_info) {
							$read_seq_pos{$index_ori}[-1][-1] = $length_f;
							$max_length_cluster{$index_ori}[1] = $length_f if $max_length_cluster{$index_ori}[1] < $length_f;
						}
					}
					@perfect_reads = grep {${$read_hash_ref}{$_}[2]+${$read_hash_ref}{$_}[3]+${$read_hash_ref}{$_}[4]==0} keys %{$read_hash_ref};
					if ($isHC == 1){
						${$all_info_read_ref}[$_]{'SJcorSeqRef'}[ ${$read_hash_ref}{$_}[0]-1 ][2] = scalar(@perfect_reads) for @perfect_reads;
					}
				} else {
					printf BACKUP "0\n";
				}
				

				### require perfect read count, ratio and matched splicing signals
				if ($isHC == 1){
					$max_length_cluster{$index_ori}[2] += 2;
				}

			}

			printf BACKUP "cluster_info:\t$l\t$index_ori\t$max_length_cluster{$index_ori}[0]\t$max_length_cluster{$index_ori}[1]\t$max_length_cluster{$index_ori}[2]\t$max_length_cluster{$index_ori}[3]\t",  scalar(@{$read_seq_pos{$index_ori}}), "\n";
			if (@{$read_seq_pos{$index_ori}} > 0) {
				$num_mt0_index_ori ++;
				my @SJ_ends_current_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori}};
				my @index_ori_pre_qualified;
				#print ALLSJ "possible length_r of $index_ori($max_length_cluster{$index_ori}[0]):";
				for my $rev_p (1 .. $l) {
					my $p = $l - $rev_p;
					my $index_ori_pre = $SJ_cluster_r_index_sort[$p];
					my @SJ_ends_pre_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori_pre}};
					my $dist = $SJ_ends_current_cluster[0]-$SJ_ends_pre_cluster[1];
					if ( $max_length_cluster{$index_ori}[0]*$fold_end_length_lost_cutoff >= $dist and $dist > 0-$max_overlap_SJ_group ){
						push @index_ori_pre_qualified, [$index_ori_pre, $dist];
						#print ALLSJ "\t$index_ori_pre($dist)";
					} elsif ($max_length_cluster{$index_ori}[0]*$fold_end_length_lost_cutoff < $dist) {
						last;
					}

				}
				
				#print ALLSJ "\n";

				if (@index_ori_pre_qualified > 0) {
					for my $read_pos_ref (@{$read_seq_pos{$index_ori}}) {
						my ($read_ID, $strand_adapted_SJ_pos, $length_r, $length_f) = @{$read_pos_ref};
						#print ALLSJ "length_r of $read_ID($length_r):";
						if ($length_r > 0) {
							for my $index_ori_pre_ref (@index_ori_pre_qualified) {
								my ($index_ori_pre, $dist) = @{$index_ori_pre_ref};
								if ($length_r*$fold_end_length_lost_cutoff >= $dist) {
									push @{$read_seq_pos{$index_ori_pre}}, [$read_ID, $strand_adapted_SJ_pos, -1, 0];
									#print ALLSJ "\t$index_ori_pre($dist)";
								} else {
									last;
								}

							}
						}
						#print ALLSJ "\n";
					}
				}
			}

		}

		printf BACKUP "SJ_read:%g\tnum_mt0_index_ori:%g\n", scalar(%SJ_read), $num_mt0_index_ori;
		for my $l (0 .. $#SJ_cluster_f_index_sort) {
			my $index_ori = $SJ_cluster_f_index_sort[$l];
			next unless $max_length_cluster{$index_ori}[2] > 0;
			
			if (@{$read_seq_pos{$index_ori}} > 0) {
				my @SJ_ends_current_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori}};
				my @index_ori_next_qualified;
				#print ALLSJ "possible length_f of $index_ori($max_length_cluster{$index_ori}[1]):";
				for my $rev_p (1 .. $l) {
					my $p = $l - $rev_p;
					my $index_ori_next = $SJ_cluster_f_index_sort[$p];
					my @SJ_ends_next_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori_next}};
					my $dist = $SJ_ends_next_cluster[0]-$SJ_ends_current_cluster[1];
					if ( $max_length_cluster{$index_ori}[1]*$fold_end_length_lost_cutoff >= $dist and $dist > 0-$max_overlap_SJ_group ){
						#print ALLSJ "\t$index_ori_next($dist)";
						push @index_ori_next_qualified, [$index_ori_next, $dist];
					} elsif ( $max_length_cluster{$index_ori}[1]*$fold_end_length_lost_cutoff < $dist ) {
						last;
					}

				}
				#print ALLSJ "\n";
				if (@index_ori_next_qualified > 0) {
					for my $read_pos_ref (@{$read_seq_pos{$index_ori}}) {
						my ($read_ID, $strand_adapted_SJ_pos, $length_r, $length_f) = @{$read_pos_ref};
						#print ALLSJ "length_f of $read_ID($length_f):";
						if ($length_f > 0) {
							for my $index_ori_next_ref (@index_ori_next_qualified) {
								my ($index_ori_next, $dist) = @{$index_ori_next_ref};
								if ($length_f*$fold_end_length_lost_cutoff >= $dist) {
									push @{$read_seq_pos{$index_ori_next}}, [$read_ID, $strand_adapted_SJ_pos, 0, -1];
									#print ALLSJ "\t$index_ori_next($dist)";
								} else {
									last;
								}

							}
						} elsif ($length_r == -1) {
							last;
						}
						#print ALLSJ "\n";
					}
				}
			}
		}

		open TOBLAST, ">", "$in/$target_ID/blast_$n/read_group_$same_group_count.fa" or die "cannot write to $in/$target_ID/blast_$n/read_group_$same_group_count.fa";
		my ($max_index,undef) = sort {$b <=> $a} keys %{$group_SJ_cluster_ref};
		for my $index_ori (0 .. $max_index) {
			#next unless exists ${$group_SJ_cluster_ref}{$index_ori};
			next unless exists $read_seq_pos{$index_ori};
			my $current_cluster_SJ_number = grep {${$_}[1]>0} @{${$group_SJ_cluster_ref}{$index_ori}};
			#print ALLSJ "reviseN: $index_ori($current_cluster_SJ_number)\n";
			if (@{$read_seq_pos{$index_ori}} > 0 and $max_length_cluster{$index_ori}[2] > 0) {
				my @reads_seq4realign;
				my @reads_cluster_sort = sort { ${$a}[0] cmp ${$b}[0] } @{$read_seq_pos{$index_ori}};
				my ($last_read, %last_read2extract);
				for my $read_pos_ref (@reads_cluster_sort) {
					my ($read_ID, $strand_adapted_SJ_pos, $length_r, $length_f) = @{$read_pos_ref};
					if (defined $last_read and $last_read ne $read_ID) {
						my $read_info_ref = ${$all_info_read_ref}[$last_read];
						my $read_seq4blast = ${$read_info_ref}{'readSeq'};
						my $read_length = ${$read_info_ref}{'read_length'};
						my $notSameStrand = ${$read_info_ref}{'notSameStrand'};
						my (@sort_pos_SJ, $key_index);
						@sort_pos_SJ = sort {$a <=> $b} keys %last_read2extract;


						for my $i (0 .. $#sort_pos_SJ) {
							my $pos = $sort_pos_SJ[$i];
							#print ALLSJ "reviseN: $index_ori($current_cluster_SJ_number): $last_read($pos:$read_length:$notSameStrand:@{$last_read2extract{$pos}}): $i($#sort_pos_SJ)\n";
							if ($i == $#sort_pos_SJ) {
								if ( ($last_read2extract{$pos}[1-$notSameStrand] == 0 or ($current_cluster_SJ_number == 1 and $last_read2extract{$pos}[1-$notSameStrand] > 0)) and $pos+$SJFS_dist_add+2*$SJFS_dist<$read_length ) {
									substr($read_seq4blast, $pos+$SJFS_dist_add+2*$SJFS_dist) = 'N' x ($read_length-$pos-$SJFS_dist_add-2*$SJFS_dist);
								}
							} if ( $i == 0 ) {
								if ( ($last_read2extract{$pos}[$notSameStrand] == 0 or ($current_cluster_SJ_number == 1 and $last_read2extract{$pos}[$notSameStrand] > 0)) and $pos-$SJFS_dist_add-2*$SJFS_dist>0 ) {
									substr($read_seq4blast, 0, $pos-$SJFS_dist_add-2*$SJFS_dist) = 'N' x ($pos-$SJFS_dist_add-2*$SJFS_dist);
								}
							} else {
								my $replaceable_length = $pos - $sort_pos_SJ[$i-1]-2*($SJFS_dist_add+2*$SJFS_dist);
								if ($replaceable_length > 0) {
									substr($read_seq4blast, $sort_pos_SJ[$i-1]+$SJFS_dist_add+2*$SJFS_dist, $replaceable_length) = 'N' x $replaceable_length;
								}
							}
						}
						push @reads_seq4realign, (">$last_read SJclst:$index_ori:",$read_seq4blast);
						%last_read2extract = ();
					}
					if (!exists $last_read2extract{$strand_adapted_SJ_pos}) {
						$last_read2extract{$strand_adapted_SJ_pos} = [$length_r, $length_f];
					} else {
						if ( $length_r != 0 ) {
							$last_read2extract{$strand_adapted_SJ_pos}[0] = $length_r;
						} if ( $length_f != 0 ) {
							$last_read2extract{$strand_adapted_SJ_pos}[1] = $length_f;
						}
					}
					
					$last_read = $read_ID;
				}

					if (defined $last_read) {
						my $read_info_ref = ${$all_info_read_ref}[$last_read];
						my $read_seq4blast = ${$read_info_ref}{'readSeq'};
						my $read_length = ${$read_info_ref}{'read_length'};
						my $notSameStrand = ${$read_info_ref}{'notSameStrand'};
						my (@sort_pos_SJ, $key_index);
						@sort_pos_SJ = sort {$a <=> $b} keys %last_read2extract;


						for my $i (0 .. $#sort_pos_SJ) {
							my $pos = $sort_pos_SJ[$i];
							#print ALLSJ "reviseN: $index_ori($current_cluster_SJ_number): $last_read($pos:$read_length:$notSameStrand:@{$last_read2extract{$pos}}): $i($#sort_pos_SJ)\n";
							if ($i == $#sort_pos_SJ) {
								if ( ($last_read2extract{$pos}[1-$notSameStrand] == 0 or ($current_cluster_SJ_number == 1 and $last_read2extract{$pos}[1-$notSameStrand] > 0)) and $pos+$SJFS_dist_add+2*$SJFS_dist<$read_length ) {
									substr($read_seq4blast, $pos+$SJFS_dist_add+2*$SJFS_dist) = 'N' x ($read_length-$pos-$SJFS_dist_add-2*$SJFS_dist);
								}
							} if ( $i == 0 ) {
								if ( ($last_read2extract{$pos}[$notSameStrand] == 0 or ($current_cluster_SJ_number == 1 and $last_read2extract{$pos}[$notSameStrand] > 0)) and $pos-$SJFS_dist_add-2*$SJFS_dist>0 ) {
									substr($read_seq4blast, 0, $pos-$SJFS_dist_add-2*$SJFS_dist) = 'N' x ($pos-$SJFS_dist_add-2*$SJFS_dist);
								}
							} else {
								my $replaceable_length = $pos - $sort_pos_SJ[$i-1]-2*($SJFS_dist_add+2*$SJFS_dist);
								if ($replaceable_length > 0) {
									substr($read_seq4blast, $sort_pos_SJ[$i-1]+$SJFS_dist_add+2*$SJFS_dist, $replaceable_length) = 'N' x $replaceable_length;
								}
							}
						}
						push @reads_seq4realign, (">$last_read SJclst:$index_ori:",$read_seq4blast);
						%last_read2extract = ();
					}
				
				print TOBLAST "$_\n" for @reads_seq4realign;
				$max_length_cluster{$index_ori}[3] += @reads_seq4realign;

			}
		}

		close TOBLAST;

		if (defined $keep_tmp) {
			close BACKUP;
		}

		my ($current_line, $accumul_read_line, $accumul_SJ_line) = (1, 0, 0);
		my @accumul_SJ_string = ();
		for my $index_ori (0 .. $max_index) {
			#next unless exists ${$group_SJ_cluster_ref}{$index_ori};
			$accumul_read_line += $max_length_cluster{$index_ori}[3];
			$accumul_SJ_line += $max_length_cluster{$index_ori}[2];
			push @accumul_SJ_string, "-e \"SJclst:$index_ori:\"" if $max_length_cluster{$index_ori}[2]>0;
			if ($accumul_SJ_line >= 40){ #$accumul_SJ_line*$accumul_read_line >= 100_000 or 
				if ( $accumul_read_line>0 ){
					my $exit_db = system("grep -A1 --no-group-separator @accumul_SJ_string $out_dir/SJ_group.fa | makeblastdb -in - -dbtype nucl -out $out_dir/current_db -title current_db");
					if ($exit_db != 0) {
						warn "Failed to run \"grep -A1 --no-group-separator @accumul_SJ_string $out_dir/SJ_group.fa | makeblastdb -in - -dbtype nucl -out $out_dir/current_db -title current_db\". Exit code is $exit_db";
					}
					my $exit_blast = system("tail -n +$current_line $out_dir/read_group_$same_group_count.fa | head -$accumul_read_line | blastn -task blastn -db $out_dir/current_db -query - -word_size 4 -reward 5 -penalty -4 -gapopen 8 -gapextend 6 -num_threads 1 -evalue $evalue_cor -dust no -soft_masking false -outfmt \"6 std btop\" >> $out_dir/read_SJ_group_$same_group_count.blast");
					if ($exit_blast != 0) {
						warn "Failed to run \"tail -n +$current_line $out_dir/read_group_$same_group_count.fa | head -$accumul_read_line | blastn -task blastn -db $out_dir/current_db -query - -word_size 4 -reward 5 -penalty -4 -gapopen 8 -gapextend 6 -num_threads 1 -evalue $evalue_cor -dust no -soft_masking false -outfmt \"6 std btop\" >> $out_dir/read_SJ_group_$same_group_count.blast\"($accumul_SJ_line). Exit code is $exit_blast";
					}
				}

				$current_line += $accumul_read_line;
				($accumul_read_line, $accumul_SJ_line) = (0, 0);
				@accumul_SJ_string = ();
			}			
		}

			if ($accumul_SJ_line*$accumul_read_line >0){
				my $exit_db = system("grep -A1 --no-group-separator @accumul_SJ_string $out_dir/SJ_group.fa | makeblastdb -in - -dbtype nucl -out $out_dir/current_db -title current_db");
				if ($exit_db != 0) {
					warn "Failed to run \"grep -A1 --no-group-separator @accumul_SJ_string $out_dir/SJ_group.fa | makeblastdb -in - -dbtype nucl -out $out_dir/current_db -title current_db\". Exit code is $exit_db";
				}
				my $exit_blast = system("tail -n +$current_line $out_dir/read_group_$same_group_count.fa | head -$accumul_read_line | blastn -task blastn -db $out_dir/current_db -query - -word_size 4 -reward 5 -penalty -4 -gapopen 8 -gapextend 6 -num_threads 1 -evalue $evalue_cor -dust no -soft_masking false -outfmt \"6 std btop\" >> $out_dir/read_SJ_group_$same_group_count.blast");
				if ($exit_blast != 0) {
					warn "Failed to run \"tail -n +$current_line $out_dir/read_group_$same_group_count.fa | head -$accumul_read_line | blastn -task blastn -db $out_dir/current_db -query - -word_size 4 -reward 5 -penalty -4 -gapopen 8 -gapextend 6 -num_threads 1 -evalue $evalue_cor -dust no -soft_masking false -outfmt \"6 std btop\" >> $out_dir/read_SJ_group_$same_group_count.blast\"($accumul_SJ_line). Exit code is $exit_blast";
				}
			}

		if (!defined $keep_tmp) {
			unlink "$out_dir/read_group_$same_group_count.fa";
			unlink "$out_dir/current_db.nhr";
			unlink "$out_dir/current_db.nin";
			unlink "$out_dir/current_db.nsq";
		}

		my $output_blast;

		if ( -s $out_dir."/read_SJ_group_$same_group_count.blast" > 0 ) {
			$output_blast = $out_dir."/read_SJ_group_$same_group_count.sort.blast";
			my $exit_sort = system("sort -k1,1 -k12,12r $out_dir/read_SJ_group_$same_group_count.blast > $output_blast");
			if ($exit_sort != 0) {
				warn "Failed to run \"sort -k1,1 -k12,12r $out_dir/read_SJ_group_$same_group_count.blast > $output_blast\". Exit code is $exit_sort";
			}
		} else {
			for my $read_ID(0 .. $#{$all_info_read_ref}){
				if ($recorded_index[$read_ID] == 1){
					$read_no_SJ{$read_ID} = 1;
				}
			}
		}

		if (scalar(keys %read_no_SJ) > 0){
			open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
			while (my ($read_ID, undef) = each %read_no_SJ) {
				my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
				my $out = &summary_final_output(${$all_info_read_ref}[$read_ID], $n, $read_ID_update, \%hc_SJ);
				print READ_FINAL $out;
			}

			close READ_FINAL;
		}

		my ($last_read, @pre_ID_alignments, %recorded_SJ);
		my (%SJ_missing_candidate);
		if(defined $output_blast){
			open BLAST, "<", $output_blast or die "cannot open $output_blast:$!";
			if (defined $keep_tmp) {
				open READ_SUMM, ">", "$out_dir/lost_end_group_$n.backup" or die "cannot write $out_dir/lost_end_group_$n.backup: $!";
			}
			
			open LOST_END, ">", "$out_dir/lost_end_group_$same_group_count.fa" or die "cannot write $out_dir/missingSJ_group_$same_group_count.fa:$!";
			print READ_SUMM "$out_dir/lost_end_group_$same_group_count.fa loaded\n";
			while (<BLAST>) {
				s/\r\n//;
				chomp;
				my @line = split /\t/;
				my ($read_ID, $sbjct_ID, $start, $end) = ($line[0], $line[1], $line[8], $line[9]);
				if (defined $last_read and $last_read ne $read_ID) {
					my $read_info_ref = ${$all_info_read_ref}[$last_read];
					my $read_seq = ${$read_info_ref}{'readSeq'};
					my $read_length = ${$read_info_ref}{'read_length'};
					my $putative_total_all = ${$read_info_ref}{'totalNumBg'}+$SJFS_dist*2;
					my @align_sort = sort { ${$a}{'query_start'} <=> ${$b}{'query_start'} or ${$a}{'query_end'}  <=> ${$b}{'query_end'}  } @pre_ID_alignments;
					my $best_SJ_ref = &reliable_SJ_from_blast(\@align_sort, ${$read_info_ref}{'SJcorSeqRef'}, ${$read_info_ref}{'IDS_SJ_ref'}, ${$read_info_ref}{'notSameStrand'}, $read_length, $SJFS_dist*2, $putative_total_all, ${$read_info_ref}{'clip_ends'}, [${$read_info_ref}{'insNumBg'}, ${$read_info_ref}{'delNumBg'}, ${$read_info_ref}{'substNumBg'}], \%hc_SJ);
					print READ_SUMM "$last_read\t",scalar(@align_sort),"\t$read_length\n";

					${$read_info_ref}{'notSameStrand_ori'} = ${$best_SJ_ref}[2];
					if (${$best_SJ_ref}[2] eq '0' or ${$best_SJ_ref}[2] eq '1'){
						print READ_SUMM "best_SJ: @{$_}\n" for values %{${$best_SJ_ref}[0]};
						${$read_info_ref}{'best_SJ'} = ${$best_SJ_ref}[0];
						${$read_info_ref}{'additional_SJ'} = ${$best_SJ_ref}[1];

						my %isoform_candidates;
						while(my ($pos, $type_ref) = each %{${$best_SJ_ref}[1]}) {
							my @sort_SJ_add = sort {${$type_ref}{$b}[1] <=> ${$type_ref}{$a}[1]} keys %{$type_ref};

							for my $i (0 .. $#sort_SJ_add) {
								if ( ${$type_ref}{$sort_SJ_add[$i]}[1]*$confirm_prob_fold_cutoff >= ${$type_ref}{$sort_SJ_add[$i-1]}[1] ){
									my $SJ2 = $sort_SJ_add[$i];
									my $SJ2_ref = ${$type_ref}{$SJ2};

									if ( $pos eq "-1" ){
										my $length4nhmmer = &min($length4nhmmer_max, ${$SJ2_ref}[2]);
										my $seq4hmmmer = substr( $read_seq, ${$SJ2_ref}[2]-$length4nhmmer, &min($length4nhmmer+$SJFS_dist+$SJFS_dist_add, $read_length-(${$SJ2_ref}[2]-$length4nhmmer)) );
										my $extra_length = &min($SJFS_dist+$SJFS_dist_add, $read_length-${$SJ2_ref}[2]);
										print LOST_END ">${last_read}$sep_end_blast$SJ2$sep_end_blast-1$sep_end_blast${$read_info_ref}{'notSameStrand'}$sep_end_blast", length($seq4hmmmer), "$sep_end_blast$extra_length$sep_end_blast${$SJ2_ref}[2]\n$seq4hmmmer\n";
										$SJ_missing_candidate{$SJ2}{0-${$read_info_ref}{'notSameStrand'}}{$last_read} = ${$SJ2_ref}[2];
									} else {
										my $length4nhmmer = &min($length4nhmmer_max, $read_length-${$SJ2_ref}[2]);
										my $seq4hmmmer;
										my $extra_length;
										if(${$SJ2_ref}[2]>=$SJFS_dist+$SJFS_dist_add) {
											$seq4hmmmer = substr($read_seq, ${$SJ2_ref}[2]-($SJFS_dist+$SJFS_dist_add), $length4nhmmer+$SJFS_dist+$SJFS_dist_add);
											$extra_length = $SJFS_dist+$SJFS_dist_add;
										} else {
											$seq4hmmmer = substr($read_seq, 0, $length4nhmmer+${$SJ2_ref}[2]);
											$extra_length = ${$SJ2_ref}[2];
										}
										print LOST_END ">${last_read}$sep_end_blast$SJ2$sep_end_blast-2$sep_end_blast${$read_info_ref}{'notSameStrand'}$sep_end_blast", length($seq4hmmmer), "$sep_end_blast$extra_length$sep_end_blast", $read_length-${$SJ2_ref}[2], "\n$seq4hmmmer\n";
										$SJ_missing_candidate{$SJ2}{${$read_info_ref}{'notSameStrand'}-1}{$last_read} = $read_length-${$SJ2_ref}[2];
										${$read_info_ref}{'read_SJ_missing'}{${$read_info_ref}{'notSameStrand'}-1}{$SJ2} = $read_length-${$SJ2_ref}[2]+$extra_length;
									}
								}
							}
						}
					}

					@pre_ID_alignments = ();
					%recorded_SJ = ();
				}
				if ( !exists $recorded_SJ{$sbjct_ID} and &min($start,$end)<=$SJFS_dist_add and &max($start,$end)>=2*$SJFS_dist+$SJFS_dist_add and ( (${$all_info_read_ref}[$read_ID]{'notSameStrand'}==1 and $start>$end) or (${$all_info_read_ref}[$read_ID]{'notSameStrand'}==0 and $start<$end)) and ( $is_stranded !=1 or $hc_SJ{$sbjct_ID}[0] eq ${$all_info_read_ref}[$read_ID]{'notSameStrand'}) ) {					
					push @pre_ID_alignments, &ID_align_btop($line[-1],[$line[6], $line[7]],[$line[8], $line[9]],$sbjct_ID);
					$recorded_SJ{$sbjct_ID} = 1;
				}
				
				$last_read = $read_ID;
			}

			close BLAST;

				if (defined $last_read ) {
					my $read_info_ref = ${$all_info_read_ref}[$last_read];
					my $read_seq = ${$read_info_ref}{'readSeq'};
					my $read_length = ${$read_info_ref}{'read_length'};
					my $putative_total_all = ${$read_info_ref}{'totalNumBg'}+$SJFS_dist*2;
					my @align_sort = sort { ${$a}{'query_start'} <=> ${$b}{'query_start'} or ${$a}{'query_end'}  <=> ${$b}{'query_end'}  } @pre_ID_alignments;
					my $best_SJ_ref = &reliable_SJ_from_blast(\@align_sort, ${$read_info_ref}{'SJcorSeqRef'}, ${$read_info_ref}{'IDS_SJ_ref'}, ${$read_info_ref}{'notSameStrand'}, $read_length, $SJFS_dist*2, $putative_total_all, ${$read_info_ref}{'clip_ends'}, [${$read_info_ref}{'insNumBg'}, ${$read_info_ref}{'delNumBg'}, ${$read_info_ref}{'substNumBg'}], \%hc_SJ);
					print READ_SUMM "$last_read\t",scalar(@align_sort),"\n";

					${$read_info_ref}{'notSameStrand_ori'} = ${$best_SJ_ref}[2];
					if (${$best_SJ_ref}[2] eq '0' or ${$best_SJ_ref}[2] eq '1'){
						print READ_SUMM "best_SJ: @{$_}\n" for values %{${$best_SJ_ref}[0]};
						${$read_info_ref}{'best_SJ'} = ${$best_SJ_ref}[0];
						${$read_info_ref}{'additional_SJ'} = ${$best_SJ_ref}[1];
							
						my %isoform_candidates;
						while(my ($pos, $type_ref) = each %{${$best_SJ_ref}[1]}) {
							my @sort_SJ_add = sort {${$type_ref}{$b}[1] <=> ${$type_ref}{$a}[1]} keys %{$type_ref};

							for my $i (0 .. $#sort_SJ_add) {
								if ( ${$type_ref}{$sort_SJ_add[$i]}[1]*$confirm_prob_fold_cutoff >= ${$type_ref}{$sort_SJ_add[$i-1]}[1] ){
									my $SJ2 = $sort_SJ_add[$i];
									my $SJ2_ref = ${$type_ref}{$SJ2};

									if ( $pos eq "-1" ){
										my $length4nhmmer = &min($length4nhmmer_max, ${$SJ2_ref}[2]);
										my $seq4hmmmer = substr( $read_seq, ${$SJ2_ref}[2]-$length4nhmmer, &min($length4nhmmer+$SJFS_dist+$SJFS_dist_add, $read_length-(${$SJ2_ref}[2]-$length4nhmmer)) );
										my $extra_length = &min($SJFS_dist+$SJFS_dist_add, $read_length-${$SJ2_ref}[2]);
										print LOST_END ">${last_read}$sep_end_blast$SJ2$sep_end_blast-1$sep_end_blast${$read_info_ref}{'notSameStrand'}$sep_end_blast", length($seq4hmmmer), "$sep_end_blast$extra_length$sep_end_blast${$SJ2_ref}[2]\n$seq4hmmmer\n";
										$SJ_missing_candidate{$SJ2}{0-${$read_info_ref}{'notSameStrand'}}{$last_read} = ${$SJ2_ref}[2];
									} else {
										my $length4nhmmer = &min($length4nhmmer_max, $read_length-${$SJ2_ref}[2]);
										my $seq4hmmmer;
										my $extra_length;
										if(${$SJ2_ref}[2]>=$SJFS_dist+$SJFS_dist_add) {
											$seq4hmmmer = substr($read_seq, ${$SJ2_ref}[2]-($SJFS_dist+$SJFS_dist_add), $length4nhmmer+$SJFS_dist+$SJFS_dist_add);
											$extra_length = $SJFS_dist+$SJFS_dist_add;
										} else {
											$seq4hmmmer = substr($read_seq, 0, $length4nhmmer+${$SJ2_ref}[2]);
											$extra_length = ${$SJ2_ref}[2];
										}
										print LOST_END ">${last_read}$sep_end_blast$SJ2$sep_end_blast-2$sep_end_blast${$read_info_ref}{'notSameStrand'}$sep_end_blast", length($seq4hmmmer), "$sep_end_blast$extra_length$sep_end_blast", $read_length-${$SJ2_ref}[2], "\n$seq4hmmmer\n";
										$SJ_missing_candidate{$SJ2}{${$read_info_ref}{'notSameStrand'}-1}{$last_read} = $read_length-${$SJ2_ref}[2];
										${$read_info_ref}{'read_SJ_missing'}{${$read_info_ref}{'notSameStrand'}-1}{$SJ2} = $read_length-${$SJ2_ref}[2]+$extra_length;
									}
								}
							}
						}
					}

					@pre_ID_alignments = ();
					%recorded_SJ = ();
				}

			#close READ_SUMM;

			if (!defined $keep_tmp) {
				unlink $out_dir."/read_SJ_group_$same_group_count.blast";
				unlink $output_blast;
			}

			close LOST_END;

			my $flankSJfile = "$out_dir/flankingSJ_group_$same_group_count.fa";
			my ($db_size, $db_SJ_type_num) = (0, 0);
			my @flankSJfile_SJ_types;
			
			if(-s "$out_dir/lost_end_group_$same_group_count.fa" > 0) {
				my $m = 0;
				my @info_m;
				open FLANK_SJ, ">", $flankSJfile or die "cannot write $flankSJfile:$!";
				
				while (my ($SJ, $type_ref) = each %SJ_missing_candidate) {
					while (my ($type, $read_ref) = each %{$type_ref}) {
						$m ++;
						#my @length_sort = sort { $b <=> $a } values %{$read_ref};
						#my $length4nhmmer = &min(200, int($length_sort[0]));
						my $length4nhmmer = $length4nhmmer_max;
						my ($substr_chr_SJ, $substr_chr_flanking);
						my @SJ_cor = split $sep_SJ, $SJ;
						my ($strand_pos1, $strand_pos2) = ("$SJ/-1/","$SJ/-2/");
						if ($type eq '0') {
							my $mapped_seq = substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[2], ($SJFS_dist+$SJFS_dist_add) );
							$substr_chr_SJ = 		substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[1]-&min($length4nhmmer+$END_dist_add, $SJ_cor[1]), &min($length4nhmmer+$END_dist_add, $SJ_cor[1]) ).$mapped_seq;
							$substr_chr_flanking = 	substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[2]-&min($length4nhmmer+$END_dist_add, $SJ_cor[2]), &min($length4nhmmer+$END_dist_add, $SJ_cor[2]) ).$mapped_seq;
							$strand_pos1 .= '0/';
							$strand_pos2 .= '1/';
						} else {
							my $mapped_seq = substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[1]-($SJFS_dist+$SJFS_dist_add), ($SJFS_dist+$SJFS_dist_add) );
							$substr_chr_SJ = 		$mapped_seq.substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[2], &min($length4nhmmer+$END_dist_add, $chr_seq_len{$SJ_cor[0]}-$SJ_cor[2]) );
							$substr_chr_flanking = 	$mapped_seq.substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[1], &min($length4nhmmer+$END_dist_add, $chr_seq_len{$SJ_cor[0]}-$SJ_cor[1]) );
							$strand_pos1 .= '1/';
							$strand_pos2 .= '0/';
						}
						my ($SJ_seq_s, $flank_seq_s) = (length($substr_chr_SJ), length($substr_chr_flanking));
						
						print FLANK_SJ ">$SJ$sep_end_blast$type${sep_end_blast}SJ$sep_end_blast",$SJ_seq_s,"\n$substr_chr_SJ\n";
						print FLANK_SJ ">$SJ$sep_end_blast$type${sep_end_blast}flanking$sep_end_blast",$flank_seq_s,"\n$substr_chr_flanking\n";

						push @info_m, [$strand_pos1, $strand_pos2, scalar(values %{$read_ref})*2];

					}
				}
				close FLANK_SJ;
				die "$m != @info_m" if @info_m != $m;
				my ($start_line, $accumul_SJ_line, $accumul_read_line, $accumul_SJ_string) = (1, 0, 0, '');

				for my $i (1 .. $m) {
					
					my ($strand_pos1, $strand_pos2, $read_line) = @{$info_m[$i-1]};
					$accumul_SJ_string .= " -e $strand_pos1 -e $strand_pos2";
					$accumul_SJ_line += 4;
					$accumul_read_line += $read_line;
					if ($accumul_SJ_line>=100) {
						system("tail -n +$start_line $flankSJfile | head -$accumul_SJ_line > $out_dir/current_flankingSJ.fa");
						my $exit_nhmmer = system("grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_$i.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null");
						if ($exit_nhmmer != 0) {
							warn "Failed to run \"grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_$i.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null\". Exit code is $exit_nhmmer"; 
						}
						$start_line += $accumul_SJ_line;
						($accumul_SJ_line, $accumul_read_line, $accumul_SJ_string) = (0, 0, '');
					}
				}

				if ($accumul_SJ_line*$accumul_read_line > 0 and $m > 0) {
						system("tail -n +$start_line $flankSJfile | head -$accumul_SJ_line > $out_dir/current_flankingSJ.fa");
						my $exit_nhmmer = system("grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_0.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null");
						if ($exit_nhmmer != 0) {
							warn "Failed to run \"grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_0.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null\". Exit code is $exit_nhmmer"; 
						}
				}

				

			}
			if (!defined $keep_tmp) {
				unlink $flankSJfile;
				unlink "$out_dir/lost_end_group_$same_group_count.fa";
			}
			my (@blasts_lost, $blast_lost);
			@blasts_lost = glob("$out_dir/lost_end_group_${same_group_count}_*.hmmer1");
			if (@blasts_lost > 0) {
				$blast_lost = "$out_dir/lost_end_group.hmmer2";
				system("cat @blasts_lost > $out_dir/lost_end_groups.hmmer1");
				if (-s "$out_dir/lost_end_groups.hmmer1">0){
					my $exit_sort = system("sort -k3,3 -k14,14r -s $out_dir/lost_end_groups.hmmer1 > $blast_lost");
					if ($exit_sort != 0) {
						warn "Failed to run \"sort -k3,3 -k14,14r -s $out_dir/lost_end_groups.hmmer1 > $blast_lost\". Exit code is $exit_sort";
					}
				}
				if (!defined $keep_tmp) {
					unlink "$_" for @blasts_lost;
					unlink "$out_dir/lost_end_groups.hmmer1";
					unlink "$out_dir/current_flankingSJ.fa";
				}
			}
			
			if(defined $blast_lost and -s $blast_lost > 0 ){
	
				my ($last_read, $last_pos, %last_read_info);
				open HMMER2, "<", $blast_lost or die "cannot open $blast_lost: $!";
				print READ_SUMM "$blast_lost loaded\n";
				while (<HMMER2>) {
					chomp;
					my @line = split /\s+/;
					next if $line[0] eq '#';
					my ($read_ID, $SJ2, $pos, $notSameStrand, $length, $extra_length, $length_raw) = split $sep_end_blast, $line[2];
					my ($SJ, $type, $cand_type, $length_G) = split $sep_end_blast, $line[0];		
					my @SJ_cor = split $sep_SJ, $SJ2;
					
					if(defined $last_read and ($last_read ne $read_ID or $pos ne $last_pos) ) {
						if (exists $last_read_info{'SJ'}) {
							my @SJ_sort = sort { $last_read_info{'SJ'}{$b}[0] <=> $last_read_info{'SJ'}{$a}[0] } keys %{$last_read_info{'SJ'}};
							my $candidate_SJ = $SJ_sort[0];

							if (!exists $last_read_info{'flanking'} or !exists $last_read_info{'flanking'}{$candidate_SJ} or $last_read_info{'SJ'}{$candidate_SJ}[0]-$last_read_info{'flanking'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff ){
								if ( @SJ_sort == 1 or $last_read_info{'SJ'}{$candidate_SJ}[0] - $last_read_info{'SJ'}{$SJ_sort[1]}[0] >= $blast_score_difference_cutoff ) {
									${$all_info_read_ref}[$last_read]{$last_pos.'_update'} = [$last_read_info{'SJ'}{$candidate_SJ}[2], $last_read_info{'SJ'}{$candidate_SJ}[3]];
									${$all_info_read_ref}[$last_read]{$last_pos} = $candidate_SJ;
									print READ_SUMM "${last_pos}_update:\t$last_read\t$last_pos\t$candidate_SJ\t@{${$all_info_read_ref}[$last_read]{$last_pos.'_update'}}\n";
								} else {
									${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD';
									print READ_SUMM "${last_pos}_not_update:\t$last_read\t$last_pos\t$candidate_SJ\n";
								}
							} elsif (exists $last_read_info{'flanking'}{$candidate_SJ} and $last_read_info{'flanking'}{$candidate_SJ}[0]-$last_read_info{'SJ'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff) {
								print READ_SUMM "${last_pos}_no_add:\t$last_read\t$last_pos\n";
							} else {
								${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD2';
								print READ_SUMM "${last_pos}_not_sure:\t$last_read\t$last_pos\n";
							}
						} elsif (exists $last_read_info{'flanking'}) {
							print READ_SUMM "${last_pos}_no_add2:\t$last_read\t$last_pos\n";
						} else {
							${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD3';
							print READ_SUMM "${last_pos}_not_sure2:\t$last_read\t$last_pos\n";
						}
						%last_read_info = ();
					}

					if ( $SJ2 eq $SJ ) {
						my $tag = 0;

						if ($pos eq '-1' and 0-$notSameStrand== $type and $length-$line[5]<=$extra_length) { #$length-$line[5]<=$SJFS_dist+$SJFS_dist_add
							$tag = 1;
						} elsif ($pos eq '-2' and $notSameStrand-1== $type and $line[4]<=$extra_length) {
							$tag = 2;
						}
						my $pos_update_read;
						if ($pos eq '-1') {
							$pos_update_read = $line[4]+$length_raw-($length-$extra_length);
						} elsif(exists ${$all_info_read_ref}[$read_ID]{'read_SJ_missing'}{${$all_info_read_ref}[$read_ID]{'notSameStrand'}-1}{$SJ}) {
							$pos_update_read = ${$all_info_read_ref}[$read_ID]{'read_SJ_missing'}{${$all_info_read_ref}[$read_ID]{'notSameStrand'}-1}{$SJ}-$line[5];#$SJ_missing_candidate{$SJ}{${$all_info_read_ref}{$read_ID}{'notSameStrand'}-1}{$read_ID}+($SJFS_dist+$SJFS_dist_add)-$line[7];
						} else {
							die "$pos:doesn't exists ${$all_info_read_ref}[$read_ID]{'readID'} read_SJ_missing ${$all_info_read_ref}[$read_ID]{'notSameStrand'} $SJ";
						}
						if ($tag > 0 and $type eq '0' and $length_G-&max($line[6], $line[7])<=$SJFS_dist+$SJFS_dist_add and abs($line[6]-$line[7])+1 > $SJFS_dist+$SJFS_dist_add and !exists $last_read_info{$cand_type}{$SJ}) { # and !exists ${$all_info_read_ref}{$read_ID}{'start_update'}
							$last_read_info{$cand_type}{$SJ} = [$line[-3], $line[-4], $SJ_cor[1]-($length_G-($SJFS_dist+$SJFS_dist_add)-&min($line[6], $line[7])+1), $pos_update_read];

						} elsif ($tag > 0 and $type eq '-1' and &min($line[6], $line[7])-1<=$SJFS_dist+$SJFS_dist_add and abs($line[6]-$line[7])+1 > $SJFS_dist+$SJFS_dist_add and !exists $last_read_info{$cand_type}{$SJ}) { # and !exists ${$all_info_read_ref}{$read_ID}{'end_update'}
							$last_read_info{$cand_type}{$SJ} = [$line[-3], $line[-4], $SJ_cor[2]+&max($line[6], $line[7])-($SJFS_dist+$SJFS_dist_add), $pos_update_read];

						}
					}
					
					$last_read = $read_ID;
					$last_pos = $pos;
				}

				close HMMER2;

						if (exists $last_read_info{'SJ'}) {
							my @SJ_sort = sort { $last_read_info{'SJ'}{$b}[0] <=> $last_read_info{'SJ'}{$a}[0] } keys %{$last_read_info{'SJ'}};
							my $candidate_SJ = $SJ_sort[0];

							if (!exists $last_read_info{'flanking'} or !exists $last_read_info{'flanking'}{$candidate_SJ} or $last_read_info{'SJ'}{$candidate_SJ}[0]-$last_read_info{'flanking'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff ){
								if ( @SJ_sort == 1 or $last_read_info{'SJ'}{$candidate_SJ}[0] - $last_read_info{'SJ'}{$SJ_sort[1]}[0] >= $blast_score_difference_cutoff ) {
									${$all_info_read_ref}[$last_read]{$last_pos.'_update'} = [$last_read_info{'SJ'}{$candidate_SJ}[2], $last_read_info{'SJ'}{$candidate_SJ}[3]];
									${$all_info_read_ref}[$last_read]{$last_pos} = $candidate_SJ;
									print READ_SUMM "${last_pos}_update:\t$last_read\t$last_pos\t$candidate_SJ\t@{${$all_info_read_ref}[$last_read]{$last_pos.'_update'}}\n";
								} else {
									${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD';
									print READ_SUMM "${last_pos}_not_update:\t$last_read\t$last_pos\t$candidate_SJ\n";
								}
							} elsif (exists $last_read_info{'flanking'}{$candidate_SJ} and $last_read_info{'flanking'}{$candidate_SJ}[0]-$last_read_info{'SJ'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff) {
								print READ_SUMM "${last_pos}_no_add:\t$last_read\t$last_pos\n";
							} else {
								${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD2';
								print READ_SUMM "${last_pos}_not_sure:\t$last_read\t$last_pos\n";
							}
						} elsif (exists $last_read_info{'flanking'}) {
							print READ_SUMM "${last_pos}_no_add2:\t$last_read\t$last_pos\n";
						} else {
							${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD3';
							print READ_SUMM "${last_pos}_not_sure2:\t$last_read\t$last_pos\n";
						}
			}
			if (defined $keep_tmp) {
				close READ_SUMM;
			} elsif (defined $blast_lost) {
				unlink $blast_lost;
			}
			
			open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";

			for my $read_ID (0 .. $#{$all_info_read_ref}) {
				my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
				my $info_ref = ${$all_info_read_ref}[$read_ID];
				next if exists $read_no_SJ{$read_ID} or !exists ${$info_ref}{'readID'};
				my $out_line = "${$all_info_read_ref}[$read_ID]{'readID'}\tSJ";
				my $out;
				my $read_length = ${$info_ref}{'read_length'};

				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tgroup_ID\t$n\t${n}_$read_ID_update\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tstrand_isoform\t${$info_ref}{'notSameStrand_ori'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tstrand_read\t${$info_ref}{'notSameStrand'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tchr\t${$info_ref}{'chr'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tmapq\t${$info_ref}{'mapq'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tflag\t${$info_ref}{'flag'}\n";

				for my $i(0 .. $#{${$info_ref}{'SJcorSeqRef'}}){
					my $j = $i + 1;
					my $SJ_info = ${$info_ref}{'SJcorSeqRef'}[$i];
					my @SJ_cor = split $sep_SJ, ${$SJ_info}[1];
					my $other_dist = $read_length-${$SJ_info}[0];
					$out .= "$out_line\t$j\t${$SJ_info}[1]\t${$SJ_info}[0]\t$other_dist\t";
					if (exists ${$info_ref}{'best_SJ'} and exists ${$info_ref}{'best_SJ'}{${$SJ_info}[1]}){
						my $SJ_info_correct = ${$info_ref}{'best_SJ'}{${$SJ_info}[1]};
						my @SJ_cor_correct = split $sep_SJ, ${$SJ_info_correct}[0];
						if (${$SJ_info_correct}[0] eq ${$SJ_info}[1]) {
							$out .= "pass\t";
						} else {
							$out .= "corrected\t";
						}
						my @dist_correct = (${$SJ_info_correct}[2], $read_length-${$SJ_info_correct}[2]);
						$out .= "${$SJ_info_correct}[0]\t$dist_correct[${$info_ref}{'notSameStrand'}]\t$dist_correct[1-${$info_ref}{'notSameStrand'}]\t${$SJ_info_correct}[1]\t";
						if (defined $hc_SJ{${$SJ_info}[1]}) {
							$out .= "$hc_SJ{${$SJ_info}[1]}[1]\t";
						} else {
							$out .= "no\t";
						}
						
						$out .= "$hc_SJ{${$SJ_info_correct}[0]}[1]\n";

					} else {
						$out .= "fail\tNA\tNA\tNA\tNA\t";
						if (defined $hc_SJ{${$SJ_info}[1]}) {
							$out .= "$hc_SJ{${$SJ_info}[1]}[1]\t";
						} else {
							$out .= "no\t";
						}
						$out .= "NA\n";
					}
				}
				my (%unmapped_ends, %mapped_genome_range);
				for my $i ('-1','-2'){
					if (exists ${$info_ref}{$i} and index(${$info_ref}{$i},'TBD')<0 ) {
						my $SJ_info = ${$info_ref}{'additional_SJ'}{$i}{ ${$info_ref}{$i} };
						my @SJ_cor = split $sep_SJ, ${$SJ_info}[0];
						my $i_convert;
						if (${$info_ref}{'notSameStrand'} == 0){
							$i_convert = $i + 1;
						} else {
							$i_convert = 0-2 - $i;
						}
						my $update = $i.'_update';
						$unmapped_ends{$i_convert} = ${$info_ref}{$update}[1];
						$mapped_genome_range{$i_convert} = ${$info_ref}{$update}[0];
						my @dist_correct = (${$SJ_info}[2], $read_length-${$SJ_info}[2]);
						$out .= "$out_line\t$i_convert\tNA\tNA\tNA\tadded\t${$SJ_info}[0]\t$dist_correct[${$info_ref}{'notSameStrand'}]\t$dist_correct[1-${$info_ref}{'notSameStrand'}]\t${$SJ_info}[1]\tNA\t";
						$out .= "$hc_SJ{${$SJ_info}[0]}[1]\n";

					}
				}

				my @unmapped_ends_raw = @{${$info_ref}{'clip_ends'}};
				my @mapped_genome_range_raw = (${$info_ref}{$ends[0]}, ${$info_ref}{$ends[1]});
				my @unmapped_ends_final = @unmapped_ends_raw;

				for my $i (0 .. $#ends){
					$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\t$ends[$i]\tNA\t";
					my $output_raw = "$mapped_genome_range_raw[$i]\t";
					if ($i == 0){
						$output_raw .= $unmapped_ends_raw[0]. "\t". ($read_length-$unmapped_ends_raw[0]). "\t";
					} else {
						$output_raw .= ($read_length-$unmapped_ends_raw[-1]). "\t". $unmapped_ends_raw[-1]. "\t";
					}
					$out .= $output_raw;
					my $output_correct;
					if (exists $mapped_genome_range{0-$i} and $i == 0) {
						if($unmapped_ends{0-$i} <= $directly_approve_length_additional) {
							$out .= "corrected\t";
						}else{
							$out .= "fail3\t";
						}
						$unmapped_ends_final[$i] = $unmapped_ends{'0'};
						$out .= "$mapped_genome_range{'0'}\t$unmapped_ends{'0'}\t". ($read_length-$unmapped_ends{'0'}). "\tNA\tNA\tNA\n";
					} elsif (exists $mapped_genome_range{0-$i}) {
						if($unmapped_ends{0-$i} <= $directly_approve_length_additional) {
							$out .= "corrected\t";
						}else{
							$out .= "fail3\t";
						}
						$unmapped_ends_final[$i] = $unmapped_ends{'-1'};
						$out .= "$mapped_genome_range{'-1'}\t". ($read_length-$unmapped_ends{'-1'}). "\t$unmapped_ends{'-1'}\tNA\tNA\tNA\n";
					} else {
						if($unmapped_ends_raw[0-$i] <= $directly_approve_length_additional) {
							$out .= "pass\t${output_raw}NA\tNA\tNA\n";
						}else{
							$out .= "fail\t${output_raw}NA\tNA\tNA\n";
						}
					}
				}
				$out .= join '', ("${$all_info_read_ref}[$read_ID]{'readID'}\tmapped_length_read\t",$read_length-$unmapped_ends_final[0]-$unmapped_ends_final[1],"\n");
				print READ_FINAL $out;
			}

			close READ_FINAL;
		} else {
			
			open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
			for my $read_ID (0 .. $#{$all_info_read_ref}) {
				next if exists $read_no_SJ{$read_ID};
				my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
				my $out = &summary_final_output(${$all_info_read_ref}[$read_ID], $n, $read_ID_update, \%hc_SJ);
				print READ_FINAL $out;
			}
			close READ_FINAL;
		}
	}


	sub reliable_SJ_from_blast {
		my @sorted_2ends = @{$_[0]}; 
		my @detected_SJ = @{$_[1]}; 
		my @IDS_original = @{$_[2]};
		my ($notSameStrand,$read_length,$sub_total,$putative_total_all, $clip_ends_ref, $IDS_total_pre_ref, $all_candidate_ref) = ($_[3],$_[4],$_[5],$_[6],$_[7],$_[8],$_[9]);
		my @best_SJ;
		my %detected_SJ_pos;
		my @clip_ends;

		if ($notSameStrand == 1) {
			%detected_SJ_pos = map {${$detected_SJ[$_]}[1] => [$read_length-${$detected_SJ[$_]}[0], ${$detected_SJ[$_]}[2], $_, $IDS_original[$_]]} (0 .. $#detected_SJ);
			@clip_ends = reverse(@{$clip_ends_ref});
		} else {
			%detected_SJ_pos = map {${$detected_SJ[$_]}[1] => [${$detected_SJ[$_]}[0], ${$detected_SJ[$_]}[2], $_, $IDS_original[$_]]} (0 .. $#detected_SJ);
			@clip_ends = @{$clip_ends_ref};
		}

		my @sorted_2ends_remove0;

		for my $read_info(@sorted_2ends) {
			my @IDS_total = map { ${$IDS_total_pre_ref}[$_]+${$read_info}{'IDM'}[$_] } (0 .. $#{$IDS_total_pre_ref});
			my $sub_total_ins = $sub_total+${$read_info}{'IDM'}[0];
			my $prob_hyperg_IDS = &calculate_probability_hypergeometric_IDS( ${$read_info}{'IDM'},\@IDS_total,$sub_total_ins,$putative_total_all+${$read_info}{'IDM'}[0] ); #,$combination_all

			print READ_SUMM "${$read_info}{$_}\t" for ('query_start', 'query_end', 'subject_start','subject_end','SJ_ID');
			print READ_SUMM "${$read_info}{$_}[0]\t${$read_info}{$_}[1]\t" for ('query_ori', 'subject_ori');
			print READ_SUMM "$_," for @{${$read_info}{'IDM'}};
			print READ_SUMM "\t$sub_total_ins\t", $putative_total_all+${$read_info}{'IDM'}[0], "\t";
			print READ_SUMM "$_," for @IDS_total;
			print READ_SUMM "\t$prob_hyperg_IDS\t";
			${$read_info}{'prob_hyperg'} = $prob_hyperg_IDS;
			my ($chr, $start,$end,$notSameStrand_SJ) = split $sep_SJ, ${$read_info}{'SJ_ID'};
			${$read_info}{'notSameStrand_SJ'} = $notSameStrand_SJ;
			print READ_SUMM "\t$notSameStrand_SJ\n";
			push @sorted_2ends_remove0, $read_info;
		}

		my (%candidate_SJ_group);
		my (%corrected_SJ_pos, %additional_SJ);
		my %candidate_strand_prob_product = ('0'=>1, '1'=>1);

		my %mapper_SJ_IDM_prob_hyperg;

		while(my ($SJ, $SJ_info_ref) = each %detected_SJ_pos) {
			my @SJ_loci = split $sep_SJ, $SJ;
			my $tag = 0;
			if (exists ${$all_candidate_ref}{$SJ}){
				$tag ++;
				my @IDS_total = map { ${$IDS_total_pre_ref}[$_]+${$SJ_info_ref}[3][$_] } (0 .. $#{$IDS_total_pre_ref});
				my $sub_total_ins = $sub_total+${$SJ_info_ref}[3][0];
				my $prob_hyperg_IDS = &calculate_probability_hypergeometric_IDS( ${$SJ_info_ref}[3],\@IDS_total,$sub_total_ins,$putative_total_all+${$SJ_info_ref}[3][0] ); 
				$mapper_SJ_IDM_prob_hyperg{$SJ} = $prob_hyperg_IDS;
				print READ_SUMM "mapper: $SJ\t";
				print READ_SUMM "$_," for @{${$SJ_info_ref}[3]};
				print READ_SUMM "\t$sub_total_ins\t", $putative_total_all+${$SJ_info_ref}[3][0], "\t";
				print READ_SUMM "$_," for @IDS_total;
				print READ_SUMM "\t$prob_hyperg_IDS\n";
			} else {
				print READ_SUMM "mapper: $SJ(not HC)\n";
			}
			
			my %candidate_SJ_strand;
			for my $align_ref (@sorted_2ends_remove0) {
				my @SJ_novel_loci = split $sep_SJ, ${$align_ref}{'SJ_ID'};

				if (${$align_ref}{'query_start'}-1-($SJFS_dist+$SJFS_dist_add) < ${$SJ_info_ref}[0] and ${$align_ref}{'query_end'}+$SJFS_dist+$SJFS_dist_add > ${$SJ_info_ref}[0] and abs($SJ_novel_loci[1]-$SJ_loci[1])<=$SJFS_dist+$SJFS_dist_add and abs($SJ_novel_loci[2]-$SJ_loci[2])<=$SJFS_dist+$SJFS_dist_add) {
					print READ_SUMM ${$align_ref}{'SJ_ID'},"(under consideration)\n";
					if ($SJ eq ${$align_ref}{'SJ_ID'} and exists $mapper_SJ_IDM_prob_hyperg{$SJ}) {
						$tag ++;
						if (${$align_ref}{'prob_hyperg'} < $mapper_SJ_IDM_prob_hyperg{$SJ}){
							print READ_SUMM "use_orig_align: $SJ\t$mapper_SJ_IDM_prob_hyperg{$SJ} > ${$align_ref}{'prob_hyperg'}\n";
							${$align_ref}{'prob_hyperg'} = $mapper_SJ_IDM_prob_hyperg{$SJ};
							${$align_ref}{'IDM'} = $detected_SJ_pos{$SJ}[3];
							${$align_ref}{'notSameStrand_SJ'} = $SJ_loci[-1];
						} else {
							$mapper_SJ_IDM_prob_hyperg{$SJ} = ${$align_ref}{'prob_hyperg'};
						}
					}

					if (${$align_ref}{'notSameStrand_SJ'} ne 'x') {
						push @{$candidate_SJ_group{${$align_ref}{'notSameStrand_SJ'}}{$SJ}}, $align_ref;
						$candidate_SJ_strand{${$align_ref}{'notSameStrand_SJ'}} += ${$align_ref}{'prob_hyperg'};
					} else {
						push @{$candidate_SJ_group{'0'}{$SJ}}, $align_ref;
						push @{$candidate_SJ_group{'1'}{$SJ}}, $align_ref;
						$candidate_SJ_strand{'0'} += ${$align_ref}{'prob_hyperg'};
						$candidate_SJ_strand{'1'} += ${$align_ref}{'prob_hyperg'};
					}
					
				}
			}
			if ($tag == 1) {
				if ($SJ_loci[-1] ne 'x') {
					push @{$candidate_SJ_group{$SJ_loci[-1]}{$SJ}}, { 'prob_hyperg' => $mapper_SJ_IDM_prob_hyperg{$SJ}, 'IDM' => $detected_SJ_pos{$SJ}[3], 'SJ_ID' => $SJ, 'notSameStrand_SJ' => $SJ_loci[-1] };
					$candidate_SJ_strand{$SJ_loci[-1]} += $mapper_SJ_IDM_prob_hyperg{$SJ};
				} else {
					push @{$candidate_SJ_group{'0'}{$SJ}}, { 'prob_hyperg' => $mapper_SJ_IDM_prob_hyperg{$SJ}, 'IDM' => $detected_SJ_pos{$SJ}[3], 'SJ_ID' => $SJ, 'notSameStrand_SJ' => '0' };
					push @{$candidate_SJ_group{'1'}{$SJ}}, { 'prob_hyperg' => $mapper_SJ_IDM_prob_hyperg{$SJ}, 'IDM' => $detected_SJ_pos{$SJ}[3], 'SJ_ID' => $SJ, 'notSameStrand_SJ' => '1' };
					$candidate_SJ_strand{'0'} += $mapper_SJ_IDM_prob_hyperg{$SJ};
					$candidate_SJ_strand{'1'} += $mapper_SJ_IDM_prob_hyperg{$SJ};
				}
				
				
			}
			next if !exists $candidate_SJ_strand{'1'} and !exists $candidate_SJ_strand{'0'};
			for my $x ('0', '1'){
				if (exists $candidate_strand_prob_product{$x}){
					$candidate_strand_prob_product{$x} *= $candidate_SJ_strand{$x};
				} else {
					$candidate_strand_prob_product{$x} = 0;
				}
			}
		}
		my $notSameStrand_ori;
		if ($is_stranded == 1){
			$notSameStrand_ori = $notSameStrand;
		} elsif ($candidate_strand_prob_product{'0'} >= $confirm_prob_fold_cutoff*$candidate_strand_prob_product{'1'}) {
			$notSameStrand_ori = 0;
			print READ_SUMM "strand is 0\n";
		} elsif ($candidate_strand_prob_product{'1'} >= $confirm_prob_fold_cutoff*$candidate_strand_prob_product{'0'}) {
			$notSameStrand_ori = 1;
			print READ_SUMM "strand is 1\n";
		} else {
			print READ_SUMM "strand not known!\n";
			return ['NA','NA','unknown'];
		}

		while(my ($SJ, $SJ_info_ref) = each %detected_SJ_pos) {
			my @SJ_loci = split $sep_SJ, $SJ;
			if (exists $candidate_SJ_group{$notSameStrand_ori}{$SJ}) {
				my @sort_score = sort {${$b}{'prob_hyperg'} <=> ${$a}{'prob_hyperg'}} @{$candidate_SJ_group{$notSameStrand_ori}{$SJ}};
				my $est_pos_read;
				if (exists $sort_score[0]{'query_start'}){
					$est_pos_read = ($sort_score[0]{'query_start'}-1+$sort_score[0]{'query_end'})/2;
				}
				$candidate_SJ_group{$notSameStrand_ori}{$SJ} = \@sort_score;
				if (exists ${$all_candidate_ref}{$SJ} and ($notSameStrand_ori eq $SJ_loci[-1] or $SJ_loci[-1] eq 'x') and $mapper_SJ_IDM_prob_hyperg{$SJ} > $sort_score[0]{'prob_hyperg'}*$additional_candidate_prob_fold_cutoff) { #${$SJ_info_ref}[1] > 0 or >=
					$est_pos_read = ${$SJ_info_ref}[0];
					$corrected_SJ_pos{$SJ} = [$SJ, $mapper_SJ_IDM_prob_hyperg{$SJ}, $est_pos_read, ${$SJ_info_ref}[1], ${$SJ_info_ref}[2]];
					print READ_SUMM "perfect_SJ_confirmed: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $SJ, $mapper_SJ_IDM_prob_hyperg{$SJ}, ", ${$SJ_info_ref}[0], "\n";

				} elsif (@sort_score >= 2 and $sort_score[0]{'prob_hyperg'} >= $confirm_prob_fold_cutoff*$sort_score[1]{'prob_hyperg'}) { #### change to larger than 0.9*all_probability 

					$corrected_SJ_pos{$SJ} = [$sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, $est_pos_read, 0, ${$SJ_info_ref}[2]];
					print READ_SUMM "corrected_SJ_confirmed: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, ", $est_pos_read, "\n";
				} elsif (@sort_score == 1 and $sort_score[0]{'SJ_ID'} ne $SJ) {
					$corrected_SJ_pos{$SJ} = [$sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, $est_pos_read, 1, ${$SJ_info_ref}[2]];
					print READ_SUMM "corrected_SJ_only_choice: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, ", $est_pos_read, "\n";
				} else {
					print READ_SUMM "undetermined_multiple_choice: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, ", $est_pos_read, "\n";
				}
			} else {
				print READ_SUMM "no alignment for $SJ(${$SJ_info_ref}[0], ${$SJ_info_ref}[1])!!!\n";
			}
		}

		if (scalar(keys %corrected_SJ_pos) >= 1) {
			my $sum = 0;
			$sum += ${$_}[1] for values %corrected_SJ_pos;
			my $ave = $sum/scalar(keys %corrected_SJ_pos);
			my @sort_prob_SJ = sort {${$a}[1] <=> ${$b}[1]} values %corrected_SJ_pos;
			my $min = ${$sort_prob_SJ[0]}[1];
			my @uncorrected_SJ = grep {!exists $corrected_SJ_pos{${$_}[1]}} @detected_SJ;
			if(@uncorrected_SJ>0){
				print READ_SUMM "uncorrected:";
				print READ_SUMM "\t${$_}[1]" for @uncorrected_SJ;
				print READ_SUMM "\n";
			}
			for my $SJ_info (@uncorrected_SJ) {
				my $SJ = ${$SJ_info}[1];
				my $first_candidate_ref = $candidate_SJ_group{$notSameStrand_ori}{$SJ}[0];
				my @SJ_novel_loci = split $sep_SJ, ${$first_candidate_ref}{'SJ_ID'};
				my @SJ_loci = split $sep_SJ, $SJ;
				if (${$first_candidate_ref}{'prob_hyperg'} >= $ave and abs($SJ_novel_loci[1]-$SJ_loci[1])<=$correct_suggest_SJ_distance_max and abs($SJ_novel_loci[2]-$SJ_loci[2])<=$correct_suggest_SJ_distance_max){
					my $est_pos_read;
					if (exists ${$first_candidate_ref}{'query_start'}){
						$est_pos_read = (${$first_candidate_ref}{'query_start'}-1+${$first_candidate_ref}{'query_end'})/2;
					} elsif ($SJ eq ${$first_candidate_ref}{'SJ_ID'}) {
						$est_pos_read = $detected_SJ_pos{$SJ}[0];
					} else {
						die "$SJ ne ${$first_candidate_ref}{'SJ_ID'}!!";
					}
					$corrected_SJ_pos{$SJ} = [${$first_candidate_ref}{'SJ_ID'}, ${$first_candidate_ref}{'prob_hyperg'}, $est_pos_read, 0];
					print READ_SUMM "!!!added_middle ${$first_candidate_ref}{'SJ_ID'}, ${$first_candidate_ref}{'prob_hyperg'}, ", $est_pos_read, "\n";
				}
			}
			my $pre_first_SJ_read = $detected_SJ[0-$notSameStrand];
			my $pre_last_SJ_read = $detected_SJ[$notSameStrand-1];
			my @SJ_loci_first = split $sep_SJ, ${$pre_first_SJ_read}[1];
			my @SJ_loci_last = split $sep_SJ, ${$pre_last_SJ_read}[1];

			my ($SJ_pos_pre_first, $SJ_pos_pre_last);
			if (exists $corrected_SJ_pos{${$pre_first_SJ_read}[1]}) {
				$SJ_pos_pre_first = $corrected_SJ_pos{${$pre_first_SJ_read}[1]}[2];
			} else {
				$SJ_pos_pre_first = $detected_SJ_pos{${$pre_first_SJ_read}[1]}[0];
			}
			if (exists $corrected_SJ_pos{${$pre_last_SJ_read}[1]}) {
				$SJ_pos_pre_last = $corrected_SJ_pos{${$pre_last_SJ_read}[1]}[2];
			} else {
				$SJ_pos_pre_last = $detected_SJ_pos{${$pre_last_SJ_read}[1]}[0];
			}
			print READ_SUMM "$min\t$ave\t$clip_ends[0]\t$clip_ends[1]\n";

			for my $align_ref (@sorted_2ends_remove0) {

				my $amb_read_pos = (${$align_ref}{'query_start'}-1+${$align_ref}{'query_end'})/2;
				my @SJ_loci = split $sep_SJ, ${$align_ref}{'SJ_ID'};

				my $align_ref_length_half;
				print READ_SUMM "-1\t${$align_ref}{'SJ_ID'}\t$SJ_pos_pre_first\t$amb_read_pos\t",$SJ_loci_first[$notSameStrand+1],"\t", $SJ_loci[2-$notSameStrand], "\n" if ${$align_ref}{'query_end'} < $SJ_pos_pre_first;
				print READ_SUMM "-2\t${$align_ref}{'SJ_ID'}\t$SJ_pos_pre_last\t$amb_read_pos\t",$SJ_loci_last[2-$notSameStrand], "\t", $SJ_loci[$notSameStrand+1],"\n" if ${$align_ref}{'query_start'}-1 > $SJ_pos_pre_last;
				if ( (${$align_ref}{'notSameStrand_SJ'} eq $notSameStrand_ori or ${$align_ref}{'notSameStrand_SJ'} eq 'x') and ${$align_ref}{'query_end'} < $SJ_pos_pre_first and abs($amb_read_pos-$clip_ends[0]) <= $first_exon_diff_cutoff and ($SJ_loci_first[$notSameStrand+1]-$SJ_loci[2-$notSameStrand])*(0.5-$notSameStrand) > 0 and ($SJ_loci_first[$notSameStrand+1]-$SJ_loci[2-$notSameStrand])*(0.5-$notSameStrand)*2*$second_exon_align_length_ratio_cutoff < ($SJ_pos_pre_first-$amb_read_pos) and ($SJ_loci_first[$notSameStrand+1]-$SJ_loci[2-$notSameStrand])*(0.5-$notSameStrand)*2 > ($SJ_pos_pre_first-$amb_read_pos)*$second_exon_align_length_ratio_cutoff and ${$align_ref}{'prob_hyperg'} >= $min*$additional_candidate_prob_fold_cutoff ) { #and ${$align_ref}{'prob_hyperg'} >= $ave
					$additional_SJ{'-1'}{${$align_ref}{'SJ_ID'}} = [${$align_ref}{'SJ_ID'},${$align_ref}{'prob_hyperg'},$amb_read_pos,-1];
					print READ_SUMM "!!!added_first ${$align_ref}{'SJ_ID'}, ${$align_ref}{'prob_hyperg'}, ", $amb_read_pos, "\n";
				} elsif ( (${$align_ref}{'notSameStrand_SJ'} eq $notSameStrand_ori or ${$align_ref}{'notSameStrand_SJ'} eq 'x') and ${$align_ref}{'query_start'}-1 > $SJ_pos_pre_last and abs($read_length-$amb_read_pos-$clip_ends[1]) <= $first_exon_diff_cutoff and ($SJ_loci[$notSameStrand+1]-$SJ_loci_last[2-$notSameStrand])*(0.5-$notSameStrand) > 0 and ($SJ_loci[$notSameStrand+1]-$SJ_loci_last[2-$notSameStrand])*(0.5-$notSameStrand)*2*$second_exon_align_length_ratio_cutoff < ($amb_read_pos-$SJ_pos_pre_last) and ($SJ_loci[$notSameStrand+1]-$SJ_loci_last[2-$notSameStrand])*(0.5-$notSameStrand)*2 > ($amb_read_pos-$SJ_pos_pre_last)*$second_exon_align_length_ratio_cutoff and ${$align_ref}{'prob_hyperg'} >= $min*$additional_candidate_prob_fold_cutoff ){ # and ${$align_ref}{'prob_hyperg'} >= $ave
					$additional_SJ{'-2'}{${$align_ref}{'SJ_ID'}} = [${$align_ref}{'SJ_ID'},${$align_ref}{'prob_hyperg'},$amb_read_pos,-2];
					print READ_SUMM "!!!added_last ${$align_ref}{'SJ_ID'}, ${$align_ref}{'prob_hyperg'}, ", $amb_read_pos, "\n";
				}
			}
			for my $type ('-1', '-2') {
				if (exists $additional_SJ{$type}) {
					if (scalar(keys %{$additional_SJ{$type}}) >= 2) {
						my @additiona_SJ_sort = sort { ${$b}[1] <=> ${$a}[1] } values %{$additional_SJ{$type}};
						if (${$additiona_SJ_sort[0]}[1] >= ${$additiona_SJ_sort[1]}[1]*$confirm_prob_fold_cutoff) {
							delete $additional_SJ{$type}{$additiona_SJ_sort[$_]} for (1 .. $#additiona_SJ_sort);
						}
					}
				}
			}
		}

		[\%corrected_SJ_pos,\%additional_SJ, $notSameStrand_ori];
	}

	sub split_sam_file {
		my ($in, $n, $out, $met) = @_;
		my (%split_files_key_read,$in_raw);
		if (rindex($in, "/")>=0) {
			$in_raw = (substr($in, rindex($in, "/")+1));
		} else {
			$in_raw = $in;
		}
		if ($n >= 2) {
			my $input_dir = $out.'/';
			my $size = -s $in;
			if($size < 1_001){
				print "Fail to get file size for $in.\nFatal error. Aborted.\n";
				die "Fail to get file size for $in: $!";
			}
			my $division;
			if ($size%$n != 0) {
				$division = int($size/$n)+1;
			} else {
				$division = int($size/$n);
			}
			if(!defined($division) or $division < 0.01*$size){
				print "Fail to calculate divided file size, total file size $size, thread $n.\nFatal error. Aborted.\n";
				die "Fail to calculate divided file size, total file size $size, thread $n: $!";
			}
			system "split -b $division $in $input_dir$in_raw";
			if ($met eq 'category') {
				my $division2 = int($division/2)+1;
				system "split -b $division2 $input_dir${in_raw}aa $input_dir${in_raw}aa";
				unlink "$input_dir${in_raw}aa";
				system "split -b $division2 $input_dir${in_raw}ab $input_dir${in_raw}ab";
				unlink "$input_dir${in_raw}ab";
			}
			my @split_sam = <$input_dir$in_raw*>;
			my @split_files;
			print " Divided SAM(LIST) sizes:\n";
			my $n2 = 0;
			for my $sam (@split_sam) {
				if ($sam=~/$in_raw[a-z]+$/){
					$n2 ++;
					if (rindex($sam, "/")>=0) {
						my $file = (substr($sam, rindex($sam, "/")+1));
						printf " $file\t%15d\n", (-s $sam);
						push @split_files, $file;
					} else {
						die "error for $sam: -1";
					}
				}
			}
			if ( ($n2 == $n and $met eq 'group') ){
				print " SAM(LIST) was divided successfully.\n" ;
			} elsif ($met eq 'group') {
				print "Cannot split $in into $n ($n2) pieces with size of $division and named them as $input_dir$in_raw.\nFatal error. Aborted.\n";
				die "Cannot split $in into $n ($n2) pieces with size of $division and named them as $input_dir$in_raw: $!";
			}
			if ( ($n2 == $n+2 and $met eq 'category') ){
				print " SAMLIST was divided successfully.\n" ;
			} elsif ($met eq 'category') {
				print "Cannot split $in into ", $n+2, " ($n2) pieces with size of $division and named them as $input_dir$in_raw.\nFatal error. Aborted.\n";
				die "Cannot split $in into ", $n+2, " ($n2) pieces with size of $division and named them as $input_dir$in_raw: $!";
			}

			print " First group of divided SAM(LIST) files: \n";
			my @split_files_sort = sort{$b cmp $a} @split_files;
			for my $i (0 .. $#split_files_sort-1) {
				my (%read_name, @add_reads, $line_num);
				open FILE, "<", $input_dir.$split_files_sort[$i] or die "cannot open $input_dir$split_files_sort[$i]: $!";
				while (<FILE>) {
					chomp;
					$line_num ++;
					my @line = split /\t/;

					if(($met eq 'category') or ($met eq 'group' and $line_num >= 2)) {
						$read_name{$line[0]} ++;
					}
					if ( scalar(keys %read_name)>=2 ) {
						$split_files_key_read{$split_files_sort[$i]} = $line[0];
						print " $split_files_sort[$i]: $line[0]\n" ;
						open OUTPUT, ">>", $input_dir.$split_files_sort[$i+1] or die;
						print OUTPUT "$_\n" for @add_reads;
						close OUTPUT;
						@add_reads = ();
						last;
					} else {
						push @add_reads, $_;
					}
				}
				if (@add_reads > 0) {
					open OUTPUT, ">>", $input_dir.$split_files_sort[$i+1] or die;
					print OUTPUT "$_\n" for @add_reads;
					close OUTPUT;
					unlink "$input_dir$split_files_sort[$i]";
					@add_reads = ();
				}
			}
			open FILE, "<", $input_dir.$split_files_sort[-1] or die "cannot open $input_dir$split_files_sort[-1]: $!";
			while (<FILE>) {
				chomp;
				my @line = split /\t/;
				unless (/^[@]/) {
					$split_files_key_read{$split_files_sort[-1]} = $line[0];
					print " $split_files_sort[-1]: $line[0]\n" ;
					last;
				}
			}
			if (keys %split_files_key_read == $n2) {
				print " First reads were recorded successfully for all $n2 files.\n" 
			} elsif (keys %split_files_key_read >= 1) {
				print " First reads were recorded successfully for ", scalar (keys %split_files_key_read), " files.\n";

			} else {
				print "Fail to record first reads for $n2 pieces of SAM.\nFatal error. Aborted.\n";
				die "Fail to record first reads for $n2 pieces of SAM: $!";
			}
		} else {
			die "Please select at least 2 threads to parse SAM!";
		}
		\%split_files_key_read;

	}

	sub ID_align_btop {
		my ($btop, $query_2ends_ref, $sbjct_2ends_ref, $sbjct_ID) = @_;
		my ($loci_query, $loci_sbjct) = (${$query_2ends_ref}[0], ${$sbjct_2ends_ref}[0]);
		my ($loci_sbjct_min, $loci_sbjct_max) = ($SJFS_dist_add+1, $SJFS_dist*2+$SJFS_dist_add);
		my $inc = (${$sbjct_2ends_ref}[1] - ${$sbjct_2ends_ref}[0])/abs(${$sbjct_2ends_ref}[1] - ${$sbjct_2ends_ref}[0]);
		
		my @matches = split /\D+/, $btop;
		my @mismatches_raw = split /\d+/, $btop;

		shift @mismatches_raw;

		my %IDM_sbjct;
		my %start_end_match;

		for my $i (0 .. $#matches) {
			for my $j (1 .. $matches[$i]) {
				if ($loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max){
					$start_end_match{$loci_sbjct} = $loci_query;
				}
				$loci_sbjct += $inc;
				$loci_query ++;
			}
			
			if (defined $mismatches_raw[$i]) {
				my @mismatches_current = split '', $mismatches_raw[$i];
				for my $j (0 .. ($#mismatches_current-1)/2) {
					my ($mismatch_query, $mismatch_sbjct) = ($mismatches_current[2*$j], $mismatches_current[2*$j+1]);
					if ($mismatch_sbjct eq '-') {
						if ($loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max) {
							push @{$IDM_sbjct{'D'}{$loci_sbjct}}, $loci_query;
						}
						$loci_query ++;
					} else {
						if ($mismatch_query eq '-') {
							$IDM_sbjct{'I'}{$loci_sbjct} = $loci_query if $loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max;
						} else {
							$IDM_sbjct{'M'}{$loci_sbjct} = $loci_query if $loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max;
							$loci_query ++;
						}
						$loci_sbjct += $inc;
					}
				}
			}
		}
		my $delete_num = 0;
		$delete_num += scalar (@{$IDM_sbjct{'D'}{$_}}) for keys %{$IDM_sbjct{'D'}};
		my @sort_match_loci_sbjct = sort {$a*$inc <=> $b*$inc} keys %start_end_match;
		{
			'query_start' => $start_end_match{$sort_match_loci_sbjct[0]},
			'query_end' => $start_end_match{$sort_match_loci_sbjct[-1]},
			'query_ori' => [${$query_2ends_ref}[0],${$query_2ends_ref}[1]],
			'subject_start' => $sort_match_loci_sbjct[0],
			'subject_end' => $sort_match_loci_sbjct[-1],
			'subject_ori' => [${$sbjct_2ends_ref}[0],${$sbjct_2ends_ref}[1]],
			'SJ_ID' => $sbjct_ID,
			'IDM' => [$delete_num, scalar(keys %{$IDM_sbjct{'I'}}), scalar(keys %{$IDM_sbjct{'M'}})]
		};
	}


	sub calculate_probability_hypergeometric_IDS {
		my @IDSM = @{$_[0]};
		my @IDSM_all = @{$_[1]};
		my ($IDSM_total, $IDSM_all_total) = ($_[2], $_[3]);
		
		my $combination_all = &combination($IDSM_all_total, $IDSM_total);
		my $prob = 1;
		for my $i (0 .. $#IDSM_all){
			$prob *= &combination($IDSM_all[$i], $IDSM[$i]);
			$IDSM_total -= $IDSM[$i];
			$IDSM_all_total -= $IDSM_all[$i];
		}
		$prob *= &combination($IDSM_all_total, $IDSM_total);
		$prob /= $combination_all;
		$prob;
	}

	sub combination {
		my ($r, $n, $k) = (1, @_);
		$k = $n-$k if $k > $n/2;
		for (1 .. $k) { $r *= $n--; $r /= $_ }
		$r;
	}

	sub comp_rev {
		my $seq = reverse($_[0]);
		$seq =~ tr/ATCG/TAGC/;
		$seq;
	}

	sub ten2b {
		my $b_string = sprintf("%b", $_[0]);
		if ($_[1] <= length($b_string)) {
			substr(reverse($b_string), $_[1]-1, 1);
		} else {
			0;
		}
	}

	sub min {
		if ($_[0] < $_[1]) {
			$_[0];
		} else {
			$_[1];
		}
	}

	sub max {
		if ($_[0] > $_[1]) {
			$_[0];
		} else {
			$_[1];
		}
	}

	sub hamming_distance{ length( $_[0] ) - ( ($_[0] ^ $_[1]) =~ tr[\0][\0] ) };

}
