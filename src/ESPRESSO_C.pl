use strict;
use threads;
use Getopt::Long;

use File::Copy;
use File::Basename qw(dirname);
use lib dirname(__FILE__);
use ESPRESSO_Version;

# This eval makes Parasail optional (instead of 'use Parasail')
my $has_parasail = eval
{
	require Parasail;
	Parasail->import();
	1;
};


my $version_number = ESPRESSO_Version::get_version_number();
my $version_string = "C_$version_number";
# Because it is a command line option, the name $blast_score_difference_cutoff should
# be kept even if blast is removed from the code.
my ($help, $in, $fa, $out, $target_ID, $num_thread, $mapq_cutoff, $keep_tmp, $proc_num_cutoff, $is_stranded,
	$cont_del_max, $chrM, $inserted_cont_cutoff, $first_exon_diff_cutoff, $SJFS_dist, $SJFS_dist_add, $align_length_ratio_cutoff, $fold_end_length_lost_cutoff,
	$correct_suggest_SJ_distance_max, $confirm_prob_fold_cutoff, $evalue_cor, $second_exon_align_length_ratio_cutoff, $length4nhmmer_max,
	$END_dist_add, $blast_score_difference_cutoff, $additional_candidate_prob_fold_cutoff, $directly_approve_length_additional, $max_overlap_SJ_group, $sort_buffer_size, $blast);

my $arguments_before_parsing = "@ARGV";
Getopt::Long::GetOptions (

	'in|I=s'					=>	\$in,
	'fa|F=s'					=>	\$fa,
	'target_ID|X=s'				=>	\$target_ID,

	'help|H!'					=>	\$help,
	'keep_tmp|K!'				=>	\$keep_tmp,
	'num_thread|T=i'			=>	\$num_thread,

	'first_exon_diff_cutoff=i'	=>	\$first_exon_diff_cutoff,
	'SJFS_dist=i'				=>	\$SJFS_dist,
	'SJFS_dist_add=i'			=>	\$SJFS_dist_add,
	'END_dist_add=i'			=>	\$END_dist_add,
	'align_length_ratio_cutoff=f'				=>	\$align_length_ratio_cutoff,
	'correct_suggest_SJ_distance_max=i'			=>	\$correct_suggest_SJ_distance_max,
	'confirm_prob_fold_cutoff=f'				=>	\$confirm_prob_fold_cutoff,
	'evalue_cor=f'								=>	\$evalue_cor,

	'second_exon_align_length_ratio_cutoff=f'	=>	\$second_exon_align_length_ratio_cutoff,
	'blast_score_difference_cutoff=f'			=>	\$blast_score_difference_cutoff,
	'additional_candidate_prob_fold_cutoff=f'	=>	\$additional_candidate_prob_fold_cutoff,
	'directly_approve_length_additional=i'		=>	\$directly_approve_length_additional,
	'proc_num_cutoff=i'							=>	\$proc_num_cutoff,
	'length4nhmmer_max=i'							=>	\$length4nhmmer_max,
	'sort_buffer_size=s'	=>	\$sort_buffer_size,
	'blast'	=>	\$blast

);

if (defined($help)) {
	print "
Program:  ESPRESSO (Error Statistics PRomoted Evaluator of Splice Site Options)
Version:  $version_string
Contact:  Yuan Gao <gaoy\@email.chop.edu, gy.james\@163.com>

Usage:    perl ESPRESSO_C.pl -I work_dir -F ref.fa -X target_ID

Arguments:

    -I, --in
          work directory (generated by ESPRESSO_S)
    -F, --fa
          FASTA file of all reference sequences. Please make sure this file is
          the same one provided to mapper. (required)
    -X, --target_ID
          ID of sample to process (required)

    -H, --help
          show this help information

    -T, --num_thread
          thread number (default: 5)
    --sort_buffer_size
          memory buffer size for running 'sort' commands (default: 2G)
    --blast
          Use BLAST instead of Smith-Waterman

";
} elsif ( !defined($in) or !defined($fa) or !defined($target_ID) ) {
	print "The following parameter(s) are required:\n";
	if (!defined($in)) {
		print "\t--in/-I";
	} if (!defined($fa)) {
		print "\t--fa/-F";
	} if (!defined($target_ID)) {
		print "\t--target_ID/-X";
	}
	print "\nPlease use the --help or -H option to get usage information.\n";
} else {

	$first_exon_diff_cutoff = 30 if !defined $first_exon_diff_cutoff;
	$SJFS_dist = 10 if !defined $SJFS_dist;
	$SJFS_dist_add = 15 if !defined $SJFS_dist_add;
	$align_length_ratio_cutoff = 0.7 if !defined $align_length_ratio_cutoff;
	$correct_suggest_SJ_distance_max = 20 if !defined $correct_suggest_SJ_distance_max;
	$confirm_prob_fold_cutoff = 10 if !defined $confirm_prob_fold_cutoff;
	$evalue_cor = 10 if !defined $evalue_cor;

	$second_exon_align_length_ratio_cutoff = 0.8 if !defined $second_exon_align_length_ratio_cutoff;
	$END_dist_add = 50 if !defined $END_dist_add;
	$blast_score_difference_cutoff = 2 if !defined $blast_score_difference_cutoff;
	$additional_candidate_prob_fold_cutoff = 0.1 if !defined $additional_candidate_prob_fold_cutoff;
	$directly_approve_length_additional = 50 if !defined $directly_approve_length_additional;
	$num_thread = 5 if !defined $num_thread;
	$fold_end_length_lost_cutoff = 1.5;
	$max_overlap_SJ_group = 100;
	$length4nhmmer_max = 200 if !defined $length4nhmmer_max;

	$proc_num_cutoff = 20_000 if !defined $proc_num_cutoff;

	$chrM = 'chrM' if !defined $chrM;
	if (defined $sort_buffer_size) {
		$sort_buffer_size = "--buffer-size=$sort_buffer_size";
	} else {
		$sort_buffer_size = "--buffer-size=2G";
	}

	# --smith_waterman was added to the code as an optional feature.
	# Now it's the default and --blast enables the old behavior.
	# $blast is only used for argument parsing.
	# $smith_waterman is used in the remainder of the code.
	my $smith_waterman = !$blast;
	undef $blast;

	my @ends = ('start','end');

	my @warn_reason;
	my @die_reason;

	if($num_thread < 2){
		push @die_reason, " Please designate at least 2 threads\n";
	}

	if ($smith_waterman) {
		if (!$has_parasail) {
			push @die_reason, "could not load Parasail module needed for Smith-Waterman\n";
		}
	} else {
		my $blast_version_error = ESPRESSO_Version::check_blast_version();
		if ($blast_version_error ne '') {
			push @die_reason, "$blast_version_error\n";
		}
	}

	my $nhmmer_version_error = ESPRESSO_Version::check_nhmmer_version();
	if ($nhmmer_version_error ne '') {
		push @die_reason, "$nhmmer_version_error\n";
	}

	if ( @warn_reason >= 1 ) {
		print @warn_reason;
	}
	if ( @die_reason >= 1 ) {
		die @die_reason;
	}

	# The summary file will be written as a final step
	my $summary_path = "$in/$target_ID/espresso_c_summary.txt";
	my %summary_data = ();
	&initialize_summary_data(\%summary_data);
	$summary_data{'perl_command'} = "$^X " . __FILE__ . " $arguments_before_parsing";

	my $sep_end_blast = '/';
	my $sep_SJ = ':';

	opendir DIR, "$in/$target_ID" or die "cannot opendir $in/$target_ID: $!";

	for my $file (readdir DIR) {
		if ( -d "$in/$target_ID/$file" and ($file =~ /^realign_\d+$/ or $file eq 'all') ) {
			opendir DIR2, "$in/$target_ID/$file" or die "cannot opendir $in/$target_ID/$file: $!";
			for my $file2 (readdir DIR2) {
				if (-f "$in/$target_ID/$file/$file2"){
					unlink "$in/$target_ID/$file/$file2";
				}
			}
			closedir DIR2;
			rmdir "$in/$target_ID/$file";
		} elsif (-f "$in/$target_ID/$file" and ($file =~ /^sam\.list3[a-z]+$/ or $file =~ /_read_final\.txt$/)) {
			unlink "$in/$target_ID/$file";
		}
	}
	closedir DIR;

	mkdir "$in/$target_ID/all";

	print_with_timestamp("Loading splice junction info");
	#my %group_all_SJ;

	# Sort the alignments to ensure deterministic results.
	# The sort columns are: -k1,1n (numeric sort of read group), -k3,3 (default sort of read ID)
	my $in_sam_list3_path = "$in/$target_ID/sam.list3";
	my $in_sam_list3_tmp_path = "$in_sam_list3_path" . ".tmp";
	my $in_sam_list3_sort_command = "sort $sort_buffer_size -k1,1n -k3,3 $in_sam_list3_path --output $in_sam_list3_tmp_path";
	my $exit_sort = system($in_sam_list3_sort_command);
	if ($exit_sort != 0) {
		die "Failed to run '$in_sam_list3_sort_command'. Exit code is $exit_sort";
	}
	move($in_sam_list3_tmp_path, $in_sam_list3_path);

	my %necessary_groups;
	open LIST3, "<", "$in/$target_ID/sam.list3" or die "cannot open $in/$target_ID/sam.list3: $!";
	while (<LIST3>) {
		s/\r\n//;
		chomp;
		my @line = split /\t/;
		$necessary_groups{$line[0]} ++;
	}
	close LIST3;
	
	my @SJ_simplified = glob("$in/*_SJ_simplified.list");
	my %group_ID_mkdir;
	for my $SJ_file (@SJ_simplified) {
		open SJ_SIM, "<", "$SJ_file" or die "cannot open $SJ_file: $!";
		my ($last_group_ID);
		while (<SJ_SIM>) {
			s/\r\n//;
			chomp;
			if (/^SJ_cluster/) {
				my @line = split /\s+/;
				my $group_ID = $line[1];
				my $chr = $line[4];
				if ($group_ID ne $last_group_ID) {
					close SJ_SIM_GROUP if exists $necessary_groups{$last_group_ID};
					if (exists $necessary_groups{$group_ID}) {
						my $output_dir = "$in/$target_ID/realign_$group_ID";
						$group_ID_mkdir{$group_ID} = [1, $chr];
						mkdir "$in/$target_ID/realign_$group_ID";
						open SJ_SIM_GROUP, ">$output_dir/SJ_info.txt" or die "cannot write $output_dir/SJ_info.txt: $!";
					}
				}

				$last_group_ID = $group_ID;
			}
			print SJ_SIM_GROUP "$_\n";

			#push @{$group_all_SJ{$line[0]}{$line[-1]}}, $line[1].$sep_SJ.$line[2].$sep_SJ.$line[3].$sep_SJ.$line[4]; # if $line[-2] == 1
		}
		close SJ_SIM_GROUP;
		close SJ_SIM;
	}
	

	open SJ_FA, "<", "$in/SJ_group_all.fa" or die "cannot open $in/SJ_group_all.fa: $!";
	my ($last_group_ID); 
	while (<SJ_FA>) {
		s/\r\n//;
		chomp;
		if (/^>/) {
			my @line = split /\s+/;
			my $group_ID = substr($line[-1], 6, length($line[-1])-7);
			if ($group_ID ne $last_group_ID) {
				close SJ_FA_GROUP if exists $necessary_groups{$last_group_ID};
				if (exists $necessary_groups{$group_ID}) {
					my $output_dir = "$in/$target_ID/realign_$group_ID";
					die "$group_ID was not recorded:$_" if !exists $group_ID_mkdir{$group_ID};
					$group_ID_mkdir{$group_ID}[0] = 2;
					#mkdir "$in/$target_ID/realign_$group_ID";
					open SJ_FA_GROUP, ">$output_dir/SJ_group.fa" or die "cannot write $output_dir/SJ_group.fa: $!";
				}
			} 

			$last_group_ID = $group_ID;
		}
		print SJ_FA_GROUP "$_\n";

		#push @{$group_all_SJ{$line[0]}{$line[-1]}}, $line[1].$sep_SJ.$line[2].$sep_SJ.$line[3].$sep_SJ.$line[4]; # if $line[-2] == 1
	}
	close SJ_FA_GROUP;
	close SJ_FA;

	%necessary_groups=();

	print_with_timestamp(sprintf("Requesting system to split SAMLIST into %g pieces", int($num_thread)));
	my $split_list_first_read = &split_sam_file("$in/$target_ID/sam.list3", int($num_thread), "$in/$target_ID/", 'group');

	print_with_timestamp("Loading references");

	my %chr_seq;
	my %chr_seq_len;
	my $current_chr;

	open FA, "<", $fa or die "cannot open $fa: $!";
	while (<FA>) {
		s/\r\n//;
		chomp;
		if (/^>/) {
			my $info = substr($_, 1, length($_)-1);
			($current_chr, undef) = split /\s+/, $info;
		} elsif (defined $current_chr) {
			$chr_seq{$current_chr} .= uc($_);
			$chr_seq_len{$current_chr} += length($_);
		}
	}
	close FA;
	my $num_chr_seqs = scalar(keys %chr_seq);
	if ($num_chr_seqs == 0) {
		die "No sequence information found in $fa";
	}

	#open READ_SUMM, ">", $out."/read_summary.txt" or die "cannot write $out/read_summary.txt: $!";

	my @output_titles = ('group_ID','line_num','readID','sample','read_length','flag','chr','start','mapq','end','notSameStrand','mappedGenome','clip_ends','exonIntronRef','IDS_SJ_ref','NM_num','insNumBg','delNumBg','substNumBg','totalNumBg','SJcorSeqRef','readSeq');
	#21
	print_with_timestamp(sprintf("Scanning SAMLIST by %g workers", int($num_thread/2)));

	my @split_list_sort = sort {$a cmp $b} keys %{$split_list_first_read};
	my @ths;
	for my $file (@split_list_sort){
		my $th = threads -> new({'context' => 'list'}, \&parallel_scan_samlist, [$file, ${$split_list_first_read}{$file}, scalar(@ths), $smith_waterman]);
		my $th_id = $th->tid();
		print " Worker $th_id begins to scan $file.\n";
		unshift @ths, $th;
	}

	&wait_for_threads_to_complete_work(\@ths, \%summary_data);
	@ths = ();

	while (my ($chr, $len) = each %chr_seq_len) {
		my @read_finals = glob("$in/$target_ID/all/*_thread_${chr}_read_final.txt");
		if (@read_finals > 0) {
			my $exit_cat = system("cat @read_finals > $in/$target_ID/${chr}_read_final.txt");
			if ($exit_cat != 0) {
				warn "Failed to run \"cat @read_finals > $in/$target_ID/${chr}_read_final.txt\". Exit code is $exit_cat";
			}
		}
		if (!defined $keep_tmp) {
			unlink "$_" for @read_finals;
			rmdir "$in/$target_ID/all";
		}
	}

	if (!defined $keep_tmp) {
		opendir DIR, "$in/$target_ID" or die "cannot opendir $in/$target_ID: $!";

		for my $file (readdir DIR) {
			if ( -d "$in/$target_ID/$file" and ($file =~ /^realign_\d+$/ or $file eq 'all') ) {
				opendir DIR2, "$in/$target_ID/$file" or die "cannot opendir $in/$target_ID/$file: $!";
				for my $file2 (readdir DIR2) {
					if (-f "$in/$target_ID/$file/$file2"){
						unlink "$in/$target_ID/$file/$file2";
					}
				}
				closedir DIR2;
				rmdir "$in/$target_ID/$file";
			} elsif (-f "$in/$target_ID/$file" and $file =~ /^sam\.list3[a-z]+$/) {
				unlink "$in/$target_ID/$file";
			}
		}
		closedir DIR;
	}

	&write_summary_file($summary_path, \%summary_data);

	print_with_timestamp("ESPRESSO_C finished its work.");

	sub parallel_scan_samlist {
		my ($file, $key_read, $thread_ID, $smith_waterman) = @{$_[0]};

		# Allow the main thread to stop other threads with kill('TERM')
		$SIG{'TERM'} = sub { threads->exit(); };

		my ($pinhead, $n, @all_info_read, $last_n);
		my ($same_group_count) = (0); #, $accu_num
		my %summary_data = ();
		my %pre_read_align_length;
		my (%group_SJ_cluster, %group_SJ_cluster_ends);

		my $aligner_matrix_pointer;
		if ($smith_waterman) {
			$aligner_matrix_pointer = &get_aligner_matrix_pointer();
		}

		open IN, "<", "$in/$target_ID/$file" or die "cannot open $in/$target_ID/$file: $!";
		#open OUT, ">", "$out/$file.size" or die "cannot write $out/$file.size: $!" if $time == 2;
		while (<IN>) {
			chomp;
			my @line = split /\t/;
			if ($line[0] eq $key_read and @line == @output_titles) {
				$pinhead = 1;
			}
			if (defined $pinhead) {
				die scalar(@output_titles)."\t@line" if @line != @output_titles;
				if ( defined $n and ($n ne $line[0] or @all_info_read >= $proc_num_cutoff) ) {
					my $chr0 = $all_info_read[0]{'chr'};
					if (!defined $last_n or $n ne $last_n) {
						if ($n ne $last_n and !defined $keep_tmp) {
							unlink "$in/$target_ID/realign_$last_n/SJ_info.txt";
							unlink "$in/$target_ID/realign_$last_n/SJ_group.fa";
							rmdir "$in/$target_ID/realign_$last_n";
						}
						$same_group_count = 0;
						%group_SJ_cluster = ();
						%group_SJ_cluster_ends = ();
						if ($group_ID_mkdir{$n}[0] == 2){
							my $SJ_list = "$in/$target_ID/realign_$n/SJ_info.txt";
							open SJ_LIST, "<", $SJ_list or die "cannot open $SJ_list: $!";
							while (<SJ_LIST>) {
								chomp;
								my @line_SJ = split /\t/;
								if ($line_SJ[0] eq 'SJ_cluster') {
									$group_SJ_cluster_ends{$line_SJ[2]} = [$line_SJ[5], $line_SJ[6], $line_SJ[3]];
								} else {
									push @{$group_SJ_cluster{$line_SJ[-1]}}, [$line_SJ[1], $line_SJ[-3], $line_SJ[-2]];
								}
							}
							close SJ_LIST;

							# sort SJ_group.fa so that it can be read line by line
							&sort_sj_group_fa_file("$in/$target_ID/realign_$n/SJ_group.fa", "$in/$target_ID/realign_$n/SJ_group.fa.tmp");
						}
						printf "$n\t%g\n", scalar(keys %group_SJ_cluster_ends), scalar(@all_info_read);

					}
					
					$same_group_count ++;
					if (scalar(%group_SJ_cluster) > 0) {
						&realign_reads(\@all_info_read, \%group_SJ_cluster, \%group_SJ_cluster_ends, "$in/$target_ID/realign", $n, $same_group_count, $thread_ID, $chr0, \%summary_data, $aligner_matrix_pointer, $smith_waterman);
					} else {
						open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
						for my $read_ID (0 .. $#all_info_read){
							my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
							my $out = &summary_final_output($all_info_read[$read_ID], $n, $read_ID_update, {});
							print READ_FINAL $out;
						}
						$summary_data{'num_reads_output'} += (scalar @all_info_read);
						$summary_data{'num_reads_without_SJs_to_correct'} += (scalar @all_info_read);
						close READ_FINAL;
					}
					@all_info_read = ();
					$last_n = $n;
					#$accu_num = 0;
				}
				my %tmp_info_read;
				$tmp_info_read{$output_titles[$_]} = $line[$_] for 1 .. $#output_titles;

				my %current_read_info;

				while (my ($key, $info) = each %tmp_info_read) {
					if ( $key eq 'clip_ends' or $key eq 'exonIntronRef' ) {
						my @array_refs = split ',', $tmp_info_read{$key};
						$current_read_info{$key} = \@array_refs;
					} elsif ( $key eq 'IDS_SJ_ref' or $key eq 'SJcorSeqRef' ) {
						if ($tmp_info_read{$key} eq 'NA'){
							$current_read_info{$key} = [];
						} else {
							my @array_refs = split ',', $tmp_info_read{$key};

							for my $array_string2 (@array_refs) {
								my @array_refs2 = split ';', $array_string2;
								push @{$current_read_info{$key}}, \@array_refs2;
							}
						}
					} else {
						$current_read_info{$key} = $tmp_info_read{$key} unless $key eq 'readSeq' and $tmp_info_read{'IDS_SJ_ref'} eq 'NA';
					}
				}
				#$accu_num ++;

				unshift @all_info_read, \%current_read_info;

				$n = $line[0];
			}
		}
					my $chr0 = $all_info_read[0]{'chr'};
					if (!defined $last_n or $n ne $last_n) {
						if ($n ne $last_n and !defined $keep_tmp) {
							unlink "$in/$target_ID/realign_$last_n/SJ_info.txt";
							unlink "$in/$target_ID/realign_$last_n/SJ_group.fa";
							rmdir "$in/$target_ID/realign_$last_n";
						}
						$same_group_count = 0;
						%group_SJ_cluster = ();
						%group_SJ_cluster_ends = ();
						if ($group_ID_mkdir{$n}[0] == 2){
							my $SJ_list = "$in/$target_ID/realign_$n/SJ_info.txt";
							open SJ_LIST, "<", $SJ_list or die "cannot open $SJ_list: $!";
							while (<SJ_LIST>) {
								chomp;
								my @line_SJ = split /\t/;
								if ($line_SJ[0] eq 'SJ_cluster') {
									$group_SJ_cluster_ends{$line_SJ[2]} = [$line_SJ[5], $line_SJ[6], $line_SJ[3]];
								} else {
									push @{$group_SJ_cluster{$line_SJ[-1]}}, [$line_SJ[1], $line_SJ[-3], $line_SJ[-2]];
								}
							}
							close SJ_LIST;

							# sort SJ_group.fa so that it can be read line by line
							&sort_sj_group_fa_file("$in/$target_ID/realign_$n/SJ_group.fa", "$in/$target_ID/realign_$n/SJ_group.fa.tmp");
						}
						printf "$n\t%g\n", scalar(keys %group_SJ_cluster_ends), scalar(@all_info_read);

					}
					
					$same_group_count ++;
					if (scalar(%group_SJ_cluster) > 0) {
						&realign_reads(\@all_info_read, \%group_SJ_cluster, \%group_SJ_cluster_ends, "$in/$target_ID/realign", $n, $same_group_count, $thread_ID, $chr0, \%summary_data, $aligner_matrix_pointer, $smith_waterman);
					} else {
						open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
						for my $read_ID (0 .. $#all_info_read){
							my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
							my $out = &summary_final_output($all_info_read[$read_ID], $n, $read_ID_update, {});
							print READ_FINAL $out;
						}
						$summary_data{'num_reads_output'} += (scalar @all_info_read);
						$summary_data{'num_reads_without_SJs_to_correct'} += (scalar @all_info_read);
						close READ_FINAL;
					}
					@all_info_read = ();
					$last_n = $n;
					if (!defined $keep_tmp) {
						unlink "$in/$target_ID/realign_$last_n/SJ_info.txt";
						unlink "$in/$target_ID/realign_$last_n/SJ_group.fa";
						rmdir "$in/$target_ID/realign_$last_n";
					}

		close IN;
		if (!defined $keep_tmp) {
			unlink "$in/$target_ID/$file";
		}

		if ($smith_waterman) {
			Parasail::matrix_free($aligner_matrix_pointer);
		}

		# indicate that the thread completed
		return (1, \%summary_data);
	}

	sub summary_final_output {
		my ($info_ref, $n, $read_ID_update, $hc_SJ_ref) = @_;
		my $out;

		#my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+${$info_ref}{'readID'};
		$out .= "${$info_ref}{'readID'}\tgroup_ID\t$n\t${n}_$read_ID_update\t${$info_ref}{'sample'}\n";
		$out .= "${$info_ref}{'readID'}\tstrand_isoform\tunknown\n";
		$out .= "${$info_ref}{'readID'}\tstrand_read\t${$info_ref}{'notSameStrand'}\n";
		$out .= "${$info_ref}{'readID'}\tchr\t${$info_ref}{'chr'}\n";
		$out .= "${$info_ref}{'readID'}\tmapq\t${$info_ref}{'mapq'}\n";
		$out .= "${$info_ref}{'readID'}\tflag\t${$info_ref}{'flag'}\n";					
		
		my $out_line = "${$info_ref}{'readID'}\tSJ";
		my $read_length = ${$info_ref}{'read_length'};

		for my $i(0 .. $#{${$info_ref}{'SJcorSeqRef'}}){
			my $j = $i + 1;
			my $SJ_info = ${$info_ref}{'SJcorSeqRef'}[$i];
			my @SJ_cor = split $sep_SJ, ${$SJ_info}[1];
			my $other_dist = $read_length-${$SJ_info}[0];
			$out .= "$out_line\t$j\t${$SJ_info}[1]\t${$SJ_info}[0]\t$other_dist\t";
			$out .= "fail2\tNA\tNA\tNA\tNA\t";
			if (exists ${$hc_SJ_ref}{${$SJ_info}[1]}) {
				$out .= "${$hc_SJ_ref}{${$SJ_info}[1]}[1]\tNA\n";
			} else {
				$out .= "no\tNA\n";
			}
			
		}

		my @unmapped_ends_raw = @{${$info_ref}{'clip_ends'}};
		my @mapped_genome_range_raw = (${$info_ref}{$ends[0]}, ${$info_ref}{$ends[1]});
		my $mapped_length_read;

		for my $i (0 .. $#ends){
			$out .= "${$info_ref}{'readID'}\t$ends[$i]\tNA\t";
			my $output_raw = "$mapped_genome_range_raw[$i]\t";
			if ($i == 0){
				$output_raw .= $unmapped_ends_raw[0]. "\t". ($read_length-$unmapped_ends_raw[0]). "\t";
				$mapped_length_read -= $unmapped_ends_raw[0];
			} else {
				$output_raw .= ($read_length-$unmapped_ends_raw[1]). "\t". $unmapped_ends_raw[1]. "\t";
				$mapped_length_read += ($read_length-$unmapped_ends_raw[1]);
			}
			$out .= $output_raw;
			my $output_correct = $output_raw."NA\tNA\tNA\n";
			if ($unmapped_ends_raw[$i] <= $directly_approve_length_additional){
				$out .= "pass2\t".$output_correct;
			} else {
				$out .= "fail2\t".$output_correct;
			}
			
		}
		$out .= join '', ("${$info_ref}{'readID'}\tmapped_length_read\t",$mapped_length_read,"\n");
		$out;
	}

	sub realign_reads {
		my ($all_info_read_ref, $group_SJ_cluster_ref, $group_SJ_cluster_ends_ref, $output_pre, $n, $same_group_count, $thread_ID, $chr0, $summary_data_ref, $aligner_matrix_pointer, $smith_waterman) = @_;
		###my $chr0 = $group_ID_mkdir{$n}[1];
		#my $out_dir = "${output_pre}_$n";
		my $out_dir = "$in/$target_ID/realign_$n/";
		my $read_final_out_path = "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt";

		#mkdir $out_dir or die "cannot mkdir $out_dir: $!";
		if (defined $keep_tmp) {
			open BACKUP, ">", "$in/$target_ID/realign_$n/backup_$same_group_count.txt" or die "cannot write to $in/$target_ID/realign_$n/backup_$same_group_count.fa";
		}
		print BACKUP "$n\t$same_group_count\n";
		my (%SJ_read, %read_no_SJ, @recorded_index);
		for my $read_ID (0 .. $#{$all_info_read_ref}){
			#$read_ID = ($same_group_count-1)*$proc_num_cutoff+$read_ID_raw;
			my $read_info_ref = ${$all_info_read_ref}[$read_ID];
			
			if (@{${$read_info_ref}{'IDS_SJ_ref'}}>0){
				my $notSameStrand = ${$read_info_ref}{'notSameStrand'};
				for my $i (0 .. $#{${$read_info_ref}{'IDS_SJ_ref'}}){
					my $j = $i+1;
					my ($insert_num, $deletion_num, $subst_num) = @{${$read_info_ref}{'IDS_SJ_ref'}[$i]};
					my ($pos_read, $SJ, undef) = @{${$read_info_ref}{'SJcorSeqRef'}[$i]};
					my ($chr, $SJ_start, $SJ_end, $notSameStrand_SJ) = split $sep_SJ, $SJ;

					if ( exists $SJ_read{$SJ} ) {
						$SJ_read{$SJ}[-1]{$read_ID} = [$j, $#{${$read_info_ref}{'IDS_SJ_ref'}}-$i+1, $insert_num, $deletion_num, $subst_num];#, $SJ_seq];
					} else {
						$SJ_read{$SJ} = [$chr, $SJ_start, $SJ_end, $SJ_end-$SJ_start, {$read_ID => [$j, $#{${$read_info_ref}{'IDS_SJ_ref'}}-$i+1, $insert_num, $deletion_num, $subst_num]} ];#, $SJ_seq]} ];
					}
					print BACKUP "$SJ, $read_ID, $j, ",$#{${$read_info_ref}{'IDS_SJ_ref'}}-$i+1, ", $insert_num, $deletion_num, $subst_num\n";
				}
			} else {
				$read_no_SJ{$read_ID} = 1;
			}
		}

		# Sort using both endpoints since two SJ clusters can share one endpoint
		my @SJ_cluster_r_index_sort = sort {
			my $a_info = ${$group_SJ_cluster_ends_ref}{$a};
			my $a_start = $a_info->[0];
			my $a_end = $a_info->[1];
			my $b_info = ${$group_SJ_cluster_ends_ref}{$b};
			my $b_start = $b_info->[0];
			my $b_end = $b_info->[1];
			($a_end <=> $b_end) or ($a_start <=> $b_start);
		} keys %{$group_SJ_cluster_ref};
		my @SJ_cluster_f_index_sort = sort {
			my $a_info = ${$group_SJ_cluster_ends_ref}{$a};
			my $a_start = $a_info->[0];
			my $a_end = $a_info->[1];
			my $b_info = ${$group_SJ_cluster_ends_ref}{$b};
			my $b_start = $b_info->[0];
			my $b_end = $b_info->[1];
			($b_start <=> $a_start) or ($b_end <=> $a_end);
		} keys %{$group_SJ_cluster_ref};

		my (%max_length_cluster, %read_seq_pos, %hc_SJ);
		my $num_mt0_index_ori = 0;
		for my $l (0 .. $#SJ_cluster_r_index_sort) {
			my $index_ori = $SJ_cluster_r_index_sort[$l];
			my @SJs_current_cluster = @{${$group_SJ_cluster_ref}{$index_ori}};

			$max_length_cluster{$index_ori} = [0, 0, 0, 0];
			$read_seq_pos{$index_ori} = [];
			
			
			for my $SJ_isHC (@SJs_current_cluster) {
				my ($SJ, $isAnno, $isHC) = @{$SJ_isHC};
				my @SJ_info = split $sep_SJ, $SJ;
				if ($isHC == 1) {
					$hc_SJ{$SJ} = [$SJ_info[-1], $isAnno];
				}
				printf BACKUP "SJ_isHC: $SJ, $isHC\t";
				my @perfect_reads;
				if (exists $SJ_read{$SJ}) {
					print BACKUP scalar(keys %{$SJ_read{$SJ}[-1]}),"\n";
					my $SJ_info_ref = $SJ_read{$SJ};
					my ($chr, $SJ_start, $SJ_end, $gap, $read_hash_ref) = @{$SJ_info_ref};
					while ( my ($read_ID, $info_ref) = each %{$read_hash_ref} ) {
						my $i = ${$info_ref}[0]-1;
						my $read_info_ref = ${$all_info_read_ref}[$read_ID];
						my @SJs_read_info = @{${$read_info_ref}{'SJcorSeqRef'}};
						my $SJ_read_info_ref = $SJs_read_info[$i];
						die "cannot correspond $SJ of cluster $l of read group $n to ${$all_info_read_ref}[$read_ID]{'readID'}: ${$SJ_read_info_ref}[1]" if ${$SJ_read_info_ref}[1] ne $SJ;
						my ($length_r, $length_f) = (${$SJ_read_info_ref}[0], ${$read_info_ref}{'read_length'} - ${$SJ_read_info_ref}[0]);
						my $strand_adapted_SJ_pos;
						if( ${$read_info_ref}{'notSameStrand'} == 1 ) {
							$strand_adapted_SJ_pos = $length_f;
						} else {
							$strand_adapted_SJ_pos = $length_r;
						}
						push @{$read_seq_pos{$index_ori}}, [$read_ID, $strand_adapted_SJ_pos, 0, 0];
						if ($i == 0){
							$read_seq_pos{$index_ori}[-1][-2] = $length_r;
							$max_length_cluster{$index_ori}[0] = $length_r if $max_length_cluster{$index_ori}[0] < $length_r;
						} if ($i == $#SJs_read_info) {
							$read_seq_pos{$index_ori}[-1][-1] = $length_f;
							$max_length_cluster{$index_ori}[1] = $length_f if $max_length_cluster{$index_ori}[1] < $length_f;
						}
					}
					@perfect_reads = grep {${$read_hash_ref}{$_}[2]+${$read_hash_ref}{$_}[3]+${$read_hash_ref}{$_}[4]==0} keys %{$read_hash_ref};
					if ($isHC == 1){
						${$all_info_read_ref}[$_]{'SJcorSeqRef'}[ ${$read_hash_ref}{$_}[0]-1 ][2] = scalar(@perfect_reads) for @perfect_reads;
					}
				} else {
					printf BACKUP "0\n";
				}
				

				### require perfect read count, ratio and matched splicing signals
				if ($isHC == 1){
					$max_length_cluster{$index_ori}[2] += 2;
				}

			}

			printf BACKUP "cluster_info:\t$l\t$index_ori\t$max_length_cluster{$index_ori}[0]\t$max_length_cluster{$index_ori}[1]\t$max_length_cluster{$index_ori}[2]\t$max_length_cluster{$index_ori}[3]\t",  scalar(@{$read_seq_pos{$index_ori}}), "\n";
			if (@{$read_seq_pos{$index_ori}} > 0) {
				$num_mt0_index_ori ++;
				my @SJ_ends_current_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori}};
				my @index_ori_pre_qualified;
				#print ALLSJ "possible length_r of $index_ori($max_length_cluster{$index_ori}[0]):";
				for my $rev_p (1 .. $l) {
					my $p = $l - $rev_p;
					my $index_ori_pre = $SJ_cluster_r_index_sort[$p];
					my @SJ_ends_pre_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori_pre}};
					# This check depends on the start and end coordinates and also the
					# order of SJ_cluster_r_index_sort. SJ_cluster_r_index_sort is in
					# ascending order of end coordinate with start coordinate used to break ties.
					my $dist = $SJ_ends_current_cluster[0]-$SJ_ends_pre_cluster[1];
					if ( $max_length_cluster{$index_ori}[0]*$fold_end_length_lost_cutoff >= $dist and $dist > 0-$max_overlap_SJ_group ){
						push @index_ori_pre_qualified, [$index_ori_pre, $dist];
						#print ALLSJ "\t$index_ori_pre($dist)";
					} elsif ($max_length_cluster{$index_ori}[0]*$fold_end_length_lost_cutoff < $dist) {
						last;
					}

				}
				
				#print ALLSJ "\n";

				if (@index_ori_pre_qualified > 0) {
					for my $read_pos_ref (@{$read_seq_pos{$index_ori}}) {
						my ($read_ID, $strand_adapted_SJ_pos, $length_r, $length_f) = @{$read_pos_ref};
						#print ALLSJ "length_r of $read_ID($length_r):";
						if ($length_r > 0) {
							for my $index_ori_pre_ref (@index_ori_pre_qualified) {
								my ($index_ori_pre, $dist) = @{$index_ori_pre_ref};
								if ($length_r*$fold_end_length_lost_cutoff >= $dist) {
									push @{$read_seq_pos{$index_ori_pre}}, [$read_ID, $strand_adapted_SJ_pos, -1, 0];
									#print ALLSJ "\t$index_ori_pre($dist)";
								} else {
									last;
								}

							}
						}
						#print ALLSJ "\n";
					}
				}
			}

		}

		printf BACKUP "SJ_read:%g\tnum_mt0_index_ori:%g\n", scalar(%SJ_read), $num_mt0_index_ori;
		for my $l (0 .. $#SJ_cluster_f_index_sort) {
			my $index_ori = $SJ_cluster_f_index_sort[$l];
			next unless $max_length_cluster{$index_ori}[2] > 0;
			
			if (@{$read_seq_pos{$index_ori}} > 0) {
				my @SJ_ends_current_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori}};
				my @index_ori_next_qualified;
				#print ALLSJ "possible length_f of $index_ori($max_length_cluster{$index_ori}[1]):";
				for my $rev_p (1 .. $l) {
					my $p = $l - $rev_p;
					my $index_ori_next = $SJ_cluster_f_index_sort[$p];
					my @SJ_ends_next_cluster = @{${$group_SJ_cluster_ends_ref}{$index_ori_next}};
					# This check depends on the start and end coordinates and also the
					# order of SJ_cluster_f_index_sort. SJ_cluster_f_index_sort is in
					# descending order of start coordinate with end coordinate used to break ties.
					my $dist = $SJ_ends_next_cluster[0]-$SJ_ends_current_cluster[1];
					if ( $max_length_cluster{$index_ori}[1]*$fold_end_length_lost_cutoff >= $dist and $dist > 0-$max_overlap_SJ_group ){
						#print ALLSJ "\t$index_ori_next($dist)";
						push @index_ori_next_qualified, [$index_ori_next, $dist];
					} elsif ( $max_length_cluster{$index_ori}[1]*$fold_end_length_lost_cutoff < $dist ) {
						last;
					}

				}
				#print ALLSJ "\n";
				if (@index_ori_next_qualified > 0) {
					for my $read_pos_ref (@{$read_seq_pos{$index_ori}}) {
						my ($read_ID, $strand_adapted_SJ_pos, $length_r, $length_f) = @{$read_pos_ref};
						#print ALLSJ "length_f of $read_ID($length_f):";
						if ($length_f > 0) {
							for my $index_ori_next_ref (@index_ori_next_qualified) {
								my ($index_ori_next, $dist) = @{$index_ori_next_ref};
								if ($length_f*$fold_end_length_lost_cutoff >= $dist) {
									push @{$read_seq_pos{$index_ori_next}}, [$read_ID, $strand_adapted_SJ_pos, 0, -1];
									#print ALLSJ "\t$index_ori_next($dist)";
								} else {
									last;
								}

							}
						} elsif ($length_r == -1) {
							last;
						}
						#print ALLSJ "\n";
					}
				}
			}
		}
		my $to_blast_name = "$in/$target_ID/realign_$n/read_group_$same_group_count.fa";
		open(my $to_blast_handle, ">", $to_blast_name) or die "cannot write to $to_blast_name";
		my %read_seqs_to_align_by_cluster_index;
		my ($max_index,undef) = sort {$b <=> $a} keys %{$group_SJ_cluster_ref};
		for my $index_ori (0 .. $max_index) {
			next unless exists $read_seq_pos{$index_ori};
			# TODO $current_cluster_SJ_number may always be 0 because ${$_}[1] is 'yes' or 'no'
			my $current_cluster_SJ_number = grep {${$_}[1]>0} @{${$group_SJ_cluster_ref}{$index_ori}};
			if (@{$read_seq_pos{$index_ori}} > 0 and $max_length_cluster{$index_ori}[2] > 0) {
				my @reads_seq4realign;
				my @reads_cluster_sort = sort { ${$a}[0] cmp ${$b}[0] } @{$read_seq_pos{$index_ori}};
				my ($last_read, %last_read2extract);
				for my $read_pos_ref (@reads_cluster_sort) {
					my ($read_ID, $strand_adapted_SJ_pos, $length_r, $length_f) = @{$read_pos_ref};
					if (defined $last_read and $last_read ne $read_ID) {
						my $seqs_to_align = &get_sequences_to_align_for_read_id($all_info_read_ref, $last_read, \%last_read2extract, $current_cluster_SJ_number, $SJFS_dist_add, $SJFS_dist, $smith_waterman);
						if ($smith_waterman) {
							$read_seqs_to_align_by_cluster_index{$index_ori}{$last_read} = $seqs_to_align;
						} else {
							push @reads_seq4realign, (">$last_read SJclst:$index_ori:", $seqs_to_align);
						}

						%last_read2extract = ();
					}
					if (!exists $last_read2extract{$strand_adapted_SJ_pos}) {
						$last_read2extract{$strand_adapted_SJ_pos} = [$length_r, $length_f];
					} else {
						if ( $length_r != 0 ) {
							$last_read2extract{$strand_adapted_SJ_pos}[0] = $length_r;
						} if ( $length_f != 0 ) {
							$last_read2extract{$strand_adapted_SJ_pos}[1] = $length_f;
						}
					}

					$last_read = $read_ID;
				}

				if (defined $last_read) {
					my $seqs_to_align = &get_sequences_to_align_for_read_id($all_info_read_ref, $last_read, \%last_read2extract, $current_cluster_SJ_number, $SJFS_dist_add, $SJFS_dist, $smith_waterman);
					if ($smith_waterman) {
						$read_seqs_to_align_by_cluster_index{$index_ori}{$last_read} = $seqs_to_align;
					} else {
						push @reads_seq4realign, (">$last_read SJclst:$index_ori:", $seqs_to_align);
					}
					%last_read2extract = ();
				}

				if ($smith_waterman) {
					$max_length_cluster{$index_ori}[3] += scalar(keys %{$read_seqs_to_align_by_cluster_index{$index_ori}});
				} else {
					print $to_blast_handle "$_\n" for @reads_seq4realign;
					$max_length_cluster{$index_ori}[3] += @reads_seq4realign;
				}
			}
		}

		close $to_blast_handle;
		if (defined $keep_tmp) {
			close BACKUP;
		}

		my %alignments_by_read = ();
		my $sj_group_fa_path = "$out_dir/SJ_group.fa";
		open(my $sj_group_fa_handle, "<", $sj_group_fa_path);

		my ($accumul_read_line, $accumul_SJ_line) = (0, 0);
		my $blast_read_in_path = "$out_dir/read_group_$same_group_count.fa";
		open(my $blast_read_in_handle, "<", $blast_read_in_path);
		my $blast_sj_temp_path = "$sj_group_fa_path.blast.tmp";
		my $blast_read_temp_path = "$blast_read_in_path.blast.tmp";
		open(my $blast_sj_temp_handle, ">", $blast_sj_temp_path);
		open(my $blast_read_temp_handle, ">", $blast_read_temp_path);

		for my $index_ori (0 .. $max_index) {
			my @cluster_sjs = ();
			my $cluster_read_count = $max_length_cluster{$index_ori}[3];
			# cluster_sj_count is actually 2*(number_of_sj) because each
			# SJ is two lines in the .fa
			my $cluster_sj_count = $max_length_cluster{$index_ori}[2];
			if ($smith_waterman) { $cluster_sj_count = $cluster_sj_count / 2 };
			# Always read the SJ and read lines from the files.
			# Only write them to the temp files if there are both SJs and reads
			my $have_both_sjs_and_reads = (($cluster_sj_count > 0) and ($cluster_read_count > 0));
			my $anything_already_written = ($accumul_read_line > 0);
			if (!$smith_waterman and $have_both_sjs_and_reads and $anything_already_written) {
				my $estimate_of_blast_on_written = &estimate_blast_runtime($accumul_read_line, $accumul_SJ_line);
				my $estimate_of_blast_on_new = &estimate_blast_runtime($cluster_read_count, $cluster_sj_count);
				my $estimate_of_blast_on_combined = &estimate_blast_runtime($accumul_read_line + $cluster_read_count, $accumul_SJ_line + $cluster_sj_count);
				my $should_run_before_writing = (($estimate_of_blast_on_written + $estimate_of_blast_on_new) < $estimate_of_blast_on_combined);

				if ($should_run_before_writing) {
					# Close the temp files to flush them
					close($blast_sj_temp_handle);
					close($blast_read_temp_handle);
					&run_blast_on_files($blast_sj_temp_path, $blast_read_temp_path, $out_dir, $same_group_count, $evalue_cor, $summary_data_ref);
					($accumul_read_line, $accumul_SJ_line) = (0, 0);
					# Reopen the temp files to truncate them.
					open($blast_sj_temp_handle, ">", $blast_sj_temp_path);
					open($blast_read_temp_handle, ">", $blast_read_temp_path);
				}
			}

			if ($smith_waterman) {
				for my $sj_i (0 .. ($cluster_sj_count - 1)) {
					my $sj_line_1 = <$sj_group_fa_handle>;
					my $sj_line_2 = <$sj_group_fa_handle>;
					if ($have_both_sjs_and_reads) {
						push @cluster_sjs, &parse_sj_group_fa_entry($sj_line_1, $sj_line_2);
					}
				}

				if ($have_both_sjs_and_reads) {
					&run_aligner_on_reads_and_sjs($read_seqs_to_align_by_cluster_index{$index_ori}, \@cluster_sjs, $summary_data_ref, $aligner_matrix_pointer, \%alignments_by_read);
				}
			} else {
				# cluster_read_count is actually 2*(number_of_read_sequences).
				# This is convenient because the entry for each sequence is two lines long.
				for my $new_read_i (0 .. ($cluster_read_count - 1)) {
					my $new_read_line = <$blast_read_in_handle>;
					if ($have_both_sjs_and_reads) {
						print $blast_read_temp_handle $new_read_line;
					}
				}
				# cluster_sj_count is actually 2*(number_of_sj).
				# This is convenient because the entry for each SJ is two lines long.
				for my $new_sj_i (0 .. ($cluster_sj_count - 1)) {
					my $new_sj_line = <$sj_group_fa_handle>;
					if ($have_both_sjs_and_reads) {
						print $blast_sj_temp_handle $new_sj_line;
					}
				}

				if ($have_both_sjs_and_reads) {
					$accumul_read_line += $cluster_read_count;
					$accumul_SJ_line += $cluster_sj_count;
				}

				# Make sure to run blast if this is the last loop iteration
				if (($index_ori == $max_index) and ($accumul_read_line > 0)) {
					# Close the temp files to flush them
					close($blast_sj_temp_handle);
					close($blast_read_temp_handle);
					&run_blast_on_files($blast_sj_temp_path, $blast_read_temp_path, $out_dir, $same_group_count, $evalue_cor, $summary_data_ref);
					($accumul_read_line, $accumul_SJ_line) = (0, 0);
					# Reopen the temp files to truncate them.
					open($blast_sj_temp_handle, ">", $blast_sj_temp_path);
					open($blast_read_temp_handle, ">", $blast_read_temp_path);
				}
			}
		}
		close($blast_read_in_handle);
		close($blast_sj_temp_handle);
		close($blast_read_temp_handle);

		if (!defined $keep_tmp) {
			unlink $blast_read_in_path;
			unlink "$out_dir/current_db.nhr";
			unlink "$out_dir/current_db.nin";
			unlink "$out_dir/current_db.nsq";
			unlink $blast_sj_temp_path;
			unlink $blast_read_temp_path;
		}

		my $output_blast;
		my $was_no_blast_output = 0;
		if ( -s $out_dir."/read_SJ_group_$same_group_count.blast" > 0 ) {
			$output_blast = $out_dir."/read_SJ_group_$same_group_count.sort.blast";
			my $sort_command = "sort $sort_buffer_size -k1,1 -k12,12r $out_dir/read_SJ_group_$same_group_count.blast > $output_blast";
			my $exit_sort = system($sort_command);
			if ($exit_sort != 0) {
				warn "Failed to run \"$sort_command\". Exit code is $exit_sort";
			}
		} elsif (!$smith_waterman) {
			$was_no_blast_output = 1;
			for my $read_ID(0 .. $#{$all_info_read_ref}){
				if ($recorded_index[$read_ID] == 1){
					$read_no_SJ{$read_ID} = 1;
				}
			}
		}
		close($sj_group_fa_handle);

		if (scalar(keys %read_no_SJ) > 0) {
			open READ_FINAL, ">>", "$read_final_out_path" or die "cannot write $read_final_out_path: $!";
			while (my ($read_ID, undef) = each %read_no_SJ) {
				my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
				my $out = &summary_final_output(${$all_info_read_ref}[$read_ID], $n, $read_ID_update, \%hc_SJ);
				print READ_FINAL $out;
			}
			$summary_data_ref->{'num_reads_output'} += (scalar keys %read_no_SJ);
			if (!$smith_waterman and $was_no_blast_output) {
				$summary_data_ref->{'num_reads_missing_blast_output'} += (scalar keys %read_no_SJ);
			} else {
				$summary_data_ref->{'num_reads_without_SJs_to_correct'} += (scalar keys %read_no_SJ);
			}
			close READ_FINAL;
		}

		my (%SJ_missing_candidate);
		if ($smith_waterman or defined $output_blast) {
			if (defined $keep_tmp) {
				open READ_SUMM, ">", "$out_dir/lost_end_group_$n.backup" or die "cannot write $out_dir/lost_end_group_$n.backup: $!";
			}

			my $lost_end_file_path = "$out_dir/lost_end_group_$same_group_count.fa";
			open(my $lost_end_handle, ">", $lost_end_file_path) or die "cannot write $lost_end_file_path:$!";
			print READ_SUMM "$out_dir/lost_end_group_$same_group_count.fa loaded\n";
			if ($smith_waterman) {
				while (my ($read_id, $alignments_by_sj_ref) = each %alignments_by_read) {
					my @pre_ID_alignments;
					while (my ($sj_id, $alignment_info_array_ref) = each %{$alignments_by_sj_ref}) {
						# Prefer alignments with a higher score.
						my @sorted_alignments = sort {$b->{'score'} <=> $a->{'score'}} @{$alignment_info_array_ref};
						for my $alignment_info_ref (@sorted_alignments) {
							my $read_start = $alignment_info_ref->{'read_start'};
							my $read_end = $alignment_info_ref->{'read_end'};
							my $sj_start = $alignment_info_ref->{'sj_start'};
							my $sj_end = $alignment_info_ref->{'sj_end'};
							my $cigar_ref = $alignment_info_ref->{'cigar'};
							my $read_strand_matches_sj_annotation = $hc_SJ{$sj_id}[0] eq ${$all_info_read_ref}[$read_id]{'notSameStrand'};
							my $sj_offsets_cover_junction = (($sj_start <= $SJFS_dist_add) and ($sj_end >= 2*$SJFS_dist + $SJFS_dist_add));
							if ($sj_offsets_cover_junction and ($is_stranded != 1 or $read_strand_matches_sj_annotation)) {
								push @pre_ID_alignments, &process_alignment_details($cigar_ref, $read_start, $read_end, $sj_start, $sj_end, $sj_id);
								last;
							}
						}
					}
					&process_realign_results_for_read_id($all_info_read_ref, $read_id, $SJFS_dist, $SJFS_dist_add, \@pre_ID_alignments, \%hc_SJ, $confirm_prob_fold_cutoff, $length4nhmmer_max, $lost_end_handle, $sep_end_blast, \%SJ_missing_candidate);
					@pre_ID_alignments = ();
				}
			} else {
				open BLAST, "<", $output_blast or die "cannot open $output_blast:$!";
				my ($last_read, @pre_ID_alignments, %recorded_SJ);
				while (<BLAST>) {
					s/\r\n//;
					chomp;
					my @line = split /\t/;
					my ($read_ID, $sbjct_ID, $start, $end) = ($line[0], $line[1], $line[8], $line[9]);
					if (defined $last_read and $last_read ne $read_ID) {
						&process_realign_results_for_read_id($all_info_read_ref, $last_read, $SJFS_dist, $SJFS_dist_add, \@pre_ID_alignments, \%hc_SJ, $confirm_prob_fold_cutoff, $length4nhmmer_max, $lost_end_handle, $sep_end_blast, \%SJ_missing_candidate);
						@pre_ID_alignments = ();
						%recorded_SJ = ();
					}
					if ( !exists $recorded_SJ{$sbjct_ID} and &min($start,$end)<=$SJFS_dist_add and &max($start,$end)>=2*$SJFS_dist+$SJFS_dist_add and ( (${$all_info_read_ref}[$read_ID]{'notSameStrand'}==1 and $start>$end) or (${$all_info_read_ref}[$read_ID]{'notSameStrand'}==0 and $start<$end)) and ( $is_stranded !=1 or $hc_SJ{$sbjct_ID}[0] eq ${$all_info_read_ref}[$read_ID]{'notSameStrand'}) ) {
						push @pre_ID_alignments, &ID_align_btop($line[-1],[$line[6], $line[7]],[$line[8], $line[9]],$sbjct_ID);
						$recorded_SJ{$sbjct_ID} = 1;
					}
					$last_read = $read_ID;
				}
				close BLAST;
				if (defined $last_read ) {
					&process_realign_results_for_read_id($all_info_read_ref, $last_read, $SJFS_dist, $SJFS_dist_add, \@pre_ID_alignments, \%hc_SJ, $confirm_prob_fold_cutoff, $length4nhmmer_max, $lost_end_handle, $sep_end_blast, \%SJ_missing_candidate);
					@pre_ID_alignments = ();
					%recorded_SJ = ();
				}
				if (!defined $keep_tmp) {
					unlink $out_dir."/read_SJ_group_$same_group_count.blast";
					unlink $output_blast;
				}
			}

			close $lost_end_handle;

			my $flankSJfile = "$out_dir/flankingSJ_group_$same_group_count.fa";
			my ($db_size, $db_SJ_type_num) = (0, 0);
			my @flankSJfile_SJ_types;
			
			if(-s "$out_dir/lost_end_group_$same_group_count.fa" > 0) {
				my $m = 0;
				my @info_m;
				open FLANK_SJ, ">", $flankSJfile or die "cannot write $flankSJfile:$!";
				
				while (my ($SJ, $type_ref) = each %SJ_missing_candidate) {
					while (my ($type, $read_ref) = each %{$type_ref}) {
						$m ++;
						#my @length_sort = sort { $b <=> $a } values %{$read_ref};
						#my $length4nhmmer = &min(200, int($length_sort[0]));
						my $length4nhmmer = $length4nhmmer_max;
						my ($substr_chr_SJ, $substr_chr_flanking);
						my @SJ_cor = split $sep_SJ, $SJ;
						my ($strand_pos1, $strand_pos2) = ("$SJ/-1/","$SJ/-2/");
						if ($type eq '0') {
							my $mapped_seq = substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[2], ($SJFS_dist+$SJFS_dist_add) );
							$substr_chr_SJ = 		substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[1]-&min($length4nhmmer+$END_dist_add, $SJ_cor[1]), &min($length4nhmmer+$END_dist_add, $SJ_cor[1]) ).$mapped_seq;
							$substr_chr_flanking = 	substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[2]-&min($length4nhmmer+$END_dist_add, $SJ_cor[2]), &min($length4nhmmer+$END_dist_add, $SJ_cor[2]) ).$mapped_seq;
							$strand_pos1 .= '0/';
							$strand_pos2 .= '1/';
						} else {
							my $mapped_seq = substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[1]-($SJFS_dist+$SJFS_dist_add), ($SJFS_dist+$SJFS_dist_add) );
							$substr_chr_SJ = 		$mapped_seq.substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[2], &min($length4nhmmer+$END_dist_add, $chr_seq_len{$SJ_cor[0]}-$SJ_cor[2]) );
							$substr_chr_flanking = 	$mapped_seq.substr( $chr_seq{$SJ_cor[0]}, $SJ_cor[1], &min($length4nhmmer+$END_dist_add, $chr_seq_len{$SJ_cor[0]}-$SJ_cor[1]) );
							$strand_pos1 .= '1/';
							$strand_pos2 .= '0/';
						}
						my ($SJ_seq_s, $flank_seq_s) = (length($substr_chr_SJ), length($substr_chr_flanking));
						
						print FLANK_SJ ">$SJ$sep_end_blast$type${sep_end_blast}SJ$sep_end_blast",$SJ_seq_s,"\n$substr_chr_SJ\n";
						print FLANK_SJ ">$SJ$sep_end_blast$type${sep_end_blast}flanking$sep_end_blast",$flank_seq_s,"\n$substr_chr_flanking\n";

						push @info_m, [$strand_pos1, $strand_pos2, scalar(values %{$read_ref})*2];

					}
				}
				close FLANK_SJ;
				die "$m != @info_m" if @info_m != $m;
				my ($start_line, $accumul_SJ_line, $accumul_read_line, $accumul_SJ_string) = (1, 0, 0, '');

				for my $i (1 .. $m) {
					
					my ($strand_pos1, $strand_pos2, $read_line) = @{$info_m[$i-1]};
					$accumul_SJ_string .= " -e $strand_pos1 -e $strand_pos2";
					$accumul_SJ_line += 4;
					$accumul_read_line += $read_line;
					if ($accumul_SJ_line>=100) {
						system("tail -n +$start_line $flankSJfile | head -$accumul_SJ_line > $out_dir/current_flankingSJ.fa");
						my $exit_nhmmer = system("grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_$i.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null");
						if ($exit_nhmmer != 0) {
							warn "Failed to run \"grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_$i.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null\". Exit code is $exit_nhmmer"; 
						}
						$summary_data_ref->{'number_of_nhmmer_calls'} ++;
						$start_line += $accumul_SJ_line;
						($accumul_SJ_line, $accumul_read_line, $accumul_SJ_string) = (0, 0, '');
					}
				}

				if ($accumul_SJ_line*$accumul_read_line > 0 and $m > 0) {
						system("tail -n +$start_line $flankSJfile | head -$accumul_SJ_line > $out_dir/current_flankingSJ.fa");
						my $exit_nhmmer = system("grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_0.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null");
						if ($exit_nhmmer != 0) {
							warn "Failed to run \"grep -A1 --no-group-separator$accumul_SJ_string $out_dir/lost_end_group_$same_group_count.fa | nhmmer --dna -T 3 --max --cpu 2 --tblout $out_dir/lost_end_group_${same_group_count}_0.hmmer1 --qformat fasta --qsingle_seqs - $out_dir/current_flankingSJ.fa > /dev/null\". Exit code is $exit_nhmmer"; 
						}
						$summary_data_ref->{'number_of_nhmmer_calls'} ++;
				}

				

			}
			if (!defined $keep_tmp) {
				unlink $flankSJfile;
				unlink "$out_dir/lost_end_group_$same_group_count.fa";
			}
			my (@ends_lost, $end_lost);
			@ends_lost = glob("$out_dir/lost_end_group_${same_group_count}_*.hmmer1");
			if (@ends_lost > 0) {
				$end_lost = "$out_dir/lost_end_group.hmmer2";
				system("cat @ends_lost > $out_dir/lost_end_groups.hmmer1");
				if (-s "$out_dir/lost_end_groups.hmmer1">0){
					my $sort_command = "sort $sort_buffer_size -k3,3 -k14,14r -s $out_dir/lost_end_groups.hmmer1 > $end_lost";
					my $exit_sort = system($sort_command);
					if ($exit_sort != 0) {
						warn "Failed to run \"$sort_command\". Exit code is $exit_sort";
					}
				}
				if (!defined $keep_tmp) {
					unlink "$_" for @ends_lost;
					unlink "$out_dir/lost_end_groups.hmmer1";
					unlink "$out_dir/current_flankingSJ.fa";
				}
			}
			
			if(defined $end_lost and -s $end_lost > 0 ){
	
				my ($last_read, $last_pos, %last_read_info);
				open HMMER2, "<", $end_lost or die "cannot open $end_lost: $!";
				print READ_SUMM "$end_lost loaded\n";
				while (<HMMER2>) {
					chomp;
					my @line = split /\s+/;
					next if $line[0] eq '#';
					my ($read_ID, $SJ2, $pos, $notSameStrand, $length, $extra_length, $length_raw) = split $sep_end_blast, $line[2];
					my ($SJ, $type, $cand_type, $length_G) = split $sep_end_blast, $line[0];		
					my @SJ_cor = split $sep_SJ, $SJ2;
					
					if(defined $last_read and ($last_read ne $read_ID or $pos ne $last_pos) ) {
						if (exists $last_read_info{'SJ'}) {
							my @SJ_sort = sort { $last_read_info{'SJ'}{$b}[0] <=> $last_read_info{'SJ'}{$a}[0] } keys %{$last_read_info{'SJ'}};
							my $candidate_SJ = $SJ_sort[0];

							if (!exists $last_read_info{'flanking'} or !exists $last_read_info{'flanking'}{$candidate_SJ} or $last_read_info{'SJ'}{$candidate_SJ}[0]-$last_read_info{'flanking'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff ){
								if ( @SJ_sort == 1 or $last_read_info{'SJ'}{$candidate_SJ}[0] - $last_read_info{'SJ'}{$SJ_sort[1]}[0] >= $blast_score_difference_cutoff ) {
									${$all_info_read_ref}[$last_read]{$last_pos.'_update'} = [$last_read_info{'SJ'}{$candidate_SJ}[2], $last_read_info{'SJ'}{$candidate_SJ}[3]];
									${$all_info_read_ref}[$last_read]{$last_pos} = $candidate_SJ;
									print READ_SUMM "${last_pos}_update:\t$last_read\t$last_pos\t$candidate_SJ\t@{${$all_info_read_ref}[$last_read]{$last_pos.'_update'}}\n";
								} else {
									${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD';
									print READ_SUMM "${last_pos}_not_update:\t$last_read\t$last_pos\t$candidate_SJ\n";
								}
							} elsif (exists $last_read_info{'flanking'}{$candidate_SJ} and $last_read_info{'flanking'}{$candidate_SJ}[0]-$last_read_info{'SJ'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff) {
								print READ_SUMM "${last_pos}_no_add:\t$last_read\t$last_pos\n";
							} else {
								${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD2';
								print READ_SUMM "${last_pos}_not_sure:\t$last_read\t$last_pos\n";
							}
						} elsif (exists $last_read_info{'flanking'}) {
							print READ_SUMM "${last_pos}_no_add2:\t$last_read\t$last_pos\n";
						} else {
							${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD3';
							print READ_SUMM "${last_pos}_not_sure2:\t$last_read\t$last_pos\n";
						}
						%last_read_info = ();
					}

					if ( $SJ2 eq $SJ ) {
						my $tag = 0;

						if ($pos eq '-1' and 0-$notSameStrand== $type and $length-$line[5]<=$extra_length) { #$length-$line[5]<=$SJFS_dist+$SJFS_dist_add
							$tag = 1;
						} elsif ($pos eq '-2' and $notSameStrand-1== $type and $line[4]<=$extra_length) {
							$tag = 2;
						}
						# pos_update_read is the number of bases unmatched at the start or end of the read
						my $pos_update_read;
						if ($pos eq '-1') {
							my $query_len_before_sj = $length - $extra_length;
							my $query_start_unmatched = $line[4] - 1;
							my $old_len_before_sj = $length_raw;
							my $len_read_seq_not_in_query = $old_len_before_sj - $query_len_before_sj;
							$pos_update_read = $query_start_unmatched + $len_read_seq_not_in_query;
						} elsif(exists ${$all_info_read_ref}[$read_ID]{'read_SJ_missing'}{${$all_info_read_ref}[$read_ID]{'notSameStrand'}-1}{$SJ}) {
							my $query_len_after_sj = $length - $extra_length;
							my $query_end_unmatched = $length - $line[5];
							my $old_len_after_sj = $length_raw;
							my $len_read_seq_not_in_query = $old_len_after_sj - $query_len_after_sj;
							$pos_update_read = $query_end_unmatched + $len_read_seq_not_in_query;
						} else {
							die "$pos:doesn't exists ${$all_info_read_ref}[$read_ID]{'readID'} read_SJ_missing ${$all_info_read_ref}[$read_ID]{'notSameStrand'} $SJ";
						}
						my $sjfs_total = $SJFS_dist + $SJFS_dist_add;
						my $higher_target_coord = &max($line[6], $line[7]);
						my $lower_target_coord = &min($line[6], $line[7]);
						my $target_match_len = ($higher_target_coord - $lower_target_coord) + 1;
						my $target_unmatched_at_end = $length_G - $higher_target_coord;
						my $target_unmatched_at_start = $lower_target_coord - 1;
						if ($tag > 0 and $type eq '0' and $target_unmatched_at_end <= $sjfs_total and $target_match_len > $sjfs_total and !exists $last_read_info{$cand_type}{$SJ}) {
							my $last_coord_of_exon = $SJ_cor[1]; # 1-based
							my $length_matched_past_sj = $sjfs_total - $target_unmatched_at_end;
							my $length_matched_before_sj = ($target_match_len - $length_matched_past_sj) - 1;
							my $aligned_start_coord = $last_coord_of_exon - $length_matched_before_sj;
							$last_read_info{$cand_type}{$SJ} = [$line[-3], $line[-4], $aligned_start_coord, $pos_update_read];

						} elsif ($tag > 0 and $type eq '-1' and $target_unmatched_at_start <= $sjfs_total and $target_match_len > $sjfs_total and !exists $last_read_info{$cand_type}{$SJ}) {
							my $first_coord_of_exon = $SJ_cor[2]; # 0-based
							my $length_matched_before_sj = $sjfs_total - $target_unmatched_at_start;
							my $length_matched_past_sj = ($target_match_len - $length_matched_before_sj) - 1;
							my $aligned_end_coord = $first_coord_of_exon + 1 + $length_matched_past_sj;
							$last_read_info{$cand_type}{$SJ} = [$line[-3], $line[-4], $aligned_end_coord, $pos_update_read];
						}
					}
					
					$last_read = $read_ID;
					$last_pos = $pos;
				}

				close HMMER2;

						if (exists $last_read_info{'SJ'}) {
							my @SJ_sort = sort { $last_read_info{'SJ'}{$b}[0] <=> $last_read_info{'SJ'}{$a}[0] } keys %{$last_read_info{'SJ'}};
							my $candidate_SJ = $SJ_sort[0];

							if (!exists $last_read_info{'flanking'} or !exists $last_read_info{'flanking'}{$candidate_SJ} or $last_read_info{'SJ'}{$candidate_SJ}[0]-$last_read_info{'flanking'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff ){
								if ( @SJ_sort == 1 or $last_read_info{'SJ'}{$candidate_SJ}[0] - $last_read_info{'SJ'}{$SJ_sort[1]}[0] >= $blast_score_difference_cutoff ) {
									${$all_info_read_ref}[$last_read]{$last_pos.'_update'} = [$last_read_info{'SJ'}{$candidate_SJ}[2], $last_read_info{'SJ'}{$candidate_SJ}[3]];
									${$all_info_read_ref}[$last_read]{$last_pos} = $candidate_SJ;
									print READ_SUMM "${last_pos}_update:\t$last_read\t$last_pos\t$candidate_SJ\t@{${$all_info_read_ref}[$last_read]{$last_pos.'_update'}}\n";
								} else {
									${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD';
									print READ_SUMM "${last_pos}_not_update:\t$last_read\t$last_pos\t$candidate_SJ\n";
								}
							} elsif (exists $last_read_info{'flanking'}{$candidate_SJ} and $last_read_info{'flanking'}{$candidate_SJ}[0]-$last_read_info{'SJ'}{$candidate_SJ}[0]>=$blast_score_difference_cutoff) {
								print READ_SUMM "${last_pos}_no_add:\t$last_read\t$last_pos\n";
							} else {
								${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD2';
								print READ_SUMM "${last_pos}_not_sure:\t$last_read\t$last_pos\n";
							}
						} elsif (exists $last_read_info{'flanking'}) {
							print READ_SUMM "${last_pos}_no_add2:\t$last_read\t$last_pos\n";
						} else {
							${$all_info_read_ref}[$last_read]{$last_pos} = 'TBD3';
							print READ_SUMM "${last_pos}_not_sure2:\t$last_read\t$last_pos\n";
						}
			}
			if (defined $keep_tmp) {
				close READ_SUMM;
			} elsif (defined $end_lost) {
				unlink $end_lost;
			}
			
			open READ_FINAL, ">>", "$read_final_out_path" or die "cannot write $read_final_out_path: $!";

			for my $read_ID (0 .. $#{$all_info_read_ref}) {
				my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
				my $info_ref = ${$all_info_read_ref}[$read_ID];
				next if exists $read_no_SJ{$read_ID} or !exists ${$info_ref}{'readID'};
				my $out_line = "${$all_info_read_ref}[$read_ID]{'readID'}\tSJ";
				my $out;
				my $read_length = ${$info_ref}{'read_length'};

				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tgroup_ID\t$n\t${n}_$read_ID_update\t${$all_info_read_ref}[$read_ID]{'sample'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tstrand_isoform\t${$info_ref}{'notSameStrand_ori'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tstrand_read\t${$info_ref}{'notSameStrand'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tchr\t${$info_ref}{'chr'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tmapq\t${$info_ref}{'mapq'}\n";
				$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\tflag\t${$info_ref}{'flag'}\n";

				for my $i(0 .. $#{${$info_ref}{'SJcorSeqRef'}}){
					my $j = $i + 1;
					my $SJ_info = ${$info_ref}{'SJcorSeqRef'}[$i];
					my @SJ_cor = split $sep_SJ, ${$SJ_info}[1];
					my $other_dist = $read_length-${$SJ_info}[0];
					$out .= "$out_line\t$j\t${$SJ_info}[1]\t${$SJ_info}[0]\t$other_dist\t";
					if (exists ${$info_ref}{'best_SJ'} and exists ${$info_ref}{'best_SJ'}{${$SJ_info}[1]}){
						my $SJ_info_correct = ${$info_ref}{'best_SJ'}{${$SJ_info}[1]};
						my @SJ_cor_correct = split $sep_SJ, ${$SJ_info_correct}[0];
						if (${$SJ_info_correct}[0] eq ${$SJ_info}[1]) {
							$out .= "pass\t";
							$summary_data_ref->{'number_of_passed_SJ_alignments'} ++;
						} else {
							$out .= "corrected\t";
							$summary_data_ref->{'number_of_corrected_SJ_alignments'} ++;
						}
						my $read_pos_matched_to_sj = ${$SJ_info_correct}[5];
						my @dist_correct = ($read_pos_matched_to_sj, $read_length-$read_pos_matched_to_sj);
						$out .= "${$SJ_info_correct}[0]\t$dist_correct[${$info_ref}{'notSameStrand'}]\t$dist_correct[1-${$info_ref}{'notSameStrand'}]\t${$SJ_info_correct}[1]\t";
						if (defined $hc_SJ{${$SJ_info}[1]}) {
							$out .= "$hc_SJ{${$SJ_info}[1]}[1]\t";
						} else {
							$out .= "no\t";
						}
						
						$out .= "$hc_SJ{${$SJ_info_correct}[0]}[1]\n";

					} else {
						$out .= "fail\tNA\tNA\tNA\tNA\t";
							$summary_data_ref->{'number_of_failed_SJ_alignments'} ++;
						if (defined $hc_SJ{${$SJ_info}[1]}) {
							$out .= "$hc_SJ{${$SJ_info}[1]}[1]\t";
						} else {
							$out .= "no\t";
						}
						$out .= "NA\n";
					}
				}
				my (%unmapped_ends, %mapped_genome_range);
				for my $i ('-1','-2'){
					if (exists ${$info_ref}{$i} and index(${$info_ref}{$i},'TBD')<0 ) {
						my $SJ_info = ${$info_ref}{'additional_SJ'}{$i}{ ${$info_ref}{$i} };
						my @SJ_cor = split $sep_SJ, ${$SJ_info}[0];
						my $i_convert;
						if (${$info_ref}{'notSameStrand'} == 0){
							$i_convert = $i + 1;
						} else {
							$i_convert = 0-2 - $i;
						}
						my $update = $i.'_update';
						$unmapped_ends{$i_convert} = ${$info_ref}{$update}[1];
						$mapped_genome_range{$i_convert} = ${$info_ref}{$update}[0];
						my $read_pos_matched_to_sj = ${$SJ_info}[4];
						my @dist_correct = ($read_pos_matched_to_sj, $read_length-$read_pos_matched_to_sj);
						$out .= "$out_line\t$i_convert\tNA\tNA\tNA\tadded\t${$SJ_info}[0]\t$dist_correct[${$info_ref}{'notSameStrand'}]\t$dist_correct[1-${$info_ref}{'notSameStrand'}]\t${$SJ_info}[1]\tNA\t";
						$out .= "$hc_SJ{${$SJ_info}[0]}[1]\n";
						if ($i == '-1') {
							$summary_data_ref->{'number_of_added_first_SJ_alignments'} ++;
						} else {
							$summary_data_ref->{'number_of_added_last_SJ_alignments'} ++;
						}
					}
				}

				my @unmapped_ends_raw = @{${$info_ref}{'clip_ends'}};
				my @mapped_genome_range_raw = (${$info_ref}{$ends[0]}, ${$info_ref}{$ends[1]});
				my @unmapped_ends_final = @unmapped_ends_raw;

				for my $i (0 .. $#ends){
					$out .= "${$all_info_read_ref}[$read_ID]{'readID'}\t$ends[$i]\tNA\t";
					my $output_raw = "$mapped_genome_range_raw[$i]\t";
					if ($i == 0){
						$output_raw .= $unmapped_ends_raw[0]. "\t". ($read_length-$unmapped_ends_raw[0]). "\t";
					} else {
						$output_raw .= ($read_length-$unmapped_ends_raw[-1]). "\t". $unmapped_ends_raw[-1]. "\t";
					}
					$out .= $output_raw;
					my $output_correct;
					if (exists $mapped_genome_range{0-$i} and $i == 0) {
						if($unmapped_ends{0-$i} <= $directly_approve_length_additional) {
							$out .= "corrected\t";
						}else{
							$out .= "fail3\t";
						}
						$unmapped_ends_final[$i] = $unmapped_ends{'0'};
						$out .= "$mapped_genome_range{'0'}\t$unmapped_ends{'0'}\t". ($read_length-$unmapped_ends{'0'}). "\tNA\tNA\tNA\n";
					} elsif (exists $mapped_genome_range{0-$i}) {
						if($unmapped_ends{0-$i} <= $directly_approve_length_additional) {
							$out .= "corrected\t";
						}else{
							$out .= "fail3\t";
						}
						$unmapped_ends_final[$i] = $unmapped_ends{'-1'};
						$out .= "$mapped_genome_range{'-1'}\t". ($read_length-$unmapped_ends{'-1'}). "\t$unmapped_ends{'-1'}\tNA\tNA\tNA\n";
					} else {
						if($unmapped_ends_raw[0-$i] <= $directly_approve_length_additional) {
							$out .= "pass\t${output_raw}NA\tNA\tNA\n";
						}else{
							$out .= "fail\t${output_raw}NA\tNA\tNA\n";
						}
					}
				}
				$out .= join '', ("${$all_info_read_ref}[$read_ID]{'readID'}\tmapped_length_read\t",$read_length-$unmapped_ends_final[0]-$unmapped_ends_final[1],"\n");
				print READ_FINAL $out;
				$summary_data_ref->{'num_reads_output'} ++;
			}

			close READ_FINAL;
		} else {
			open READ_FINAL, ">>", "$in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt" or die "cannot write $in/$target_ID/all/${thread_ID}_thread_${chr0}_read_final.txt: $!";
			for my $read_ID (0 .. $#{$all_info_read_ref}) {
				next if exists $read_no_SJ{$read_ID};
				my $read_ID_update = ($same_group_count-1)*$proc_num_cutoff+$read_ID;
				my $out = &summary_final_output(${$all_info_read_ref}[$read_ID], $n, $read_ID_update, \%hc_SJ);
				print READ_FINAL $out;
				$summary_data_ref->{'num_reads_output'} ++;
				$summary_data_ref->{'num_reads_missing_blast_output'} ++;
			}
			close READ_FINAL;
    }
	}

	sub process_realign_results_for_read_id {
		my ($all_info_read_ref, $last_read, $SJFS_dist, $SJFS_dist_add, $pre_ID_alignments_ref, $hc_SJ_ref, $confirm_prob_fold_cutoff, $length4nhmmer_max, $lost_end_handle, $sep_end_blast, $SJ_missing_candidate_ref) = @_;

		my $read_info_ref = ${$all_info_read_ref}[$last_read];
		my $read_seq = ${$read_info_ref}{'readSeq'};
		my $read_length = ${$read_info_ref}{'read_length'};
		my $putative_total_all = ${$read_info_ref}{'totalNumBg'}+$SJFS_dist*2;
		my @align_sort = sort { ${$a}{'query_start'} <=> ${$b}{'query_start'} or ${$a}{'query_end'}  <=> ${$b}{'query_end'}  } @{$pre_ID_alignments_ref};
		my $best_SJ_ref = &reliable_SJ_from_realign(\@align_sort, ${$read_info_ref}{'SJcorSeqRef'}, ${$read_info_ref}{'IDS_SJ_ref'}, ${$read_info_ref}{'notSameStrand'}, $read_length, $SJFS_dist*2, $putative_total_all, ${$read_info_ref}{'clip_ends'}, [${$read_info_ref}{'insNumBg'}, ${$read_info_ref}{'delNumBg'}, ${$read_info_ref}{'substNumBg'}], $hc_SJ_ref);
		print READ_SUMM "$last_read\t",scalar(@align_sort),"\t$read_length\n";

		${$read_info_ref}{'notSameStrand_ori'} = ${$best_SJ_ref}[2];
		if (${$best_SJ_ref}[2] eq '0' or ${$best_SJ_ref}[2] eq '1') {
			print READ_SUMM "best_SJ: @{$_}\n" for values %{${$best_SJ_ref}[0]};
			${$read_info_ref}{'best_SJ'} = ${$best_SJ_ref}[0];
			${$read_info_ref}{'additional_SJ'} = ${$best_SJ_ref}[1];

			my %isoform_candidates;
			while(my ($pos, $type_ref) = each %{${$best_SJ_ref}[1]}) {
				my @sort_SJ_add = sort {(${$type_ref}{$b}[1] <=> ${$type_ref}{$a}[1]) or (${$type_ref}{$b}[0] cmp ${$type_ref}{$a}[0])} keys %{$type_ref};

				for my $i (0 .. $#sort_SJ_add) {
					if ( ${$type_ref}{$sort_SJ_add[$i]}[1]*$confirm_prob_fold_cutoff >= ${$type_ref}{$sort_SJ_add[$i-1]}[1] ){
						my $SJ2 = $sort_SJ_add[$i];
						my $SJ2_ref = ${$type_ref}{$SJ2};
						# $junction_pos is a 0-based offset in the read sequence.
						# It's the last base of the exon
						my $junction_pos = ${$SJ2_ref}[4] - 1;
						if ( $pos eq "-1" ) {
							my $substr_start = $junction_pos - ($length4nhmmer_max - 1);
							$substr_start = &max($substr_start, 0);
							my $substr_end = $junction_pos + $SJFS_dist + $SJFS_dist_add;
							$substr_end = &min($substr_end, $read_length - 1);
							my $substr_length = ($substr_end - $substr_start) + 1;
							my $seq4hmmmer = substr($read_seq, $substr_start, $substr_length);
							my $extra_length = $substr_end - $junction_pos;
							my $length_before_sj = $junction_pos + 1;
							print $lost_end_handle ">${last_read}$sep_end_blast$SJ2$sep_end_blast-1$sep_end_blast${$read_info_ref}{'notSameStrand'}$sep_end_blast", $substr_length, "$sep_end_blast$extra_length$sep_end_blast$length_before_sj\n$seq4hmmmer\n";
							$SJ_missing_candidate_ref->{$SJ2}{0-${$read_info_ref}{'notSameStrand'}}{$last_read} = $junction_pos;
						} else {
							my $substr_end = $junction_pos + $length4nhmmer_max;
							$substr_end = &min($substr_end, $read_length - 1);
							my $substr_start = $junction_pos - ($SJFS_dist + $SJFS_dist_add - 1);
							$substr_start = &max($substr_start, 0);
							my $substr_length = ($substr_end - $substr_start) + 1;
							my $seq4hmmmer = substr($read_seq, $substr_start, $substr_length);
							my $extra_length = ($junction_pos - $substr_start) + 1;
							my $length_after_sj = ($read_length - $junction_pos) - 1;
							print $lost_end_handle ">${last_read}$sep_end_blast$SJ2$sep_end_blast-2$sep_end_blast${$read_info_ref}{'notSameStrand'}$sep_end_blast", $substr_length, "$sep_end_blast$extra_length$sep_end_blast", $length_after_sj, "\n$seq4hmmmer\n";
							$SJ_missing_candidate_ref->{$SJ2}{${$read_info_ref}{'notSameStrand'}-1}{$last_read} = $length_after_sj;
							${$read_info_ref}{'read_SJ_missing'}{${$read_info_ref}{'notSameStrand'}-1}{$SJ2} = $length_after_sj + $extra_length;
						}
					}
				}
			}
		}
	}


	sub reliable_SJ_from_realign {
		my @sorted_2ends = @{$_[0]}; 
		my @detected_SJ = @{$_[1]}; 
		my @IDS_original = @{$_[2]};
		my ($notSameStrand,$read_length,$sub_total,$putative_total_all, $clip_ends_ref, $IDS_total_pre_ref, $all_candidate_ref) = ($_[3],$_[4],$_[5],$_[6],$_[7],$_[8],$_[9]);
		my @best_SJ;
		my %detected_SJ_pos;
		my @clip_ends;

		if ($notSameStrand == 1) {
			%detected_SJ_pos = map {${$detected_SJ[$_]}[1] => [$read_length-${$detected_SJ[$_]}[0], ${$detected_SJ[$_]}[2], $_, $IDS_original[$_]]} (0 .. $#detected_SJ);
			@clip_ends = reverse(@{$clip_ends_ref});
		} else {
			%detected_SJ_pos = map {${$detected_SJ[$_]}[1] => [${$detected_SJ[$_]}[0], ${$detected_SJ[$_]}[2], $_, $IDS_original[$_]]} (0 .. $#detected_SJ);
			@clip_ends = @{$clip_ends_ref};
		}

		my @sorted_2ends_remove0;

		for my $read_info(@sorted_2ends) {
			my @IDS_total = map { ${$IDS_total_pre_ref}[$_]+${$read_info}{'IDM'}[$_] } (0 .. $#{$IDS_total_pre_ref});
			my $sub_total_ins = $sub_total+${$read_info}{'IDM'}[0];
			my $prob_hyperg_IDS = &calculate_probability_hypergeometric_IDS( ${$read_info}{'IDM'},\@IDS_total,$sub_total_ins,$putative_total_all+${$read_info}{'IDM'}[0] ); #,$combination_all

			print READ_SUMM "${$read_info}{$_}\t" for ('query_start', 'query_end', 'subject_start','subject_end','SJ_ID');
			print READ_SUMM "${$read_info}{$_}[0]\t${$read_info}{$_}[1]\t" for ('query_ori', 'subject_ori');
			print READ_SUMM "$_," for @{${$read_info}{'IDM'}};
			print READ_SUMM "\t$sub_total_ins\t", $putative_total_all+${$read_info}{'IDM'}[0], "\t";
			print READ_SUMM "$_," for @IDS_total;
			print READ_SUMM "\t$prob_hyperg_IDS\t";
			${$read_info}{'prob_hyperg'} = $prob_hyperg_IDS;
			my ($chr, $start,$end,$notSameStrand_SJ) = split $sep_SJ, ${$read_info}{'SJ_ID'};
			${$read_info}{'notSameStrand_SJ'} = $notSameStrand_SJ;
			print READ_SUMM "\t$notSameStrand_SJ\n";
			push @sorted_2ends_remove0, $read_info;
		}

		my (%candidate_SJ_group);
		my (%corrected_SJ_pos, %additional_SJ);
		my %candidate_strand_prob_product = ('0'=>1, '1'=>1);

		my %mapper_SJ_IDM_prob_hyperg;

		while(my ($SJ, $SJ_info_ref) = each %detected_SJ_pos) {
			my @SJ_loci = split $sep_SJ, $SJ;
			my $tag = 0;
			if (exists ${$all_candidate_ref}{$SJ}){
				$tag ++;
				my @IDS_total = map { ${$IDS_total_pre_ref}[$_]+${$SJ_info_ref}[3][$_] } (0 .. $#{$IDS_total_pre_ref});
				my $sub_total_ins = $sub_total+${$SJ_info_ref}[3][0];
				my $prob_hyperg_IDS = &calculate_probability_hypergeometric_IDS( ${$SJ_info_ref}[3],\@IDS_total,$sub_total_ins,$putative_total_all+${$SJ_info_ref}[3][0] ); 
				$mapper_SJ_IDM_prob_hyperg{$SJ} = $prob_hyperg_IDS;
				print READ_SUMM "mapper: $SJ\t";
				print READ_SUMM "$_," for @{${$SJ_info_ref}[3]};
				print READ_SUMM "\t$sub_total_ins\t", $putative_total_all+${$SJ_info_ref}[3][0], "\t";
				print READ_SUMM "$_," for @IDS_total;
				print READ_SUMM "\t$prob_hyperg_IDS\n";
			} else {
				print READ_SUMM "mapper: $SJ(not HC)\n";
			}
			
			my %candidate_SJ_strand;
			for my $align_ref (@sorted_2ends_remove0) {
				my @SJ_novel_loci = split $sep_SJ, ${$align_ref}{'SJ_ID'};

				if (${$align_ref}{'query_start'}-1-($SJFS_dist+$SJFS_dist_add) < ${$SJ_info_ref}[0] and ${$align_ref}{'query_end'}+$SJFS_dist+$SJFS_dist_add > ${$SJ_info_ref}[0] and abs($SJ_novel_loci[1]-$SJ_loci[1])<=$SJFS_dist+$SJFS_dist_add and abs($SJ_novel_loci[2]-$SJ_loci[2])<=$SJFS_dist+$SJFS_dist_add) {
					print READ_SUMM ${$align_ref}{'SJ_ID'},"(under consideration)\n";
					if ($SJ eq ${$align_ref}{'SJ_ID'} and exists $mapper_SJ_IDM_prob_hyperg{$SJ}) {
						$tag ++;
						if (${$align_ref}{'prob_hyperg'} < $mapper_SJ_IDM_prob_hyperg{$SJ}){
							print READ_SUMM "use_orig_align: $SJ\t$mapper_SJ_IDM_prob_hyperg{$SJ} > ${$align_ref}{'prob_hyperg'}\n";
							${$align_ref}{'prob_hyperg'} = $mapper_SJ_IDM_prob_hyperg{$SJ};
							${$align_ref}{'IDM'} = $detected_SJ_pos{$SJ}[3];
							${$align_ref}{'notSameStrand_SJ'} = $SJ_loci[-1];
						} else {
							$mapper_SJ_IDM_prob_hyperg{$SJ} = ${$align_ref}{'prob_hyperg'};
						}
					}

					if (${$align_ref}{'notSameStrand_SJ'} ne 'x') {
						push @{$candidate_SJ_group{${$align_ref}{'notSameStrand_SJ'}}{$SJ}}, $align_ref;
						$candidate_SJ_strand{${$align_ref}{'notSameStrand_SJ'}} += ${$align_ref}{'prob_hyperg'};
					} else {
						push @{$candidate_SJ_group{'0'}{$SJ}}, $align_ref;
						push @{$candidate_SJ_group{'1'}{$SJ}}, $align_ref;
						$candidate_SJ_strand{'0'} += ${$align_ref}{'prob_hyperg'};
						$candidate_SJ_strand{'1'} += ${$align_ref}{'prob_hyperg'};
					}
					
				}
			}
			if ($tag == 1) {
				if ($SJ_loci[-1] ne 'x') {
					push @{$candidate_SJ_group{$SJ_loci[-1]}{$SJ}}, { 'prob_hyperg' => $mapper_SJ_IDM_prob_hyperg{$SJ}, 'IDM' => $detected_SJ_pos{$SJ}[3], 'SJ_ID' => $SJ, 'notSameStrand_SJ' => $SJ_loci[-1] };
					$candidate_SJ_strand{$SJ_loci[-1]} += $mapper_SJ_IDM_prob_hyperg{$SJ};
				} else {
					push @{$candidate_SJ_group{'0'}{$SJ}}, { 'prob_hyperg' => $mapper_SJ_IDM_prob_hyperg{$SJ}, 'IDM' => $detected_SJ_pos{$SJ}[3], 'SJ_ID' => $SJ, 'notSameStrand_SJ' => '0' };
					push @{$candidate_SJ_group{'1'}{$SJ}}, { 'prob_hyperg' => $mapper_SJ_IDM_prob_hyperg{$SJ}, 'IDM' => $detected_SJ_pos{$SJ}[3], 'SJ_ID' => $SJ, 'notSameStrand_SJ' => '1' };
					$candidate_SJ_strand{'0'} += $mapper_SJ_IDM_prob_hyperg{$SJ};
					$candidate_SJ_strand{'1'} += $mapper_SJ_IDM_prob_hyperg{$SJ};
				}
				
				
			}
			next if !exists $candidate_SJ_strand{'1'} and !exists $candidate_SJ_strand{'0'};
			for my $x ('0', '1'){
				if (exists $candidate_strand_prob_product{$x}){
					$candidate_strand_prob_product{$x} *= $candidate_SJ_strand{$x};
				} else {
					$candidate_strand_prob_product{$x} = 0;
				}
			}
		}
		my $notSameStrand_ori;
		if ($is_stranded == 1){
			$notSameStrand_ori = $notSameStrand;
		} elsif ($candidate_strand_prob_product{'0'} >= $confirm_prob_fold_cutoff*$candidate_strand_prob_product{'1'}) {
			$notSameStrand_ori = 0;
			print READ_SUMM "strand is 0\n";
		} elsif ($candidate_strand_prob_product{'1'} >= $confirm_prob_fold_cutoff*$candidate_strand_prob_product{'0'}) {
			$notSameStrand_ori = 1;
			print READ_SUMM "strand is 1\n";
		} else {
			print READ_SUMM "strand not known!\n";
			return ['NA','NA','unknown'];
		}

		while(my ($SJ, $SJ_info_ref) = each %detected_SJ_pos) {
			my @SJ_loci = split $sep_SJ, $SJ;
			if (exists $candidate_SJ_group{$notSameStrand_ori}{$SJ}) {
				my @sort_score = sort {${$b}{'prob_hyperg'} <=> ${$a}{'prob_hyperg'}} @{$candidate_SJ_group{$notSameStrand_ori}{$SJ}};
				my $est_pos_read;
				my $read_pos_matched_to_sj;
				if (exists $sort_score[0]{'query_start'}){
					# ensure the estimated read position is an integer
					$est_pos_read = int(($sort_score[0]{'query_start'} + $sort_score[0]{'query_end'}) / 2);
					$read_pos_matched_to_sj = $sort_score[0]{'query_sj_pos'};
				}
				$candidate_SJ_group{$notSameStrand_ori}{$SJ} = \@sort_score;
				if (exists ${$all_candidate_ref}{$SJ} and ($notSameStrand_ori eq $SJ_loci[-1] or $SJ_loci[-1] eq 'x') and $mapper_SJ_IDM_prob_hyperg{$SJ} > $sort_score[0]{'prob_hyperg'}*$additional_candidate_prob_fold_cutoff) { #${$SJ_info_ref}[1] > 0 or >=
					$est_pos_read = ${$SJ_info_ref}[0];
					$read_pos_matched_to_sj = $est_pos_read;
					$corrected_SJ_pos{$SJ} = [$SJ, $mapper_SJ_IDM_prob_hyperg{$SJ}, $est_pos_read, ${$SJ_info_ref}[1], ${$SJ_info_ref}[2], $read_pos_matched_to_sj];
					print READ_SUMM "perfect_SJ_confirmed: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $SJ, $mapper_SJ_IDM_prob_hyperg{$SJ}, ", ${$SJ_info_ref}[0], "\n";
				} elsif (@sort_score >= 2 and $sort_score[0]{'prob_hyperg'} >= $confirm_prob_fold_cutoff*$sort_score[1]{'prob_hyperg'}) { #### change to larger than 0.9*all_probability 

					$corrected_SJ_pos{$SJ} = [$sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, $est_pos_read, 0, ${$SJ_info_ref}[2], $read_pos_matched_to_sj];
					print READ_SUMM "corrected_SJ_confirmed: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, ", $est_pos_read, "\n";
				} elsif (@sort_score == 1 and $sort_score[0]{'SJ_ID'} ne $SJ) {
					$corrected_SJ_pos{$SJ} = [$sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, $est_pos_read, 1, ${$SJ_info_ref}[2], $read_pos_matched_to_sj];
					print READ_SUMM "corrected_SJ_only_choice: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, ", $est_pos_read, "\n";
				} else {
					print READ_SUMM "undetermined_multiple_choice: $SJ, ${$SJ_info_ref}[0], ${$SJ_info_ref}[1]: $sort_score[0]{'SJ_ID'}, $sort_score[0]{'prob_hyperg'}, ", $est_pos_read, "\n";
				}
			} else {
				print READ_SUMM "no alignment for $SJ(${$SJ_info_ref}[0], ${$SJ_info_ref}[1])!!!\n";
			}
		}

		if (scalar(keys %corrected_SJ_pos) >= 1) {
			my $sum = 0;
			$sum += ${$_}[1] for values %corrected_SJ_pos;
			my $ave = $sum/scalar(keys %corrected_SJ_pos);
			my @sort_prob_SJ = sort {${$a}[1] <=> ${$b}[1]} values %corrected_SJ_pos;
			my $min = ${$sort_prob_SJ[0]}[1];
			my @uncorrected_SJ = grep {!exists $corrected_SJ_pos{${$_}[1]}} @detected_SJ;
			if(@uncorrected_SJ>0){
				print READ_SUMM "uncorrected:";
				print READ_SUMM "\t${$_}[1]" for @uncorrected_SJ;
				print READ_SUMM "\n";
			}
			for my $SJ_info (@uncorrected_SJ) {
				my $SJ = ${$SJ_info}[1];
				my $first_candidate_ref = $candidate_SJ_group{$notSameStrand_ori}{$SJ}[0];
				my @SJ_novel_loci = split $sep_SJ, ${$first_candidate_ref}{'SJ_ID'};
				my @SJ_loci = split $sep_SJ, $SJ;
				if (${$first_candidate_ref}{'prob_hyperg'} >= $ave and abs($SJ_novel_loci[1]-$SJ_loci[1])<=$correct_suggest_SJ_distance_max and abs($SJ_novel_loci[2]-$SJ_loci[2])<=$correct_suggest_SJ_distance_max){
					my $est_pos_read;
					my $read_pos_matched_to_sj;
					if (exists ${$first_candidate_ref}{'query_start'}){
						$est_pos_read = int((${$first_candidate_ref}{'query_start'} + ${$first_candidate_ref}{'query_end'}) / 2);
						$read_pos_matched_to_sj = ${$first_candidate_ref}{'query_sj_pos'};
					} elsif ($SJ eq ${$first_candidate_ref}{'SJ_ID'}) {
						$est_pos_read = $detected_SJ_pos{$SJ}[0];
						$read_pos_matched_to_sj = $est_pos_read;
					} else {
						die "$SJ ne ${$first_candidate_ref}{'SJ_ID'}!!";
					}
					$corrected_SJ_pos{$SJ} = [${$first_candidate_ref}{'SJ_ID'}, ${$first_candidate_ref}{'prob_hyperg'}, $est_pos_read, 0, undef, $read_pos_matched_to_sj];
					print READ_SUMM "!!!added_middle ${$first_candidate_ref}{'SJ_ID'}, ${$first_candidate_ref}{'prob_hyperg'}, ", $est_pos_read, "\n";
				}
			}
			my $pre_first_SJ_read = $detected_SJ[0-$notSameStrand];
			my $pre_last_SJ_read = $detected_SJ[$notSameStrand-1];
			my @SJ_loci_first = split $sep_SJ, ${$pre_first_SJ_read}[1];
			my @SJ_loci_last = split $sep_SJ, ${$pre_last_SJ_read}[1];

			my ($SJ_pos_pre_first, $SJ_pos_pre_last);
			if (exists $corrected_SJ_pos{${$pre_first_SJ_read}[1]}) {
				$SJ_pos_pre_first = $corrected_SJ_pos{${$pre_first_SJ_read}[1]}[2];
			} else {
				$SJ_pos_pre_first = $detected_SJ_pos{${$pre_first_SJ_read}[1]}[0];
			}
			if (exists $corrected_SJ_pos{${$pre_last_SJ_read}[1]}) {
				$SJ_pos_pre_last = $corrected_SJ_pos{${$pre_last_SJ_read}[1]}[2];
			} else {
				$SJ_pos_pre_last = $detected_SJ_pos{${$pre_last_SJ_read}[1]}[0];
			}
			print READ_SUMM "$min\t$ave\t$clip_ends[0]\t$clip_ends[1]\n";

			for my $align_ref (@sorted_2ends_remove0) {

				my $amb_read_pos = int((${$align_ref}{'query_start'} + ${$align_ref}{'query_end'}) / 2);
				my $read_pos_matched_to_sj = ${$align_ref}{'query_sj_pos'};
				my @SJ_loci = split $sep_SJ, ${$align_ref}{'SJ_ID'};

				my $align_ref_length_half;
				print READ_SUMM "-1\t${$align_ref}{'SJ_ID'}\t$SJ_pos_pre_first\t$amb_read_pos\t",$SJ_loci_first[$notSameStrand+1],"\t", $SJ_loci[2-$notSameStrand], "\n" if ${$align_ref}{'query_end'} < $SJ_pos_pre_first;
				print READ_SUMM "-2\t${$align_ref}{'SJ_ID'}\t$SJ_pos_pre_last\t$amb_read_pos\t",$SJ_loci_last[2-$notSameStrand], "\t", $SJ_loci[$notSameStrand+1],"\n" if ${$align_ref}{'query_start'}-1 > $SJ_pos_pre_last;
				if ( (${$align_ref}{'notSameStrand_SJ'} eq $notSameStrand_ori or ${$align_ref}{'notSameStrand_SJ'} eq 'x') and ${$align_ref}{'query_end'} < $SJ_pos_pre_first and abs($amb_read_pos-$clip_ends[0]) <= $first_exon_diff_cutoff and ($SJ_loci_first[$notSameStrand+1]-$SJ_loci[2-$notSameStrand])*(0.5-$notSameStrand) > 0 and ($SJ_loci_first[$notSameStrand+1]-$SJ_loci[2-$notSameStrand])*(0.5-$notSameStrand)*2*$second_exon_align_length_ratio_cutoff < ($SJ_pos_pre_first-$amb_read_pos) and ($SJ_loci_first[$notSameStrand+1]-$SJ_loci[2-$notSameStrand])*(0.5-$notSameStrand)*2 > ($SJ_pos_pre_first-$amb_read_pos)*$second_exon_align_length_ratio_cutoff and ${$align_ref}{'prob_hyperg'} >= $min*$additional_candidate_prob_fold_cutoff ) { #and ${$align_ref}{'prob_hyperg'} >= $ave
					$additional_SJ{'-1'}{${$align_ref}{'SJ_ID'}} = [${$align_ref}{'SJ_ID'},${$align_ref}{'prob_hyperg'},$amb_read_pos,-1, $read_pos_matched_to_sj];
					print READ_SUMM "!!!added_first ${$align_ref}{'SJ_ID'}, ${$align_ref}{'prob_hyperg'}, ", $amb_read_pos, "\n";
				} elsif ( (${$align_ref}{'notSameStrand_SJ'} eq $notSameStrand_ori or ${$align_ref}{'notSameStrand_SJ'} eq 'x') and ${$align_ref}{'query_start'}-1 > $SJ_pos_pre_last and abs($read_length-$amb_read_pos-$clip_ends[1]) <= $first_exon_diff_cutoff and ($SJ_loci[$notSameStrand+1]-$SJ_loci_last[2-$notSameStrand])*(0.5-$notSameStrand) > 0 and ($SJ_loci[$notSameStrand+1]-$SJ_loci_last[2-$notSameStrand])*(0.5-$notSameStrand)*2*$second_exon_align_length_ratio_cutoff < ($amb_read_pos-$SJ_pos_pre_last) and ($SJ_loci[$notSameStrand+1]-$SJ_loci_last[2-$notSameStrand])*(0.5-$notSameStrand)*2 > ($amb_read_pos-$SJ_pos_pre_last)*$second_exon_align_length_ratio_cutoff and ${$align_ref}{'prob_hyperg'} >= $min*$additional_candidate_prob_fold_cutoff ){ # and ${$align_ref}{'prob_hyperg'} >= $ave
					$additional_SJ{'-2'}{${$align_ref}{'SJ_ID'}} = [${$align_ref}{'SJ_ID'},${$align_ref}{'prob_hyperg'},$amb_read_pos,-2, $read_pos_matched_to_sj];
					print READ_SUMM "!!!added_last ${$align_ref}{'SJ_ID'}, ${$align_ref}{'prob_hyperg'}, ", $amb_read_pos, "\n";
				}
			}
			for my $type ('-1', '-2') {
				if (exists $additional_SJ{$type}) {
					if (scalar(keys %{$additional_SJ{$type}}) >= 2) {
						my @additiona_SJ_sort = sort { ${$b}[1] <=> ${$a}[1] } values %{$additional_SJ{$type}};
						if (${$additiona_SJ_sort[0]}[1] >= ${$additiona_SJ_sort[1]}[1]*$confirm_prob_fold_cutoff) {
							delete $additional_SJ{$type}{$additiona_SJ_sort[$_]} for (1 .. $#additiona_SJ_sort);
						}
					}
				}
			}
		}

		[\%corrected_SJ_pos,\%additional_SJ, $notSameStrand_ori];
	}

	sub split_sam_file {
		my ($in, $n, $out, $met) = @_;
		my (%split_files_key_read,$in_raw);
		if (rindex($in, "/")>=0) {
			$in_raw = (substr($in, rindex($in, "/")+1));
		} else {
			$in_raw = $in;
		}
		if ($n >= 2) {
			my $input_dir = $out.'/';
			my $size = -s $in;
			if($size < 1_001){
				print "Fail to get file size for $in.\nFatal error. Aborted.\n";
				die "Fail to get file size for $in: $!";
			}
			my $division;
			if ($size%$n != 0) {
				$division = int($size/$n)+1;
			} else {
				$division = int($size/$n);
			}
			if(!defined($division) or $division < 0.01*$size){
				print "Fail to calculate divided file size, total file size $size, thread $n.\nFatal error. Aborted.\n";
				die "Fail to calculate divided file size, total file size $size, thread $n: $!";
			}
			system "split -b $division $in $input_dir$in_raw";
			if ($met eq 'category') {
				my $division2 = int($division/2)+1;
				system "split -b $division2 $input_dir${in_raw}aa $input_dir${in_raw}aa";
				unlink "$input_dir${in_raw}aa";
				system "split -b $division2 $input_dir${in_raw}ab $input_dir${in_raw}ab";
				unlink "$input_dir${in_raw}ab";
			}
			my @split_sam = <$input_dir$in_raw*>;
			my @split_files;
			print " Divided SAM(LIST) sizes:\n";
			my $n2 = 0;
			for my $sam (@split_sam) {
				if ($sam=~/$in_raw[a-z]+$/){
					$n2 ++;
					if (rindex($sam, "/")>=0) {
						my $file = (substr($sam, rindex($sam, "/")+1));
						printf " $file\t%15d\n", (-s $sam);
						push @split_files, $file;
					} else {
						die "error for $sam: -1";
					}
				}
			}
			if ( ($n2 == $n and $met eq 'group') ){
				print " SAM(LIST) was divided successfully.\n" ;
			} elsif ($met eq 'group') {
				print "Cannot split $in into $n ($n2) pieces with size of $division and named them as $input_dir$in_raw.\nFatal error. Aborted.\n";
				die "Cannot split $in into $n ($n2) pieces with size of $division and named them as $input_dir$in_raw: $!";
			}
			if ( ($n2 == $n+2 and $met eq 'category') ){
				print " SAMLIST was divided successfully.\n" ;
			} elsif ($met eq 'category') {
				print "Cannot split $in into ", $n+2, " ($n2) pieces with size of $division and named them as $input_dir$in_raw.\nFatal error. Aborted.\n";
				die "Cannot split $in into ", $n+2, " ($n2) pieces with size of $division and named them as $input_dir$in_raw: $!";
			}

			print " First group of divided SAM(LIST) files: \n";
			my @split_files_sort = sort{$b cmp $a} @split_files;
			for my $i (0 .. $#split_files_sort-1) {
				my (%read_name, @add_reads, $line_num);
				open FILE, "<", $input_dir.$split_files_sort[$i] or die "cannot open $input_dir$split_files_sort[$i]: $!";
				while (<FILE>) {
					chomp;
					$line_num ++;
					my @line = split /\t/;

					if(($met eq 'category') or ($met eq 'group' and $line_num >= 2)) {
						$read_name{$line[0]} ++;
					}
					if ( scalar(keys %read_name)>=2 ) {
						$split_files_key_read{$split_files_sort[$i]} = $line[0];
						print " $split_files_sort[$i]: $line[0]\n" ;
						open OUTPUT, ">>", $input_dir.$split_files_sort[$i+1] or die;
						print OUTPUT "$_\n" for @add_reads;
						close OUTPUT;
						@add_reads = ();
						last;
					} else {
						push @add_reads, $_;
					}
				}
				if (@add_reads > 0) {
					open OUTPUT, ">>", $input_dir.$split_files_sort[$i+1] or die;
					print OUTPUT "$_\n" for @add_reads;
					close OUTPUT;
					unlink "$input_dir$split_files_sort[$i]";
					@add_reads = ();
				}
			}
			open FILE, "<", $input_dir.$split_files_sort[-1] or die "cannot open $input_dir$split_files_sort[-1]: $!";
			while (<FILE>) {
				chomp;
				my @line = split /\t/;
				unless (/^[@]/) {
					$split_files_key_read{$split_files_sort[-1]} = $line[0];
					print " $split_files_sort[-1]: $line[0]\n" ;
					last;
				}
			}
			if (keys %split_files_key_read == $n2) {
				print " First reads were recorded successfully for all $n2 files.\n" 
			} elsif (keys %split_files_key_read >= 1) {
				print " First reads were recorded successfully for ", scalar (keys %split_files_key_read), " files.\n";

			} else {
				print "Fail to record first reads for $n2 pieces of SAM.\nFatal error. Aborted.\n";
				die "Fail to record first reads for $n2 pieces of SAM: $!";
			}
		} else {
			die "Please select at least 2 threads to parse SAM!";
		}
		\%split_files_key_read;

	}

	sub ID_align_btop {
		my ($btop, $query_2ends_ref, $sbjct_2ends_ref, $sbjct_ID) = @_;
		my ($loci_query, $loci_sbjct) = (${$query_2ends_ref}[0], ${$sbjct_2ends_ref}[0]);
		my ($loci_sbjct_min, $loci_sbjct_max) = ($SJFS_dist_add+1, $SJFS_dist*2+$SJFS_dist_add);
		my $loci_sbjct_sj = $SJFS_dist_add + $SJFS_dist;
		my $inc = 1;
		if (${$sbjct_2ends_ref}[0] > ${$sbjct_2ends_ref}[1]) {
			$inc = -1;
		}

		my @matches = split /\D+/, $btop;
		my @mismatches_raw = split /\d+/, $btop;
		shift @mismatches_raw;

		my %IDM_sbjct;
		my %start_end_match;
		my $query_sj_pos = undef;
		my $query_sj_pos_default = $loci_query;

		for my $i (0 .. $#matches) {
			for my $j (1 .. $matches[$i]) {
				if ($loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max){
					$start_end_match{$loci_sbjct} = $loci_query;
				}
				if ($inc == 1) {
					# Record the last position that matched in the exon before the SJ
					if ($loci_sbjct <= $loci_sbjct_sj) {
						$query_sj_pos = $loci_query;
					}
				} else {
					# Since working backwards, only set $query_sj_pos on the 1st match found before the SJ
					if ((not defined $query_sj_pos) and ($loci_sbjct <= $loci_sbjct_sj)) {
						$query_sj_pos = $loci_query;
					}
				}
				$loci_sbjct += $inc;
				$loci_query ++;
			}

			if (defined $mismatches_raw[$i]) {
				my @mismatches_current = split '', $mismatches_raw[$i];
				for my $j (0 .. ($#mismatches_current-1)/2) {
					my ($mismatch_query, $mismatch_sbjct) = ($mismatches_current[2*$j], $mismatches_current[2*$j+1]);
					if ($mismatch_sbjct eq '-') {
						if ($loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max) {
							push @{$IDM_sbjct{'D'}{$loci_sbjct}}, $loci_query;
						}
						$loci_query ++;
					} else {
						if ($mismatch_query eq '-') {
							$IDM_sbjct{'I'}{$loci_sbjct} = $loci_query if $loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max;
						} else {
							$IDM_sbjct{'M'}{$loci_sbjct} = $loci_query if $loci_sbjct >= $loci_sbjct_min and $loci_sbjct <= $loci_sbjct_max;
							$loci_query ++;
						}
						$loci_sbjct += $inc;
					}
				}
			}
		}

		my $delete_num = 0;
		$delete_num += scalar (@{$IDM_sbjct{'D'}{$_}}) for keys %{$IDM_sbjct{'D'}};
		if (not defined $query_sj_pos) {
			$query_sj_pos = $query_sj_pos_default;
		}
		my @sort_match_loci_sbjct = sort {$a*$inc <=> $b*$inc} keys %start_end_match;

		{
			'query_start' => $start_end_match{$sort_match_loci_sbjct[0]},
			'query_end' => $start_end_match{$sort_match_loci_sbjct[-1]},
			'query_ori' => [${$query_2ends_ref}[0],${$query_2ends_ref}[1]],
			'query_sj_pos' => $query_sj_pos,
			'subject_start' => $sort_match_loci_sbjct[0],
			'subject_end' => $sort_match_loci_sbjct[-1],
			'subject_ori' => [${$sbjct_2ends_ref}[0],${$sbjct_2ends_ref}[1]],
			'SJ_ID' => $sbjct_ID,
			'IDM' => [$delete_num, scalar(keys %{$IDM_sbjct{'I'}}), scalar(keys %{$IDM_sbjct{'M'}})]
		};
	}

	sub process_alignment_details {
		my ($cigar_ref, $read_start, $read_end, $sj_start, $sj_end, $sj_id) = @_;
		my ($loci_query, $loci_sbjct) = ($read_start, $sj_start);
		my ($loci_sbjct_min, $loci_sbjct_max) = ($SJFS_dist_add+1, $SJFS_dist*2+$SJFS_dist_add);
		my $loci_sbjct_sj = $SJFS_dist_add + $SJFS_dist;

		my $delete_num = 0;
		my $insert_num = 0;
		my $mismatch_num = 0;
		my %start_end_match;
		my $query_sj_pos = undef;
		my $query_sj_pos_default = $loci_query;

		my $cigar_len = scalar(@{$cigar_ref});
		for my $cigar_i (0 .. ($cigar_len - 1)) {
			my $cigar_num = $cigar_ref->[$cigar_i][0];
			my $cigar_op = $cigar_ref->[$cigar_i][1];
			for (1 .. $cigar_num) {
				my $sbjct_in_sj = ($loci_sbjct_min <= $loci_sbjct and $loci_sbjct <= $loci_sbjct_max);
				if ($cigar_op eq '=') {
					if ($sbjct_in_sj) {
						$start_end_match{$loci_sbjct} = $loci_query;
					}
					# Record the last position that matched in the exon before the SJ
					if ($loci_sbjct <= $loci_sbjct_sj) {
						$query_sj_pos = $loci_query;
					}
					$loci_sbjct ++;
					$loci_query ++;
				} elsif ($cigar_op eq 'X') {
					if ($sbjct_in_sj) {
						$mismatch_num ++;
					}
					$loci_sbjct ++;
					$loci_query ++;
				} elsif ($cigar_op eq 'I') {
					if ($sbjct_in_sj) {
						$delete_num ++;
					}
					$loci_query ++;
				} elsif ($cigar_op eq 'D') {
					if ($sbjct_in_sj) {
						$insert_num ++;
					}
					$loci_sbjct ++;
				} elsif (($cigar_op eq 'S') or ($cigar_op eq 'H')) {
					$loci_query ++;
				} else {
					# M,N,P
					die "unexpected CIGAR operation $cigar_op for $sj_id";
				}
			}
		}

		if (not defined $query_sj_pos) {
			$query_sj_pos = $query_sj_pos_default;
		}
		my @sort_match_loci_sbjct = sort {$a <=> $b} keys %start_end_match;

		my %alignment_details = ();
		$alignment_details{'query_start'} = $start_end_match{$sort_match_loci_sbjct[0]};
		$alignment_details{'query_end'} = $start_end_match{$sort_match_loci_sbjct[-1]};
		$alignment_details{'query_ori'} = [$read_start, $read_end];
		$alignment_details{'query_sj_pos'} = $query_sj_pos;
		$alignment_details{'subject_start'} = $sort_match_loci_sbjct[0];
		$alignment_details{'subject_end'} = $sort_match_loci_sbjct[-1];
		$alignment_details{'subject_ori'} = [$sj_start, $sj_end];
		$alignment_details{'SJ_ID'} = $sj_id;
		$alignment_details{'IDM'} = [$delete_num, $insert_num, $mismatch_num];

		return \%alignment_details;
	}

	sub calculate_probability_hypergeometric_IDS {
		my @IDSM = @{$_[0]};
		my @IDSM_all = @{$_[1]};
		my ($IDSM_total, $IDSM_all_total) = ($_[2], $_[3]);
		
		my $combination_all = &combination($IDSM_all_total, $IDSM_total);
		my $prob = 1;
		for my $i (0 .. $#IDSM_all){
			$prob *= &combination($IDSM_all[$i], $IDSM[$i]);
			$IDSM_total -= $IDSM[$i];
			$IDSM_all_total -= $IDSM_all[$i];
		}
		$prob *= &combination($IDSM_all_total, $IDSM_total);
		$prob /= $combination_all;
		$prob;
	}

	sub combination {
		my ($r, $n, $k) = (1, @_);
		$k = $n-$k if $k > $n/2;
		for (1 .. $k) { $r *= $n--; $r /= $_ }
		$r;
	}

	sub comp_rev {
		my $seq = reverse($_[0]);
		$seq =~ tr/ATCG/TAGC/;
		$seq;
	}

	sub ten2b {
		my $b_string = sprintf("%b", $_[0]);
		if ($_[1] <= length($b_string)) {
			substr(reverse($b_string), $_[1]-1, 1);
		} else {
			0;
		}
	}

	sub min {
		if ($_[0] < $_[1]) {
			$_[0];
		} else {
			$_[1];
		}
	}

	sub max {
		if ($_[0] > $_[1]) {
			$_[0];
		} else {
			$_[1];
		}
	}

	sub hamming_distance{ length( $_[0] ) - ( ($_[0] ^ $_[1]) =~ tr[\0][\0] ) };

	sub sort_sj_group_fa_file {
		# Each entry in the original file consists of two lines like:
		# >chr11:15170776:15197286:0 SJclst:0: group:3919:
		# ACTCCGTCACCCTGCCGGGTCAGCGGCTACACCTGATGCAGGTGGACTCA
		#
		# First combine those two lines on a single line with the SJclst
		# value placed at the begining of the line with a space. Then
		# the sort command will use the SJclst value as the sort key.
		# Then restore the original two line format.
		my ($orig_file_path, $tmp_file_path) = @_;
		open(my $tmp_write_handle,  ">", $tmp_file_path) or die "cannot write $tmp_file_path: $!";
		open(my $orig_read_handle,  "<", $orig_file_path) or die "cannot read $orig_file_path: $!";
		my $combined_line;
		my $line_in_combo_i = 1;
		while (my $full_line = <$orig_read_handle>) {
			chomp $full_line;
			if ($line_in_combo_i == 1) {
				$line_in_combo_i = 2;
				my @line_pieces = split(/:/, $full_line);
				my $sj_cluster_index = $line_pieces[4];
				$combined_line = "$sj_cluster_index " . $full_line;
			} else {
				$line_in_combo_i = 1;
				$combined_line = $combined_line . ';' . $full_line . "\n";
				print $tmp_write_handle $combined_line;
				$combined_line = "";
			}
		}
		close($orig_read_handle);
		close($tmp_write_handle);

		my $sort_command = "sort $sort_buffer_size --numeric-sort --output=$orig_file_path $tmp_file_path";
		my $exit_sort = system($sort_command);
		if ($exit_sort != 0) {
			die "Failed to run $sort_command. Exit code is $exit_sort";
		}

		open(my $sort_read_handle, "<", $orig_file_path);
		open(my $un_combine_write_handle, ">", $tmp_file_path);
		while (my $full_line = <$sort_read_handle>) {
			chomp $full_line;
			my @line_separated = split(/;/, $full_line);
			my $orig_second_line = $line_separated[1];
			my $first_line = $line_separated[0];
			my @space_separated = split(/ /, $first_line);
			my $sj_cluster_index = $space_separated[0];
			my $orig_first_line = substr($first_line, (length $sj_cluster_index) + 1);
			$orig_first_line = $orig_first_line . "\n";
			$orig_second_line = $orig_second_line . "\n";
			print $un_combine_write_handle $orig_first_line;
			print $un_combine_write_handle $orig_second_line;
		}
		close($sort_read_handle);
		close($un_combine_write_handle);

		move($tmp_file_path, $orig_file_path) or die "cannot mv $tmp_file_path $orig_file_path: $!";
	}

	sub remove_prefix_and_suffix {
		my ($string, $prefix, $suffix) = @_;
		my $without_prefix = substr($string, length($prefix));
		return substr($without_prefix, 0, length($without_prefix) - length($suffix));
	}

	sub parse_sj_group_fa_entry {
		my ($line_1, $line_2) = @_;
		# $line_1: >{sj_string} SJclst:{clust_num}: group:{group_num}:
		# $line_2: {sequence}
		chomp($line_1);
		chomp($line_2);
		my $line_1_trim = substr($line_1, 1); # remove leading >
		my @line_1_parts = split(/ /, $line_1_trim);
		my $sj_string = $line_1_parts[0];
		my $sj_clust_string = $line_1_parts[1];
		my $group_string = $line_1_parts[2];
		my $clust_prefix = 'SJclst:';
		my $clust_suffix = ':';
		my $sj_clust = &remove_prefix_and_suffix($sj_clust_string, $clust_prefix, $clust_suffix);
		my $group_prefix = 'group:';
		my $group_suffix = ':';
		my $group = &remove_prefix_and_suffix($group_string, $group_prefix, $group_suffix);
		my %sj_info = ();
		$sj_info{'sj'} = $sj_string;
		$sj_info{'clust'} = $sj_clust;
		$sj_info{'group'} = $group;
		$sj_info{'seq'} = $line_2;

		return \%sj_info;
	}

	sub get_sequences_to_align_for_read_id {
		my ($all_info_read_ref, $last_read, $last_read2extract_ref, $current_cluster_SJ_number, $SJFS_dist_add, $SJFS_dist, $smith_waterman) = @_;
		my $SJFS_two_plus_add = (2 * $SJFS_dist) + $SJFS_dist_add;
		my $read_info_ref = ${$all_info_read_ref}[$last_read];
		my $read_seq_to_align = ${$read_info_ref}{'readSeq'};
		my $read_length = ${$read_info_ref}{'read_length'};
		my $notSameStrand = ${$read_info_ref}{'notSameStrand'};

		# Replace parts of the read sequence that are not near an SJ with 'N'.
		my @sort_pos_SJ = sort {$a <=> $b} keys %{$last_read2extract_ref};
		for my $i (0 .. $#sort_pos_SJ) {
			my $pos = $sort_pos_SJ[$i];
			if ($i == $#sort_pos_SJ) {
				my $extra_length = $last_read2extract_ref->{$pos}[1-$notSameStrand];
				if (($extra_length == 0 or ($current_cluster_SJ_number == 1 and $extra_length > 0)) and $pos + $SJFS_two_plus_add < $read_length) {
					substr($read_seq_to_align, $pos + $SJFS_two_plus_add) = 'N' x ($read_length - $pos - $SJFS_two_plus_add);
				}
			} if ( $i == 0 ) {
				my $extra_length = $last_read2extract_ref->{$pos}[$notSameStrand];
				if (($extra_length == 0 or ($current_cluster_SJ_number == 1 and $extra_length > 0)) and $pos - $SJFS_two_plus_add > 0 ) {
					substr($read_seq_to_align, 0, $pos - $SJFS_two_plus_add) = 'N' x ($pos - $SJFS_two_plus_add);
				}
			} else {
				my $prev_pos = $sort_pos_SJ[$i-1];
				my $replaceable_length = $pos - $prev_pos - 2 * $SJFS_two_plus_add;
				if ($replaceable_length > 0) {
					substr($read_seq_to_align, $prev_pos + $SJFS_two_plus_add, $replaceable_length) = 'N' x $replaceable_length;
				}
			}
		}

		if (!$smith_waterman) {
			return $read_seq_to_align;
		}

		# Split the sequence into N and non-N segments
		my @read_seq_segments = ();
		my $segment_start_i = 0;
		my $segment_is_N = (substr($read_seq_to_align, 0, 1) eq 'N');
		for my $seq_i (1 .. ($read_length - 1)) {
			my $base = substr($read_seq_to_align, $seq_i, 1);
			my $base_is_N = $base eq 'N';
			if ($base_is_N == $segment_is_N) {
				next;
			}
			my $segment_length = $seq_i - $segment_start_i;
			my $segment = substr($read_seq_to_align, $segment_start_i, $segment_length);
			push @read_seq_segments, $segment;
			$segment_start_i = $seq_i;
			$segment_is_N = $base_is_N;
		}
		my $segment = substr($read_seq_to_align, $segment_start_i);
		push @read_seq_segments, $segment;

		# Combine segments together except "long" N-segments
		my @collapsed_segments = ();
		push @collapsed_segments, '';
		for my $segment (@read_seq_segments) {
			my $segment_length = length($segment);
			my $segment_is_N = (substr($segment, 0, 1) eq 'N');
			if ($segment_is_N and ($segment_length > $SJFS_two_plus_add)) {
				push @collapsed_segments, $segment;
				push @collapsed_segments, '';
			} else {
				$collapsed_segments[-1] = $collapsed_segments[-1] . $segment;
			}
		}
		if ($collapsed_segments[0] eq '') {
			shift(@collapsed_segments);
		}
		if ($collapsed_segments[-1] eq '') {
			pop(@collapsed_segments);
		}
		return \@collapsed_segments;
	}

	sub run_blast_on_files {
		my ($sj_file_path, $read_file_path, $out_dir, $same_group_count, $evalue_cor, $summary_data_ref) = @_;
		my $db_command = "makeblastdb -in $sj_file_path -dbtype nucl -out $out_dir/current_db -title current_db";
		my $exit_db = system($db_command);
		if ($exit_db != 0) {
			warn "Failed to run \"$db_command\". Exit code is $exit_db";
		}
		my $blast_command = "blastn -task blastn -db $out_dir/current_db -query $read_file_path -word_size 4 -reward 5 -penalty -4 -gapopen 8 -gapextend 6 -num_threads 1 -evalue $evalue_cor -dust no -soft_masking false -outfmt \"6 std btop\" >> $out_dir/read_SJ_group_$same_group_count.blast";
		my $exit_blast = system($blast_command);
		if ($exit_blast != 0) {
			warn "Failed to run \"$blast_command\". Exit code is $exit_blast";
		}
		$summary_data_ref->{'number_of_aligner_calls'} ++;
	}

	sub estimate_blast_runtime {
		# Based on runtimes recorded for test data, blast runtime is
		# roughly linear with respect to (num_sj_lines * num_read_lines).
		# Additionally, a small fixed amount of time is estimated for small inputs
		# to account for flushing the input files and starting blast.
		my ($num_read_lines, $num_sj_lines) = @_;
		# Since num_reads is (num_read_lines / 2) and num_sjs is (num_sj_lines / 2) multiply by 0.25
		my $amount_of_work = $num_read_lines * $num_sj_lines * 0.25;
		# small job cutoff at 1500 * 0.002 = 3
		if ($amount_of_work <= 1500) {
			# 3 second estimate for small inputs
			return 3;
		}
		# linear estimate for larger inputs
		return $amount_of_work * 0.002;
	}

	sub get_aligner_matrix_pointer {
		my $match_score = 5;
		my $mismatch_score = -4;
		my $score_matrix_p = Parasail::get_score_matrix_p($match_score, $mismatch_score);
		return $score_matrix_p;
	}

	sub run_aligner_on_reads_and_sjs {
		my ($reads_by_id_ref, $sj_array_ref, $summary_data_ref, $aligner_matrix_pointer, $alignments_by_read_ref) = @_;
		my $gap_open = 8;
		my $gap_extend = 6;

		while (my ($read_id, $read_segments_ref) = each %{$reads_by_id_ref}) {
			my $offset_i = 0;
			for my $read_seq (@{$read_segments_ref}) {
				my $read_seq_len = length($read_seq);
				my $segment_has_non_N = ($read_seq =~ m/[^N]/);
				if (!$segment_has_non_N) {
					$offset_i += $read_seq_len;
					next;
				}

				my $profile_p = Parasail::profile_create_16($read_seq, $read_seq_len, $aligner_matrix_pointer);
				for my $sj_info (@{$sj_array_ref}) {
					my $sj_id = $sj_info->{'sj'};
					my $sj_seq = $sj_info->{'seq'};
					my $result_p = Parasail::sw_trace_striped_profile_16($profile_p, $sj_seq, length($sj_seq), $gap_open, $gap_extend);
					$summary_data_ref->{'number_of_aligner_calls'} ++;
					my $score = Parasail::result_get_score($result_p);
					my %cigar_info = Parasail::result_get_cigar_info($result_p, $read_seq, $sj_seq, $aligner_matrix_pointer);
					my @cigar_parts = @{$cigar_info{'parts'}};
					my $read_start = $cigar_info{'query_start'} + $offset_i;
					my $sj_start = $cigar_info{'ref_start'};
					my $read_end = Parasail::result_get_end_query($result_p) + $offset_i;
					my $sj_end = Parasail::result_get_end_ref($result_p);
					Parasail::result_free($result_p);
					my %result_info = ();
					$result_info{'cigar'} = \@cigar_parts;
					# Convert from 0-based coordinates to 1-based coordinates.
					# The code was originally written for blast which outputs 1-based coords.
					$result_info{'read_start'} = $read_start + 1;
					$result_info{'sj_start'} = $sj_start + 1;
					$result_info{'read_end'} = $read_end + 1;
					$result_info{'sj_end'} = $sj_end + 1;
					$result_info{'score'} = $score;
					push @{$alignments_by_read_ref->{$read_id}{$sj_id}}, \%result_info;
				}
				Parasail::profile_free($profile_p);
				$offset_i += $read_seq_len;
			}
		}
	}

	sub wait_for_threads_to_complete_work {
		my ($threads_ref, $summary_data_ref) = @_;
		my $num_threads = scalar(@{$threads_ref});
		my @running_threads = 0 .. ($num_threads - 1);
		my @still_running_threads = ();
		my $first_check = 1;
		my $had_error = 0;
		while (@running_threads) {
			if ($first_check) {
				$first_check = 0;
			} else {
				# Give the threads a chance to work
				my $sleep_seconds = 5;
				sleep $sleep_seconds;
			}
			for my $thread_i (@running_threads) {
				my $thread_is_joinable = $threads_ref->[$thread_i]->is_joinable();
				if ($thread_is_joinable) {
					my @results = $threads_ref->[$thread_i]->join();
					if (((scalar @results) == 2) and $results[0] == 1) {
						my $th_id = $threads_ref->[$thread_i]->tid();
						print "Worker $th_id finished reporting.\n";
						my $thread_summary_ref = $results[1];
						&merge_summary_results($summary_data_ref, $thread_summary_ref);
					} else {
						$had_error = 1;
					}
				} else {
					push @still_running_threads, $thread_i;
				}
			}

			@running_threads = @still_running_threads;
			@still_running_threads = ();
			if ($had_error) {
				last;
			}
		}

		if (!$had_error) {
			return;
		}

		for my $thread_i (@running_threads) {
			if (!$threads_ref->[$thread_i]->is_joinable()) {
				my $th_id = $threads_ref->[$thread_i]->tid();
				print "Terminating worker $th_id.\n";
				$threads_ref->[$thread_i]->kill('TERM');
			}
		}
		# Give the threads a chance to exit
		my $sleep_seconds = 1;
		sleep $sleep_seconds;

		for my $thread_i (@running_threads) {
			if ($threads_ref->[$thread_i]->is_joinable()) {
				$threads_ref->[$thread_i]->join();
			} else {
				my $th_id = $threads_ref->[$thread_i]->tid();
				print "Worker $th_id not responding.\n";
			}
		}
		die "Exiting due to error in worker thread\n";
	}

	sub merge_summary_results {
		my ($summary_data_ref, $thread_summary_ref) = @_;
		while (my ($key, $value) = each %{$thread_summary_ref}) {
			$summary_data_ref->{$key} += $value;
		}
	}

	sub initialize_summary_data {
		my $summary_data_ref = $_[0];
		$summary_data_ref->{'num_reads_output'} = 0;
		$summary_data_ref->{'num_reads_missing_blast_output'} = 0;
		$summary_data_ref->{'num_reads_without_SJs_to_correct'} = 0;
		$summary_data_ref->{'number_of_passed_SJ_alignments'} = 0;
		$summary_data_ref->{'number_of_corrected_SJ_alignments'} = 0;
		$summary_data_ref->{'number_of_failed_SJ_alignments'} = 0;
		$summary_data_ref->{'number_of_added_first_SJ_alignments'} = 0;
		$summary_data_ref->{'number_of_added_last_SJ_alignments'} = 0;
		$summary_data_ref->{'number_of_aligner_calls'} = 0;
		$summary_data_ref->{'number_of_nhmmer_calls'} = 0;
	}

	sub write_summary_file {
		my ($summary_path, $summary_data_ref) = @_;
		open(my $summary_handle, '>', $summary_path) or die "cannot write $summary_path: $!";
		print $summary_handle "$summary_data_ref->{'perl_command'}\n";
		print $summary_handle "number of reads in output: $summary_data_ref->{'num_reads_output'}\n";
		print $summary_handle "number of reads missing blast output: $summary_data_ref->{'num_reads_missing_blast_output'}\n";
		print $summary_handle "number of reads without splice junctions to correct: $summary_data_ref->{'num_reads_without_SJs_to_correct'}\n";
		print $summary_handle "number of passed splice junction alignments: $summary_data_ref->{'number_of_passed_SJ_alignments'}\n";
		print $summary_handle "number of corrected splice junction alignments: $summary_data_ref->{'number_of_corrected_SJ_alignments'}\n";
		print $summary_handle "number of failed splice junction alignments: $summary_data_ref->{'number_of_failed_SJ_alignments'}\n";
		print $summary_handle "number of added first splice junction alignments: $summary_data_ref->{'number_of_added_first_SJ_alignments'}\n";
		print $summary_handle "number of added last splice junction alignments: $summary_data_ref->{'number_of_added_last_SJ_alignments'}\n";
		print $summary_handle "number of aligner calls: $summary_data_ref->{'number_of_aligner_calls'}\n";
		print $summary_handle "number of nhmmer calls: $summary_data_ref->{'number_of_nhmmer_calls'}\n";
		close $summary_handle;
	}

	sub print_with_timestamp {
		my ($message) = @_;
		my $time_value = localtime;
		print "[$time_value] $message\n";
	}
}
