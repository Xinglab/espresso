use strict;
use Getopt::Long;

my $version = 'Q_alpha1.2.2';
my ($help, $in_dir, $out_dir, $anno, $anno_C, $tsv_compt, $list_samples, $read_num_cutoff, $read_ratio_cutoff, $is_denovo, $max_iterate, $SJ_dist, $raw, $target_col_index, $tmp_output);

Getopt::Long::GetOptions (

	'list_samples|L=s'			=>	\$list_samples,
	'out_dir|O=s'				=>	\$out_dir,
	'anno|A=s'					=>	\$anno,
	'anno_C|C=s'				=>	\$anno_C,
	'tsv_compt|V=s'				=>	\$tsv_compt,

	'help|H!'					=>	\$help,

	'read_ratio_cutoff|R=f'		=>	\$read_ratio_cutoff,
	'read_num_cutoff|N=i'		=>	\$read_num_cutoff,
	'max_iterate|M=i'			=>	\$max_iterate,
	'SJ_dist|S=i'				=>	\$SJ_dist,
	'raw!'						=>	\$raw,
	'target_col_index=i'		=>	\$target_col_index,
	'tmp_output=s'				=>	\$tmp_output

);

if (defined($help)) {
	print "
Program:  ESPRESSO (Error Statistics PRomoted Evaluator of Splice Site Options)
Version:  $version
Contact:  Yuan Gao <gaoy\@email.chop.edu, gy.james\@163.com>

Usage:    perl ESPRESSO_Q.pl -L work_dir/samples.tsv.updated -A anno.gtf

Arguments:

    -L, --list_samples
          tsv list of multiple samples (each bam in a line with 1st column as
          sorted bam file, 2nd column as sample name in output, 3rd column as
          directory of ESPRESSO_C results; this list can be generated by
          ESPRESSO_S according to the initially provided tsv list; required)
    -A, --anno
          input annotation file in GTF format (optional)
    -O, --out_dir
          output directory (default: directory of -L)
    -V, --tsv_compt
          output tsv for compatible isoform(s) of each read (optional)

    -H, --help
          show this help information

    -N, --read_num_cutoff
          min perfect read count for all splice junctions of novel isoform
          (default: 2)
    -R, --read_ratio_cutoff
          min perfect read ratio for all splice junctions of novel isoform
          (default: 0)

";
} elsif ( !defined($list_samples) ) {
	print  "The following parameter is required:\n";
	print  "\t--list_samples/-L";
	print  "\nPlease use the --help or -H option to get usage information.\n";
} else {
	my $target_dir;
	if (rindex($list_samples, "/")>=0){
		$target_dir = (substr( $list_samples, 0, rindex($list_samples, "/") ));
	} else {
		$target_dir = '.';
	}

	if (!defined $out_dir) {
		$out_dir = $target_dir;
	} elsif ( !-d $out_dir ) {
		warn " Output directory $out_dir does not exist. Make it by myself\n";
		system("mkdir $out_dir"); 
	}

	if (defined $tsv_compt) {
		if (index($tsv_compt, '/') == -1) {
			$tsv_compt = $out_dir.'/'.$tsv_compt;
		}
	}

	$read_ratio_cutoff = 0 if !defined $read_ratio_cutoff;
	$read_num_cutoff = 2 if !defined $read_num_cutoff;
	$SJ_dist = 35 if !defined $SJ_dist;
	$max_iterate = 100 if !defined $max_iterate;

	$target_col_index = 7 if !defined $target_col_index;

	my $base_in_dir;

	my $dot_index = rindex($list_samples, '.');
	if ($dot_index == 0) {
		$in_dir = substr($list_samples, 1);
	} else {
		$in_dir = substr($list_samples, 0, $dot_index);
	}

	my @in_dir_parts = split /[\/.]/, $in_dir;
	if (length($in_dir_parts[-1]) > 1) {
		$base_in_dir = $in_dir_parts[-2];
	} else {
		$base_in_dir = 'samples';
	}

	my $keep_tmp = 1 if defined $tmp_output;
	#$tmp_output = $out_dir."/ESPRESSO_${version}_$base_in_dir.txt" if !defined $tmp_output;


	my %strand_digit = ('+' => 0, '-' => 1);
	my %strand_symbol = ('0' => '+', '1' => '-', 'unknown' => 'unknown');
	my $sep_SJ = ':';

	print  '[', scalar(localtime), "] Loading annotation\n";

	my (%isoform_info, %anno_SJ, %anno_SS, %isoform_SJ, %isoform_exon);
	if(defined $anno) {
		my (%anno_exons);
		open ANNO, "<", $anno or die "cannot open $anno: $!";
		while(<ANNO>) {
			chomp;
			my @line = split /\t/;
			next if $line[2] ne 'exon';
			my ($current_isoform, $current_gene);
			my ($gene_name,$isoform_name) = ('NA','NA');
			if($line[-1] =~ /transcript_id \"(\S+)\"/) {
				$current_isoform = $1;
			} else {
				die "no transcript_id found in $_";
			}
			if($line[-1] =~ /gene_id \"(\S+)\"/) {
				$current_gene = $1;
			} else {
				die "no transcript_id found in $_";
			}
			if($line[-1] =~ /gene_name \"(\S+)\"/) {
				$gene_name = $1;
			}
			if($line[-1] =~ /transcript_name \"(\S+)\"/) {
				$isoform_name = $1;
			}
			$isoform_info{$current_isoform} = [$current_gene, $line[6], $line[0], $gene_name, $isoform_name];
			$anno_exons{$current_isoform}{$line[3]-1} = $line[4];

			$isoform_exon{$current_isoform}{($line[3]-1).':'.$line[4]} = [$line[3]-1, $line[4], $line[0], $line[6]];

		}
		while (my ($isoform, $exon_start_ref) = each %anno_exons) {
			my @exon_start_sort = sort {$a <=> $b} keys %{$exon_start_ref};
			my $strand = $isoform_info{$isoform}[1];
			my $chr = $isoform_info{$isoform}[2];
			for my $i (1 .. $#exon_start_sort){
				$anno_SS{'0'}{$chr.':'.${$exon_start_ref}{$exon_start_sort[$i-1]}.':'.$strand_digit{$strand}} ++;
				$anno_SS{'1'}{$chr.':'.$exon_start_sort[$i].':'.$strand_digit{$strand}} ++;
				#my $SJ2_no_strand = $chr.$sep_SJ.${$exon_start_ref}{$exon_start_sort[$i-1]}.$sep_SJ.$exon_start_sort[$i];
				#my $SJ2 = $SJ2_no_strand.$sep_SJ.$strand_digit{$strand};
				my $SJ2 = $chr.$sep_SJ.${$exon_start_ref}{$exon_start_sort[$i-1]}.$sep_SJ.$exon_start_sort[$i];
				$isoform_SJ{$chr}{$isoform}{$SJ2} = [${$exon_start_ref}{$exon_start_sort[$i-1]}, $exon_start_sort[$i], $strand_digit{$strand}];
				if (!exists $anno_SJ{$chr}{$SJ2}) {
					$anno_SJ{$chr}{$SJ2} = [$strand_digit{$strand},${$exon_start_ref}{$exon_start_sort[$i-1]},$exon_start_sort[$i],[$isoform]];
				} else {
					push @{$anno_SJ{$chr}{$SJ2}[-1]}, $isoform;
				}
			}
		}
	}
	my (%isoform_SJ_complete, %anno_SJ_complete);
	if (defined $anno_C) {
		my (%anno_exons);

		open ANNOC, "<", $anno_C or die "cannot open $anno_C: $!";
		while(<ANNOC>) {
			chomp;
			my @line = split /\t/;
			next if $line[2] ne 'exon';
			my ($current_isoform, $current_gene);
			my ($gene_name,$isoform_name) = ('NA','NA');
			if($line[-1] =~ /transcript_id \"(\S+)\"/) {
				$current_isoform = $1;
			} else {
				die "no transcript_id found in $_";
			}
			if($line[-1] =~ /gene_id \"(\S+)\"/) {
				$current_gene = $1;
			} else {
				die "no transcript_id found in $_";
			}
			if($line[-1] =~ /transcript_name \"(\S+)\"/) {
				$isoform_name = $1;
			}
			$isoform_info{$current_isoform} = [$current_gene, $line[6], $line[0], $gene_name, $isoform_name];
			$anno_exons{$current_isoform}{$line[3]-1} = $line[4];

		}
		while (my ($isoform, $exon_start_ref) = each %anno_exons) {
			my @exon_start_sort = sort {$a <=> $b} keys %{$exon_start_ref};
			my $strand = $isoform_info{$isoform}[1];
			my $chr = $isoform_info{$isoform}[2];
			for my $i (1 .. $#exon_start_sort){
				#my $SJ2_no_strand = $chr.$sep_SJ.${$exon_start_ref}{$exon_start_sort[$i-1]}.$sep_SJ.$exon_start_sort[$i];
				#my $SJ2 = $SJ2_no_strand.$sep_SJ.$strand_digit{$strand};
				my $SJ2 = $chr.$sep_SJ.${$exon_start_ref}{$exon_start_sort[$i-1]}.$sep_SJ.$exon_start_sort[$i];
				$isoform_SJ_complete{$chr}{$isoform}{$SJ2} = [${$exon_start_ref}{$exon_start_sort[$i-1]}, $exon_start_sort[$i], $strand_digit{$strand}];
				if (!exists $anno_SJ_complete{$chr}{$SJ2}) {
					$anno_SJ_complete{$chr}{$SJ2} = [$strand_digit{$strand},${$exon_start_ref}{$exon_start_sort[$i-1]},$exon_start_sort[$i],[$isoform]];
				} else {
					push @{$anno_SJ_complete{$chr}{$SJ2}[-1]}, $isoform;
				}
			}
		}
	}

	print  '[', scalar(localtime), "] Summarizing annotated isoforms\n";

	my (%multi_exon_isoform_end,%single_exon_isoform_end);
	while (my ($chr, $isoform_ref) = each %isoform_SJ) {
		while (my ($isoform, $SJ_ref) = each %{$isoform_ref}) {
			my @exon_sort = sort {${$isoform_exon{$isoform}}{$a}[0] <=> ${$isoform_exon{$isoform}}{$b}[0]} keys %{$isoform_exon{$isoform}};
			$multi_exon_isoform_end{$isoform}{'0'} = $isoform_exon{$isoform}{$exon_sort[0]}[0];
			$multi_exon_isoform_end{$isoform}{'1'} = $isoform_exon{$isoform}{$exon_sort[-1]}[1];
			$multi_exon_isoform_end{$isoform}{${$isoform_exon{$isoform}{$_}}[1]} = ${$isoform_exon{$isoform}{$_}}[0] for @exon_sort;
			$multi_exon_isoform_end{$isoform}{${$isoform_exon{$isoform}{$_}}[0]} = ${$isoform_exon{$isoform}{$_}}[1] for @exon_sort;

		}
	}

	while (my ($isoform, $exon_ref) = each %isoform_exon) {
		if (!exists $multi_exon_isoform_end{$isoform}){
			while (my ($exon, $exon_info_ref) = each %{$exon_ref}){
				$single_exon_isoform_end{${$exon_info_ref}[2]}{$isoform}{'0'} = ${$exon_info_ref}[0];
				$single_exon_isoform_end{${$exon_info_ref}[2]}{$isoform}{'1'} = ${$exon_info_ref}[1];
				$single_exon_isoform_end{${$exon_info_ref}[2]}{$isoform}{'strand'} = ${$exon_info_ref}[3];
			}
		}
	}

	print  '[', scalar(localtime), "] Loading corrected splice junctions and alignment information by ESPRESSO\n";
	
	open GTF,  ">", $out_dir."/${base_in_dir}_N${read_num_cutoff}_R${read_ratio_cutoff}_updated.gtf" or die "cannot write $out_dir/${base_in_dir}_N${read_num_cutoff}_R${read_ratio_cutoff}_updated.gtf: $!";
	open ABU,  ">", $out_dir."/${base_in_dir}_N${read_num_cutoff}_R${read_ratio_cutoff}_abundance.esp" or die "cannot write $out_dir/${base_in_dir}_N${read_num_cutoff}_R${read_ratio_cutoff}_abundance.esp: $!";
	open COMPT, ">", $tsv_compt or die "cannot write $tsv_compt: $!" if defined $tsv_compt;
	open DEFAULT,  ">", $tmp_output if defined $tmp_output;

	my (@samples_sort, %file_sample, %input_file);
	my (%file_input, %sample_file);
	open LIST_S, "<", $list_samples or die "cannot open $list_samples: $!";
	while(<LIST_S>) {
		chomp;
		my @line = split /\t/;
		if ( $_ ne '' and (@line != 3 or $line[0] eq '' or $line[1] eq '' or $line[2] eq '') ){
			die "Please make sure $list_samples has three columns seperated by tab.";
		} elsif ($_ eq '') {
			next;
		}
		if ( (!exists $file_sample{$line[0]} or $file_sample{$line[0]} eq $line[1]) and (!exists $file_input{$line[0]} or $file_input{$line[0]} eq $line[2])) {
			$file_sample{$line[0]} = $line[1];
			$sample_file{$line[1]}{$line[0]} ++;
			$input_file{$line[2]}{$line[0]} ++;
			$file_input{$line[0]} = $line[2];
		} elsif (exists $file_sample{$line[0]}) {
			die "One fastq file should only correspond to one sample. \nThe fastq file \"$line[0]\" corresponds to more than one samples: \"$file_sample{$line[0]}\", \"$line[1]\".";
		} elsif (exists $file_input{$line[0]}) {
			die "One fastq file should only correspond to one input directory. \nThe fastq file \"$line[0]\" corresponds to more than one input directories: \"$file_input{$line[0]}\", \"$line[2]\".";
		}
		
	}
	@samples_sort = sort {$a <=> $b or $a cmp $b} keys %sample_file;

	opendir DIR, $out_dir or die "cannot opendir $out_dir: $!";

	for my $file (readdir DIR) {
		if (-f "$out_dir/$file" and (index($file, 'read_final.tmp')>0 or index($file, 'all_SJ.tmp')>0)) {
			unlink "$out_dir/$file";
		}
	}
	closedir DIR;

	print ABU "transcript_ID\ttranscript_name\tgene_ID";
	print ABU "\t$_" for @samples_sort;
	print ABU "\n";

	my (%chr_tmp_f, %chr_tmp_sj); #, %input_num

	while (my ($input_dir, $bam_file_ref) = each %input_file) {
		unless ($input_dir =~ /(^\d+$)/) {
			die "unexpected format for $input_dir";
		}
		
		my %read_sample;
		
		while (my ($file, $count) = each %{$bam_file_ref}) {
			my $sample = $file_sample{$file};
			if ($file =~ /\.bam$/) {
				open IN, "samtools view -h $file |" or die "cannot open $file using samtools: $!";
			} else {
				open IN, $file or die "can’t open $file";
			}
			while(<IN>) {
				my ($read_ID, undef) = split /\t/;
				$read_sample{$read_ID} = $sample;
			}
			close IN;
		}
		
		my $valid_read_final_num = 0;
		opendir DIR, "$target_dir/$input_dir" or die "cannot opendir $target_dir/$input_dir: $!";
		for my $file (readdir DIR) {
			my $rindex_read_final = rindex ($file, "_read_final.txt");
			if ( $rindex_read_final > 0 and $rindex_read_final+15==length($file) ) { # 
				my $chr = substr($file, 0, $rindex_read_final);
				my $tmp_f = $out_dir."/$chr.read_final.tmp";
				$valid_read_final_num ++;
				$chr_tmp_f{$chr} ++;
				open TMP_F, ">>", $tmp_f or die "cannot write $tmp_f: $!";
				open IN_F,  "<", "$target_dir/$input_dir".'/'.$file or die "cannot open $target_dir/$input_dir/$file: $!";
				while (<IN_F>) {
					s/\r\n//;
					chomp;
					my @line = split /\t/;
					if ($line[1] eq 'group_ID') {
						if ( exists $read_sample{$line[0]} ) {
							print TMP_F "$line[0]\t$line[1]\t$line[2]\t$read_sample{$line[0]}\t$target_dir/$input_dir\t$input_dir\t$line[3]\n";
						} else {
							die "Don't know which sample $line[0] in $target_dir/$input_dir/$file is from.";
						}
					} else {
						print TMP_F "$_\n";
					}
				}
				close TMP_F;
				close IN_F;
			}
		}
		die "No valid read_final.list can be found in $target_dir/$input_dir.\n" if $valid_read_final_num == 0;
		
		my ($last_chr, $tmp_sj, @last_chr_info);
		if(-s "$target_dir/$input_dir".'/sj.list' > 0) {
			open IN_SJ,  "<", "$target_dir/$input_dir".'/sj.list' or die "cannot open $target_dir/$input_dir/sj.list: $!";
			while (<IN_SJ>) {
				s/\r\n//;
				chomp;
				my @line = split /\t/;
				if (!defined $tmp_sj or $last_chr ne $line[2]) {
					if (defined $tmp_sj) {
						print TMP_SJ "$input_dir\t$_\n" for @last_chr_info;
						@last_chr_info = ();
						close TMP_SJ;
					}
					$tmp_sj = $out_dir."/$line[2].all_SJ.tmp";
					$chr_tmp_sj{$line[2]} ++;
					open TMP_SJ, ">>", $tmp_sj or die "cannot write $tmp_sj: $!";
				}
				push @last_chr_info, $_;
				$last_chr = $line[2];
			}
			print TMP_SJ "$input_dir\t$_\n" for @last_chr_info;
			@last_chr_info = ();
			close TMP_SJ;
			close IN_SJ;
		} else {
			warn "No valid sj.list can be found in $target_dir/$input_dir.\n";
		}
		
	}

	print  '[', scalar(localtime), "] Categorizing reads according to annotation\n";
	my %chr_type;
	while (my ($chr, $count) = each %chr_tmp_f) {
		my $tmp_f = $out_dir."/$chr.read_final.tmp";
		my $tmp_sj = $out_dir."/$chr.all_SJ.tmp";

		my %SJ_read_improved;
		my %read_filtered;
		my %read_info;
		my %SJ_read_order;
		my %unanno_SJ;

		my %all_SJ_reads;
		my ($read_input_ID,$strand_isoform);
		open TMP_F, "<", $tmp_f or die "cannot open $tmp_f: $!";
		while (<TMP_F>) {
			s/\r\n//;
			chomp;
			my @line = split /\t/;
			if ($line[1] eq 'SJ'){

				if ($line[$target_col_index] ne 'NA') {
					my ($chr, $start, $end, $strand) = split ':', $line[$target_col_index];
					$line[$target_col_index] = join ':', ($chr, $start, $end);
					$SJ_read_improved{$read_input_ID}{$line[$target_col_index]} = [$chr, $start, $end, $strand_isoform, 0];
					if (exists $anno_SJ{$chr}{$line[$target_col_index]}){
						$SJ_read_improved{$read_input_ID}{$line[$target_col_index]}[-1] = 1;
						$all_SJ_reads{$line[$target_col_index]}{$line[0]} = 0;
					} else {
						$unanno_SJ{$line[$target_col_index]} = [$strand, $start, $end];
						$all_SJ_reads{$line[$target_col_index]}{$line[0]} = 0;
					}
					$SJ_read_order{$read_input_ID}{$line[2]} = $line[$target_col_index];
				} else {
					$read_filtered{$read_input_ID} ++ if $target_col_index == 7;
					$SJ_read_order{$read_input_ID}{$line[2]} = 'x' if $target_col_index == 7;
				}
			} elsif ($line[1] eq 'start' or $line[1] eq 'end') {
				$read_info{$read_input_ID}{$line[1]} = $line[$target_col_index];
			} elsif ($line[1] eq 'group_ID') {
				$read_input_ID = $line[5].'_'.$line[6];
				$read_info{$read_input_ID}{'sample'} = $line[3];
				$read_info{$read_input_ID}{'ori_ID'} = $line[0];
			} elsif ($line[1] eq 'strand_isoform') {
				$strand_isoform = $line[2];
				$read_info{$read_input_ID}{'strand_isoform'} = $strand_isoform;
			}
		}
		close TMP_F;

		if (exists $chr_tmp_sj{$chr}) {
			open TMP_SJ,  "<", $tmp_sj or die "cannot open $tmp_sj: $!";
			while (<TMP_SJ>) {
				s/\r\n//;
				chomp;
				my @line = split /\t/;
				next if $line[-2] eq 'NA';
				my @perfect_reads = split ',', $line[-2];
				if (exists $all_SJ_reads{$line[2]}) {
					$all_SJ_reads{$line[2]}{$_} ++ for @perfect_reads;
				}
			}
			close TMP_SJ;
		}

		unlink($tmp_f) if !defined $keep_tmp;
		unlink($tmp_sj) if !defined $keep_tmp;
		
		my %group_reads;
		my %group_ends;
		
		my @group_sort;
#need update

		while (my ($read, $info_ref) = each %read_info){
			my ($sample_ID, $group_ID, $read_ID) = split '_', $read;
			push @{$group_reads{$group_ID}}, $read;
			if(!exists $group_ends{$group_ID}) {
				$group_ends{$group_ID} = [${$info_ref}{'start'}, ${$info_ref}{'end'}];
			} else {
				if (${$info_ref}{'start'} < $group_ends{$group_ID}[0]) {
					$group_ends{$group_ID}[0] = ${$info_ref}{'start'};
				} if (${$info_ref}{'end'} > $group_ends{$group_ID}[1]) {
					$group_ends{$group_ID}[1] = ${$info_ref}{'end'};
				}
			}
		}
		@group_sort = sort {$group_ends{$a}[0] <=> $group_ends{$b}[0]} keys %group_reads;


		my @annotated_SJ_chr = sort {$anno_SJ{$chr}{$a}[1] <=> $anno_SJ{$chr}{$b}[1] or $anno_SJ{$chr}{$a}[2] <=> $anno_SJ{$chr}{$b}[2]} keys %{$anno_SJ{$chr}};
		my @unannotated_SJ_chr = sort {$unanno_SJ{$a}[1] <=> $unanno_SJ{$b}[1] or $unanno_SJ{$a}[2] <=> $unanno_SJ{$b}[2]} keys %unanno_SJ;

		my ($start_SJ_index_anno, $start_SJ_index_unanno) = (0,0);
		my $chr_SJ_reads_ref = \%all_SJ_reads;
		my %single_exon_isoform_total;
		
		for my $n (@group_sort) {

			my (%fsm, %ism, %nic, %nnc, %isoform_perfect_match);
			my @single_exon_reads;
			for my $read (@{$group_reads{$n}}) {
				if (exists $read_filtered{$read}){
					print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\tNA\tfiltered\tNA\n";# if exists $SJ_read_improved{$read};
				} elsif (exists $SJ_read_improved{$read}){
					
					my @SJ_correct = grep {$SJ_read_improved{$read}{$_}[-1] == 1} keys %{$SJ_read_improved{$read}};
					if ( scalar(keys %{$SJ_read_improved{$read}}) != scalar(@SJ_correct) ){
						my @same_SSs = grep {exists $anno_SS{'0'}{${$_}[0].':'.${$_}[1].':'.${$_}[3]} and exists $anno_SS{'1'}{${$_}[0].':'.${$_}[2].':'.${$_}[3]}} values %{$SJ_read_improved{$read}};
						if ( @same_SSs == scalar(keys %{$SJ_read_improved{$read}}) ){
							print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\t",scalar(@same_SSs), "\tNIC\tNA\t";
							$nic{$read} ++;
							$chr_type{$chr}{'nic'} ++;
						} else {
							print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\t",scalar(@same_SSs), "\tNNC\tNA\t";
							$nnc{$read} ++;
							$chr_type{$chr}{'nnc'} ++;
						}
					} else {
						my @fsm_isoforms;
						my @ism_isoforms;

						my $read_info_ref = $read_info{$read};
						my %possible_isoforms;
						while (my ($SJ2, undef) = each %{$SJ_read_improved{$read}}) {
							die "not_recorded:$chr\t$read\t$SJ2\t\n" if !exists $anno_SJ{$chr}{$SJ2};
							die "not_array:$chr\t$read\t$SJ2\t\n" if !defined $anno_SJ{$chr}{$SJ2}[-1];
							$possible_isoforms{$_}++ for @{$anno_SJ{$chr}{$SJ2}[-1]};
						}
						
						while (my ($isoform, undef) = each %possible_isoforms){
							my $SJ_isoform_ref = $isoform_SJ{$chr}{$isoform};
							my $comp_result = &comp_minimap_reference_SJ($SJ_read_improved{$read}, $SJ_isoform_ref);
							if ($comp_result == 1){
								push @fsm_isoforms, $isoform;

							} elsif ($comp_result == 2) {
								push @ism_isoforms, $isoform;
							}
						}
						if (@fsm_isoforms >= 1 ) {
							print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\tall\tFSM\t";
							print DEFAULT "$_," for @fsm_isoforms;
							print DEFAULT "\t";
							push @{$fsm{$read}}, $_ for @fsm_isoforms;
							$chr_type{$chr}{'fsm'} ++;
							for my $fsm_isoform (@fsm_isoforms) {
								if ( abs(${$read_info_ref}{'start'}-$multi_exon_isoform_end{$fsm_isoform}{'0'}) <= $SJ_dist and abs(${$read_info_ref}{'end'}-$multi_exon_isoform_end{$fsm_isoform}{'1'}) <= $SJ_dist ) {
									push @{$isoform_perfect_match{$fsm_isoform}{${$read_info_ref}{'sample'}}}, $read;
								}
							}

						} elsif (@ism_isoforms >= 1){
							print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\tall\tISM\t";
							print DEFAULT "$_," for @ism_isoforms;
							print DEFAULT "\t";
							push @{$ism{$read}}, $_ for @ism_isoforms;
							$chr_type{$chr}{'ism'} ++;
						} else {
							print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\tall\tNIC\tNA\t";
							$nic{$read}++;
							$chr_type{$chr}{'nic'} ++;
						}

					}
					print DEFAULT "$chr\n";
				} else {
					push @single_exon_reads, $read;
					print DEFAULT "$read\t$read_info{$read}{'ori_ID'}\tall\tone-exon\tNA\t$chr\n";
				}
			}

			my %all_SJ_group;
			
			my ($group_start, $group_end) = @{$group_ends{$n}};
			print DEFAULT "group $n: ($group_start, $group_end)\n";
			for my $i ($start_SJ_index_anno .. $#annotated_SJ_chr) {
				if ($anno_SJ{$chr}{$annotated_SJ_chr[$i]}[1] > $group_end) {
					last;
				} elsif ($anno_SJ{$chr}{$annotated_SJ_chr[$i]}[2] >= $group_start and $anno_SJ{$chr}{$annotated_SJ_chr[$i]}[1] <= $group_end) {
					$all_SJ_group{$annotated_SJ_chr[$i]} = [@{$anno_SJ{$chr}{$annotated_SJ_chr[$i]}}, 0];
				} elsif ($anno_SJ{$chr}{$annotated_SJ_chr[$i]}[2] < $group_start){
					$start_SJ_index_anno = $i;
				}
			}
			for my $i ($start_SJ_index_unanno .. $#unannotated_SJ_chr) {
				if ($unanno_SJ{$unannotated_SJ_chr[$i]}[1] > $group_end) {
					last;
				} elsif ($unanno_SJ{$unannotated_SJ_chr[$i]}[2] >= $group_start and $unanno_SJ{$unannotated_SJ_chr[$i]}[1] <= $group_end) {

					$all_SJ_group{$unannotated_SJ_chr[$i]} = [@{$unanno_SJ{$unannotated_SJ_chr[$i]}}, 1];
				} elsif ($unanno_SJ{$unannotated_SJ_chr[$i]}[2] < $group_start){
					$start_SJ_index_unanno = $i;
				}
			}

			my %annotated_isoforms_included;
			while (my ($SJ, $SJ_info) = each %all_SJ_group) {
				if (${$SJ_info}[-1] == 0) {
					for my $isoform (@{${$SJ_info}[-2]}) {
						$annotated_isoforms_included{$isoform} ++;
					}
				}
			}

			while (my ($isoform, undef) = each %annotated_isoforms_included) {
				while (my ($SJ, undef) = each %{$isoform_SJ{$chr}{$isoform}}){
					$all_SJ_group{$SJ} = [@{$anno_SJ{$chr}{$SJ}}, 0] if !exists $all_SJ_group{$SJ};
				}
			}

			my @all_SJ_group_sort = sort {$all_SJ_group{$a}[1] <=> $all_SJ_group{$b}[1] or $all_SJ_group{$a}[2] <=> $all_SJ_group{$b}[2]} keys %all_SJ_group;
			my %all_SJ_group_ID;
			$all_SJ_group_ID{$all_SJ_group_sort[$_]} = $_ for 0 .. $#all_SJ_group_sort;

			my %fsm_chain;
			while (my ($isoform, undef) = each %annotated_isoforms_included) {
				my @SJ_in_group_ID_sort = sort {$a <=> $b} (map {$all_SJ_group_ID{$_}} keys %{$isoform_SJ{$chr}{$isoform}});
				$fsm_chain{$isoform} = join '_', @SJ_in_group_ID_sort;
				print DEFAULT "annotated_isoform: $isoform\t$fsm_chain{$isoform}\n";
			}

			my (%SJ_chain_read, %SJ_chain_cat);
			for my $read (@{$group_reads{$n}}) {
				if (exists $SJ_read_order{$read}) {
					my $SJ_count = scalar (keys %{$SJ_read_order{$read}});
					if (exists $SJ_read_order{$read}{'-1'}){
						$SJ_read_order{$read}{$SJ_count} = $SJ_read_order{$read}{'-1'};
						delete $SJ_read_order{$read}{'-1'};
					}
					my @SJ_order_sort = sort {$a <=> $b} keys %{$SJ_read_order{$read}};
					my @SJ_IDs;
					for my $SJ_order (@SJ_order_sort) {
						if ($SJ_read_order{$read}{$SJ_order} ne 'x'){
							if (exists $all_SJ_group_ID{$SJ_read_order{$read}{$SJ_order}}) {
								push @SJ_IDs, $all_SJ_group_ID{$SJ_read_order{$read}{$SJ_order}}
							} else {
								die "$read has no SJ ID for: $SJ_read_order{$read}{$SJ_order}";
							}
							
						} else {
							push @SJ_IDs, 'x';
						}
					}
					my $SJ_chain = join '_', @SJ_IDs;
					
					if (!exists $SJ_chain_read{$SJ_chain}) {
						my $cat;
						if (exists $fsm{$read}) {
							$SJ_chain_cat{'fsm'}{$SJ_chain} = [scalar(@SJ_IDs), $fsm{$read}];
							$cat = 'fsm';

						} elsif (exists $ism{$read}) {
							$SJ_chain_cat{'ism'}{$SJ_chain} = [scalar(@SJ_IDs), $ism{$read}];
							$cat = 'ism';
						} elsif (exists $nic{$read}) {
							$SJ_chain_cat{'nic'}{$SJ_chain} = [scalar(@SJ_IDs)];
							$cat = 'nic';
						} elsif (exists $nnc{$read}) {
							$SJ_chain_cat{'nnc'}{$SJ_chain} = [scalar(@SJ_IDs)];
							$cat = 'nnc';
						} else {
							$SJ_chain_cat{'filtered'}{$SJ_chain} = [scalar(@SJ_IDs)];
							$cat = 'filtered';
						}
						$SJ_chain_read{$SJ_chain} = [$cat, $read_info{$read}{'start'}, $read_info{$read}{'end'}, $read_info{$read}{'strand_isoform'}, scalar(@SJ_IDs), {}, [[$read, $read_info{$read}{'start'}, $read_info{$read}{'end'}]]];
					} else {
						push @{$SJ_chain_read{$SJ_chain}[-1]}, [$read, $read_info{$read}{'start'}, $read_info{$read}{'end'}];

					}
				}
			}


			my (%SJ_chain_read_exon_end, %SJ_included_chain);
			while (my ($SJ_chain, $SJ_chain_info) = each %SJ_chain_read) {
				#
				my @SJ_IDs = split '_', $SJ_chain;
				my @start_reads_sort = sort {${$a}[1] <=> ${$b}[1]} @{${$SJ_chain_info}[-1]};
				my @end_reads_sort = sort {${$a}[2] <=> ${$b}[2]} @{${$SJ_chain_info}[-1]};
				$SJ_chain_read{$SJ_chain}[1] = ${$start_reads_sort[int(@start_reads_sort/2)]}[1];
				$SJ_chain_read{$SJ_chain}[2] = ${$end_reads_sort[int(@end_reads_sort/2)]}[2];
				next if defined $raw;
				for my $SJ_ID_i (0 .. $#SJ_IDs) {
					push @{$SJ_included_chain{$SJ_IDs[$SJ_ID_i]}}, $SJ_chain if $SJ_IDs[$SJ_ID_i] ne 'x'; #record chain in to hash with keys as SJ
					next if exists $SJ_chain_cat{'filtered'}{$SJ_chain};
					my ($start, $end);
					if ($SJ_ID_i == 0) {
						$start = ${$SJ_chain_info}[1];
					}
					if ($SJ_ID_i == $#SJ_IDs) {
						$end = ${$SJ_chain_info}[2];
					}
					if(!defined $start) {
						my $pre_SJ = $all_SJ_group_sort[$SJ_IDs[$SJ_ID_i-1]];
						my ($pre_SJ_chr, $pre_SJ_start, $pre_SJ_end, $pre_SJ_strand) = split ':', $pre_SJ;
						$start = $pre_SJ_end;
					} if (!defined $end) {
						my $next_SJ = $all_SJ_group_sort[$SJ_IDs[$SJ_ID_i+1]];
						my ($next_SJ_chr, $next_SJ_start, $next_SJ_end, $next_SJ_strand) = split ':', $next_SJ;
						$end = $next_SJ_start;
					}
					$SJ_chain_read_exon_end{$SJ_chain}{'start'}{$SJ_IDs[$SJ_ID_i]} = $start;
					$SJ_chain_read_exon_end{$SJ_chain}{'end'}{$SJ_IDs[$SJ_ID_i]} = $end;
					print DEFAULT "$chr:exon_end: $SJ_chain\t$SJ_IDs[$SJ_ID_i]\t$start\t$end\n";
				}
			}

			while (my ($SJ_ID, $SJ_chain_ref) = each %SJ_included_chain) {
				my @chain_length_sort = sort {$SJ_chain_read{$a}[4] <=> $SJ_chain_read{$b}[4]} @{$SJ_chain_ref}; #sort chains according to length
				for my $i( 0 .. $#chain_length_sort-1 ){	# record possible longer chains of a shorter(filtered) chain
					my $chain_short = $chain_length_sort[$i];
					for my $j ($i+1 .. $#chain_length_sort){
						my $chain_long = $chain_length_sort[$j];
						if ($SJ_chain_read{$chain_short}[4] == $SJ_chain_read{$chain_long}[4]){
							if (exists $SJ_chain_cat{'filtered'}{$chain_long} and !exists $SJ_chain_cat{'filtered'}{$chain_short}) {
								${$SJ_chain_read{$chain_long}[-2]}{$chain_short}++;
							} elsif (exists $SJ_chain_cat{'filtered'}{$chain_short} and !exists $SJ_chain_cat{'filtered'}{$chain_long}) {
								${$SJ_chain_read{$chain_short}[-2]}{$chain_long}++;
							}
						} elsif (!exists $SJ_chain_cat{'filtered'}{$chain_long}) {
							${$SJ_chain_read{$chain_short}[-2]}{$chain_long}++;
						}
					}
				}
			}

			my (%longest_nc_valid, @nc_valid_longest, %substring_nc, @nic_valid_all, @nnc_valid_all);
			my (%read_count_isoform, %cat_SJ_chains_sort, %possible_fsm_filtered, %unannotated_isoforms);

			if (defined $raw) {
				for my $cat ('ism', 'nic', 'nnc') {
					if (exists $SJ_chain_cat{$cat}){
						while (my ($chain, undef) = each %{$SJ_chain_cat{$cat}}) {
							my $validation_result = &valid_nc($chain, $chr_SJ_reads_ref, $SJ_chain_read{$chain}[-1], \%read_info, \@all_SJ_group_sort, $anno_SJ_complete{$chr}, $isoform_SJ_complete{$chr});
							$unannotated_isoforms{$chain} = $validation_result;
							$longest_nc_valid{$chain} = -1 if ${$validation_result}[0] > 0;
						}
					}
				}
			} else {


			
			if (exists $SJ_chain_cat{'nnc'}) {
				my @chain_length_sort = sort {$SJ_chain_cat{'nnc'}{$a}[0] <=> $SJ_chain_cat{'nnc'}{$b}[0]} keys %{$SJ_chain_cat{'nnc'}};
				for my $chain(@chain_length_sort) {
					my $validation_result = &valid_nc($chain, $chr_SJ_reads_ref, $SJ_chain_read{$chain}[-1], \%read_info, \@all_SJ_group_sort, $anno_SJ_complete{$chr}, $isoform_SJ_complete{$chr});
					if (${$validation_result}[0] >= 1) { #chr_anno_SJ_ref
						push @nnc_valid_all, $chain;
						$unannotated_isoforms{$chain} = $validation_result; # if @{${$validation_result}[1]} > 0;
					}
				}
				for my $i( 0 .. $#nnc_valid_all-1 ){
					my @SJs_i = split '_', $nnc_valid_all[$i];
					for my $j ($i+1 .. $#nnc_valid_all){
						next unless exists ${$SJ_chain_read{$nnc_valid_all[$i]}[-2]}{$nnc_valid_all[$j]};
						my $comp_result = &comp_SJ_chain($nnc_valid_all[$i], $nnc_valid_all[$j]);
						print DEFAULT "$nnc_valid_all[$i]\t$nnc_valid_all[$j]\t$comp_result\t$SJ_chain_read_exon_end{$nnc_valid_all[$j]}{'start'}{$SJs_i[0]}\t$SJ_chain_read_exon_end{$nnc_valid_all[$j]}{'end'}{$SJs_i[-1]}\t$SJ_chain_read{$nnc_valid_all[$i]}[1]\t$SJ_chain_read{$nnc_valid_all[$i]}[2]\n";
						if ($comp_result == 2) {
							push @{$substring_nc{$nnc_valid_all[$i]}}, $nnc_valid_all[$j] if $SJ_chain_read_exon_end{$nnc_valid_all[$j]}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$nnc_valid_all[$i]}[1] and $SJ_chain_read_exon_end{$nnc_valid_all[$j]}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$nnc_valid_all[$i]}[2];
						}
					}
				}
				for my $chain(@nnc_valid_all) {
					if (!exists $substring_nc{$chain}) {
						push @nc_valid_longest, $chain;
						$longest_nc_valid{$chain} = $#nc_valid_longest;
					}
				}
			}
			if (exists $SJ_chain_cat{'nic'}) {
				my @chain_length_sort = sort {$SJ_chain_cat{'nic'}{$a}[0] <=> $SJ_chain_cat{'nic'}{$b}[0]} keys %{$SJ_chain_cat{'nic'}};
				for my $chain(@chain_length_sort) {
					my $validation_result = &valid_nc($chain, $chr_SJ_reads_ref, $SJ_chain_read{$chain}[-1], \%read_info, \@all_SJ_group_sort, $anno_SJ_complete{$chr}, $isoform_SJ_complete{$chr});
					if (${$validation_result}[0] >= 1) {
						push @nic_valid_all, $chain;
						$unannotated_isoforms{$chain} = $validation_result; 
					}
				}

				for my $i( 0 .. $#nic_valid_all-1 ){
					my @SJs_i = split '_', $nic_valid_all[$i];
					for my $j ($i+1 .. $#nic_valid_all){
						next unless exists ${$SJ_chain_read{$nic_valid_all[$i]}[-2]}{$nic_valid_all[$j]};
						my $comp_result = &comp_SJ_chain($nic_valid_all[$i], $nic_valid_all[$j]);
						print DEFAULT "$nic_valid_all[$i]\t$nic_valid_all[$j]\t$comp_result\t$SJ_chain_read_exon_end{$nic_valid_all[$j]}{'start'}{$SJs_i[0]}\t$SJ_chain_read_exon_end{$nic_valid_all[$j]}{'end'}{$SJs_i[-1]}\t$SJ_chain_read{$nic_valid_all[$i]}[1]\t$SJ_chain_read{$nic_valid_all[$i]}[2]\n";
						if ($comp_result == 2) {
							push @{$substring_nc{$nic_valid_all[$i]}}, $nic_valid_all[$j] if $SJ_chain_read_exon_end{$nic_valid_all[$j]}{'start'}{$SJs_i[0]}- $SJ_dist <= $SJ_chain_read{$nic_valid_all[$i]}[1] and $SJ_chain_read_exon_end{$nic_valid_all[$j]}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$nic_valid_all[$i]}[2];
						}
					}
				}
				my %longest_nic_valid;
				for my $chain(@nic_valid_all) {
					my @SJs_i = split '_', $chain;
					while (my ($nc_chain, undef) = each %longest_nc_valid) {
						next unless exists ${$SJ_chain_read{$chain}[-2]}{$nc_chain};
						my $comp_result = &comp_SJ_chain($chain, $nc_chain);
						if ($comp_result == 2) {
							push @{$substring_nc{$chain}}, $nc_chain if $SJ_chain_read_exon_end{$nc_chain}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$chain}[1] and $SJ_chain_read_exon_end{$nc_chain}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$chain}[2];
						}
					}
					if (!exists $substring_nc{$chain}) {
						push @nc_valid_longest, $chain;
						$longest_nic_valid{$chain} = $#nc_valid_longest;
					}
				}
				$longest_nc_valid{$_} = $longest_nic_valid{$_} for keys %longest_nic_valid;
			}

			if (exists $SJ_chain_cat{'ism'}) {
				my @chain_length_sort = sort {$SJ_chain_cat{'ism'}{$a}[0] <=> $SJ_chain_cat{'ism'}{$b}[0]} keys %{$SJ_chain_cat{'ism'}};
				my (@possible_nc_ism, %chain_w_compatible_annotated_fsm);
				for my $chain(@chain_length_sort) {
					my (@isoforms_fsm_valid);
					my @SJs_i = split '_', $chain;
					print DEFAULT "ism\t$chain\t";
					print DEFAULT "$_," for @{$SJ_chain_cat{'ism'}{$chain}[1]};
					my $compatible_annotated_fsm_num = 0;
					for my $isoform_fsm(@{$SJ_chain_cat{'ism'}{$chain}[1]}) {
						if (exists $multi_exon_isoform_end{$isoform_fsm}){
							if( exists $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$all_SJ_group_sort[$SJs_i[0]]}[1]} and exists $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$all_SJ_group_sort[$SJs_i[-1]]}[2]} and $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$all_SJ_group_sort[$SJs_i[0]]}[1]} - $SJ_dist <= $SJ_chain_read{$chain}[1] and $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$all_SJ_group_sort[$SJs_i[-1]]}[2]} + $SJ_dist >= $SJ_chain_read{$chain}[2] ){
								$compatible_annotated_fsm_num ++;
								push @isoforms_fsm_valid, $isoform_fsm if exists $SJ_chain_read{$fsm_chain{$isoform_fsm}};	#check if there is any full length annotated isoform for this chain
							}
						}
					}
					print DEFAULT "\t";
					print DEFAULT "$_," for @isoforms_fsm_valid;
					print DEFAULT "\n";
					$SJ_chain_cat{'ism'}{$chain}[1] = \@isoforms_fsm_valid;
					if (@isoforms_fsm_valid == 0) { #check if the ism chain is valid if no full length annotated isoform contains the chain
						$chain_w_compatible_annotated_fsm{$chain} = 1 if $compatible_annotated_fsm_num > 0; #check if completely compatible with annotated isoform
						my $validation_result = &valid_nc($chain, $chr_SJ_reads_ref, $SJ_chain_read{$chain}[-1], \%read_info, \@all_SJ_group_sort, $anno_SJ_complete{$chr}, $isoform_SJ_complete{$chr});
						if (${$validation_result}[0] >= 1) {
							push @possible_nc_ism, $chain;
							$unannotated_isoforms{$chain} = $validation_result; # if @{${$validation_result}[1]} > 0;
						}
					}
				}
				for my $i ( 0 .. $#possible_nc_ism-1 ){	#pairwise comaprison of valid ism chains without full length annotated isoform to find the longest
					my @SJs_i = split '_', $possible_nc_ism[$i];
					for my $j ($i+1 .. $#possible_nc_ism){
						next unless exists ${$SJ_chain_read{$possible_nc_ism[$i]}[-2]}{$possible_nc_ism[$j]};
						my $comp_result = &comp_SJ_chain($possible_nc_ism[$i], $possible_nc_ism[$j]);
						print DEFAULT "$possible_nc_ism[$i]\t$possible_nc_ism[$j]\t$comp_result\t$SJ_chain_read_exon_end{$possible_nc_ism[$j]}{'start'}{$SJs_i[0]}\t$SJ_chain_read_exon_end{$possible_nc_ism[$j]}{'end'}{$SJs_i[-1]}\t$SJ_chain_read{$possible_nc_ism[$i]}[1]\t$SJ_chain_read{$possible_nc_ism[$i]}[2]\n";
						if ($comp_result == 2) {
							push @{$substring_nc{$possible_nc_ism[$i]}}, $possible_nc_ism[$j] if $SJ_chain_read_exon_end{$possible_nc_ism[$j]}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$possible_nc_ism[$i]}[1] and $SJ_chain_read_exon_end{$possible_nc_ism[$j]}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$possible_nc_ism[$i]}[2];
						}
					}
				}

				for my $chain (@possible_nc_ism) {
					my @SJs_i = split '_', $chain;
					for my $nc_chain (@nc_valid_longest){	#compare valid ism chains without full length annotated isoform to valid longest nc chians
						next unless exists ${$SJ_chain_read{$chain}[-2]}{$nc_chain};
						my $comp_result = &comp_SJ_chain($chain, $nc_chain);
						if ($comp_result == 2) {
							push @{$substring_nc{$chain}}, $nc_chain if $SJ_chain_read_exon_end{$nc_chain}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$chain}[1] and $SJ_chain_read_exon_end{$nc_chain}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$chain}[2];
						}
					}
					if (exists $substring_nc{$chain}) {
						my @nc_isoforms;
						for my $nc_chain (@{$substring_nc{$chain}}) {
							if (exists $longest_nc_valid{$nc_chain}) {
								push @nc_isoforms, $longest_nc_valid{$nc_chain};
							}
						}
						$SJ_chain_cat{'ism'}{$chain}[1] = \@nc_isoforms;
					} elsif (exists $chain_w_compatible_annotated_fsm{$chain}) {
						push @nc_valid_longest, $chain;
						$longest_nc_valid{$chain} = $#nc_valid_longest;
					}
				}
			}

			}
			
			while (my ($SJ_chain, $chain_info_ref) = each %SJ_chain_read) {
				my ($cat, $chain_start, $chain_end, $strand, $SJ_count, $related_chain_ref, $read_info) = @{$chain_info_ref};
				my %read_count_sample;
				for my $read_info_ref (@{$read_info}){
					$read_count_sample{$read_info{${$read_info_ref}[0]}{'sample'}} ++;
				}
				for my $sample (@samples_sort) {
					if (exists $read_count_sample{$sample}) {
						$read_count_isoform{$SJ_chain}{$sample} = [$read_count_sample{$sample},$read_count_sample{$sample},0,0,0]; #before_assign, direct_assign, EM_assign, current_increase, last_increase
					} else {
						$read_count_isoform{$SJ_chain}{$sample} = [0,0,0,0,0]; 
					}				
				}

			}
			
			my %ism_mt1_chain_count;
			if (!defined $raw) {
			
			for my $cat ('ism', 'fsm', 'nic', 'nnc', 'filtered') {
				@{$cat_SJ_chains_sort{$cat}} = sort {$SJ_chain_cat{$cat}{$b}[0] <=> $SJ_chain_cat{$cat}{$a}[0]} keys %{$SJ_chain_cat{$cat}};
			}

			for my $cat ('nic', 'nnc') {
				for my $chain (@{$cat_SJ_chains_sort{$cat}}) {
					my $type;
					if (exists $substring_nc{$chain}) {
						my @nc_isoforms;
						for my $nc_chain (@{$substring_nc{$chain}}) {
							if (exists $longest_nc_valid{$nc_chain}) {
								push @nc_isoforms, $longest_nc_valid{$nc_chain};
							}
						}
						
						if (@nc_isoforms>0) {
							push @{$SJ_chain_cat{$cat}{$chain}}, \@nc_isoforms;
							if (scalar(@nc_isoforms) == 1){
								my $read_count_total=0;
								for my $sample (@samples_sort) {
									$read_count_isoform{ $nc_valid_longest[$nc_isoforms[0]] }{$sample}[1] += $read_count_isoform{$chain}{$sample}[0];
									$read_count_total += $read_count_isoform{$chain}{$sample}[0];
								}
								$type = "direct";
								printf DEFAULT "!!read_count_summary\t$chr\t$cat\t$n:$chain\t$type\t%g!=$read_count_total\n", scalar(@{$SJ_chain_read{$chain}[-1]}) if $read_count_total!=@{$SJ_chain_read{$chain}[-1]};
							} else {
								$type = "EM";
							}
							if (defined $tsv_compt){
								for my $read_info_ref (@{$SJ_chain_read{$chain}[-1]}) {
									my $read_ID = ${$read_info_ref}[0];
									print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNIC/NNC\t";
									print COMPT "ESPRESSO:$chr:$n:$_," for @{$SJ_chain_cat{$cat}{$chain}[1]};
									print COMPT "\n";
								}
							}
							printf DEFAULT "read_count_summary\t$chr\t$cat\t$n:$chain\t$type\t%g\n", scalar(@{$SJ_chain_read{$chain}[-1]});
						} else {
							if (defined $tsv_compt){
								for my $read_info_ref (@{$SJ_chain_read{$chain}[-1]}) {
									my $read_ID = ${$read_info_ref}[0];
									print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNIC/NNC\tNA\n";
								}
							}
							printf DEFAULT "read_count_summary\t$chr\t$cat\t$n:$chain\tNA1\t%g\n", scalar(@{$SJ_chain_read{$chain}[-1]});
						}
					} elsif (exists $longest_nc_valid{$chain}) {
						if (defined $tsv_compt){
							for my $read_info_ref (@{$SJ_chain_read{$chain}[-1]}){
								my $read_ID = ${$read_info_ref}[0];
								print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNIC/NNC\tESPRESSO:$chr:$n:$longest_nc_valid{$chain}\n";
							}
						}
						
						printf DEFAULT "read_count_summary\t$chr\t$cat\t$n:$chain\titself\t%g\n", scalar(@{$SJ_chain_read{$chain}[-1]});
					} else {
						if (defined $tsv_compt){
							for my $read_info_ref (@{$SJ_chain_read{$chain}[-1]}) {
								my $read_ID = ${$read_info_ref}[0];
								print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNIC/NNC\tNA\n";
							}
						}
						printf DEFAULT "read_count_summary\t$chr\t$cat\t$n:$chain\tNA2\t%g\n", scalar(@{$SJ_chain_read{$chain}[-1]});
						#print "$cat\t$chain\t",scalar(@{$SJ_chain_read{$chain}[-1]}),"\n";
					}
					
				}
			}

			
			for my $ism_SJ_chain (@{$cat_SJ_chains_sort{'ism'}}) {
				if (exists $longest_nc_valid{$ism_SJ_chain}){
					if (defined $tsv_compt){
						for my $read_info_ref (@{$SJ_chain_read{$ism_SJ_chain}[-1]}){
							my $read_ID = ${$read_info_ref}[0];
							print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNIC/NNC\t";
							print COMPT "ESPRESSO:$chr:$n:$longest_nc_valid{$ism_SJ_chain},";
							print COMPT "\n";
						}
					}
					printf DEFAULT "read_count_summary\t$chr\tism\t$n:$ism_SJ_chain\titself\t%g\n", scalar(@{$SJ_chain_read{$ism_SJ_chain}[-1]});
				} else {
					if (!exists $substring_nc{$ism_SJ_chain}) {
						my @SJs_i = split '_', $ism_SJ_chain;
						while (my ($nc_chain, $nc_chain_ID) = each %longest_nc_valid) {
							next unless exists ${$SJ_chain_read{$ism_SJ_chain}[-2]}{$nc_chain};
							my $comp_result = &comp_SJ_chain($ism_SJ_chain, $nc_chain);
							if ($comp_result == 2) {
								push @{$SJ_chain_cat{'ism'}{$ism_SJ_chain}[1]}, $nc_chain_ID if $SJ_chain_read_exon_end{$nc_chain}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$ism_SJ_chain}[1] and $SJ_chain_read_exon_end{$nc_chain}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$ism_SJ_chain}[2];
							}
						}
					}
					
					if (scalar(@{$SJ_chain_cat{'ism'}{$ism_SJ_chain}[1]}) == 1) {
						my @isoforms_only = @{$SJ_chain_cat{'ism'}{$ism_SJ_chain}[1]};
						my $isoform_fsm = $SJ_chain_cat{'ism'}{$ism_SJ_chain}[1][0];
						my ($read_compatible_isoform_1);
						if (exists $fsm_chain{$isoform_fsm}) {
							for my $sample (@samples_sort) {
								$read_count_isoform{$fsm_chain{$isoform_fsm}}{$sample}[1] += $read_count_isoform{$ism_SJ_chain}{$sample}[0];
							}
							$read_compatible_isoform_1 = $isoform_fsm;
						} elsif ($isoform_fsm =~ /^\d+$/ and defined $nc_valid_longest[$isoform_fsm]){
							for my $sample (@samples_sort) {
								$read_count_isoform{$nc_valid_longest[$isoform_fsm]}{$sample}[1] += $read_count_isoform{$ism_SJ_chain}{$sample}[0];
							}
							$read_compatible_isoform_1 = "ESPRESSO:$chr:$n:$isoform_fsm";
						} else {
							die "don't know what fsm is for $ism_SJ_chain in group $n($group_start, $group_end)\t$isoform_fsm\n";
						}
						if (defined $tsv_compt){
							for my $read_info_ref (@{$SJ_chain_read{$ism_SJ_chain}[-1]}){
								my $read_ID = ${$read_info_ref}[0];
								print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tISM\t";
								print COMPT "$read_compatible_isoform_1,\n";
							}
						}
						printf DEFAULT "read_count_summary\t$chr\tism\t$n:$ism_SJ_chain\tdirect\t%g\n", scalar(@{$SJ_chain_read{$ism_SJ_chain}[-1]});
					} elsif (scalar(@{$SJ_chain_cat{'ism'}{$ism_SJ_chain}[1]}) > 1) {
						my @ism_SJ_order = split '_', $ism_SJ_chain;
						my @SJ_chain_pos = map {$all_SJ_group_sort[$_]} @ism_SJ_order;
						my (%chains_string_freq);
						for my $read_info_ref (@{$SJ_chain_read{$ism_SJ_chain}[-1]}){
							my ($read_ID, $read_start, $read_end, $strand) = @{$read_info_ref};
							my $sample = $read_info{$read_ID}{'sample'};
							my (%fsm_SJ_chain_right, %read_compatible_isoform);
							for my $isoform_fsm (@{$SJ_chain_cat{'ism'}{$ism_SJ_chain}[1]}){
								if (exists $multi_exon_isoform_end{$isoform_fsm}){
									$fsm_SJ_chain_right{$fsm_chain{$isoform_fsm}} = 0;
									$read_compatible_isoform{$isoform_fsm} = 0;
									if( exists $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$SJ_chain_pos[0]}[1]} and exists $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$SJ_chain_pos[-1]}[2]} and $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$SJ_chain_pos[0]}[1]} - $SJ_dist <= $read_start and $multi_exon_isoform_end{$isoform_fsm}{$anno_SJ{$chr}{$SJ_chain_pos[-1]}[2]} + $SJ_dist >= $read_end ){
										$fsm_SJ_chain_right{$fsm_chain{$isoform_fsm}} ++;
										$read_compatible_isoform{$isoform_fsm} ++;
									}
								} elsif ($isoform_fsm =~ /^\d+$/ and defined $nc_valid_longest[$isoform_fsm]){
									$fsm_SJ_chain_right{$nc_valid_longest[$isoform_fsm]} ++;
									$read_compatible_isoform{"ESPRESSO:$chr:$n:$isoform_fsm"} ++;

								} else {
									die "don't know what fsm is for2 $ism_SJ_chain in group $n($group_start, $group_end): $isoform_fsm";
								}
							}
							my @sort_chains;
							my @valid_SJ_chain = grep {$fsm_SJ_chain_right{$_}>0} keys %fsm_SJ_chain_right;
							if (scalar(@valid_SJ_chain)>=1) {
								@sort_chains = sort {$a cmp $b} @valid_SJ_chain;
								print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tISM\t";
								my @valid_isoforms = grep {$read_compatible_isoform{$_}>0} keys %read_compatible_isoform;
								print COMPT "$_," for @valid_isoforms;
								print COMPT "\n";
							} else {
								@sort_chains = sort {$a cmp $b} keys %fsm_SJ_chain_right;
								print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tISM\t";
								print COMPT "$_," for keys %read_compatible_isoform;
								print COMPT "\n";
							}

							my $chains_compt_read_string = join(':', @sort_chains);
							$chains_string_freq{$chains_compt_read_string}{$sample} ++;
						}
						my $total_count = 0;
						while (my ($chains_string, $sample_ref) = each %chains_string_freq) {
							while (my ($sample, $count) = each %{$sample_ref}) {
								push @{$ism_mt1_chain_count{$ism_SJ_chain}{$sample}}, [$chains_string, $count];
								$total_count += $count;
							}
						}
						die "$total_count!=@{$SJ_chain_read{$ism_SJ_chain}[-1]}" if $total_count!=@{$SJ_chain_read{$ism_SJ_chain}[-1]};
						printf DEFAULT "read_count_summary\t$chr\tism\t$n:$ism_SJ_chain\tEM\t%g\n", scalar(@{$SJ_chain_read{$ism_SJ_chain}[-1]});
					} else {
						if (defined $tsv_compt){
							for my $read_info_ref (@{$SJ_chain_read{$ism_SJ_chain}[-1]}){
								my $read_ID = ${$read_info_ref}[0];
								print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tISM\t";
								print COMPT "NA\n";
							}
						}
						
						printf DEFAULT "read_count_summary\t$chr\tism\t$n:$ism_SJ_chain\tNA0\t%g\n", scalar(@{$SJ_chain_read{$ism_SJ_chain}[-1]});
					}
				}
			}
			
			for my $filtered_SJ_chain (@{$cat_SJ_chains_sort{'filtered'}}) {
				my @SJs_i = split '_', $filtered_SJ_chain;
				my (@SJ_chains, @isoforms_compatible);
				for my $fsm_SJ_chain (@{$cat_SJ_chains_sort{'fsm'}}) {
					next unless exists ${$SJ_chain_read{$filtered_SJ_chain}[-2]}{$fsm_SJ_chain};
					my $comp_result = &comp_SJ_chain($filtered_SJ_chain, $fsm_SJ_chain);
					if ($comp_result == 3) {
						if ($SJ_chain_read_exon_end{$fsm_SJ_chain}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$filtered_SJ_chain}[1] and $SJ_chain_read_exon_end{$fsm_SJ_chain}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$filtered_SJ_chain}[2]){
							push @SJ_chains, $fsm_SJ_chain;
							my @isoforms = @{$SJ_chain_cat{'fsm'}{$fsm_SJ_chain}[1]};
							push @isoforms_compatible, @isoforms;;
						}
					}
				}
				while (my ($nc_chain, $nc_chain_ID) = each %longest_nc_valid) {
					next unless exists ${$SJ_chain_read{$filtered_SJ_chain}[-2]}{$nc_chain};
					my $comp_result = &comp_SJ_chain($filtered_SJ_chain, $nc_chain);
					if ($comp_result == 3) {
						if ($SJ_chain_read_exon_end{$nc_chain}{'start'}{$SJs_i[0]} - $SJ_dist <= $SJ_chain_read{$filtered_SJ_chain}[1] and $SJ_chain_read_exon_end{$nc_chain}{'end'}{$SJs_i[-1]} + $SJ_dist >= $SJ_chain_read{$filtered_SJ_chain}[2]){
							push @SJ_chains, $nc_chain;
							push @isoforms_compatible, "ESPRESSO:$chr:$n:$longest_nc_valid{$nc_chain}";
						}
					}
				}
				if (@SJ_chains >= 1) {
					$possible_fsm_filtered{scalar(@SJ_chains)}{$filtered_SJ_chain} = \@SJ_chains;
					if (defined $tsv_compt){
						for my $read_info_ref (@{$SJ_chain_read{$filtered_SJ_chain}[-1]}) {
							my $read_ID = ${$read_info_ref}[0];
							print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNCD\t";
							for my $isoform (@isoforms_compatible) {
								#my @isoforms = @{$SJ_chain_cat{'fsm'}{$chain}[1]};
								print COMPT "$isoform,";
							}
							print COMPT "\n";
						}
					}
					printf DEFAULT "read_count_summary\t$chr\tfiltered\t$n:$filtered_SJ_chain\tEM\t%g\n", scalar(@{$SJ_chain_read{$filtered_SJ_chain}[-1]}) if @SJ_chains > 1;
				} else {
					for my $read_info_ref (@{$SJ_chain_read{$filtered_SJ_chain}[-1]}) {
						my $read_ID = ${$read_info_ref}[0];
						print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tNCD\tNA\n";
					}
					printf DEFAULT "read_count_summary\t$chr\tfiltered\t$n:$filtered_SJ_chain\tNA\t%g\n", scalar(@{$SJ_chain_read{$filtered_SJ_chain}[-1]});
				}
			}
			while(my ($filtered_SJ_chain, $chain_ref) = each %{$possible_fsm_filtered{'1'}}){
				for my $sample (@samples_sort) {
					$read_count_isoform{${$chain_ref}[0]}{$sample}[1] += $read_count_isoform{$filtered_SJ_chain}{$sample}[0];
				}
				printf DEFAULT "read_count_summary\t$chr\tfiltered\t$n:$filtered_SJ_chain\tdirect\t%g\n", scalar(@{$SJ_chain_read{$filtered_SJ_chain}[-1]});
			}
			while (my ($chain, $sample_ref) = each %read_count_isoform) {
				while (my ($sample, $count_ref) = each %{$sample_ref}) {
					$read_count_isoform{$chain}{$sample}[2]=$read_count_isoform{$chain}{$sample}[1];
				}
			}



			}

			if (defined $tmp_output) {
				while (my ($SJ_chain, $chain_info_ref) = each %SJ_chain_read) {
					my @SJ_IDs = split '_', $SJ_chain;
					my ($cat, $chain_start, $chain_end, $strand, $SJ_count, $related_chain_ref, $read_info) = @{$chain_info_ref};
					print DEFAULT "isoform_chain\t$chr\t$SJ_chain\t$cat\t", scalar(@{$read_info}), "\t$SJ_chain_read{$SJ_chain}[1]\t$SJ_chain_read{$SJ_chain}[2]\t";

					for my $SJ_ID (@SJ_IDs){
						if ($SJ_ID eq 'x'){
							print DEFAULT "x,";
						} else {
							print DEFAULT "$all_SJ_group_sort[$SJ_ID],";
						}
					}
					print DEFAULT "\t";
					if (exists $SJ_chain_cat{$cat}{$SJ_chain} and defined $SJ_chain_cat{$cat}{$SJ_chain}[1] and @{$SJ_chain_cat{$cat}{$SJ_chain}[1]} > 0) {
						print DEFAULT "$_," for @{$SJ_chain_cat{$cat}{$SJ_chain}[1]};
					} else {
						print DEFAULT "NA";
					}
					print DEFAULT "\t";
					if ($cat eq 'fsm') {
						print DEFAULT "NA";
					} elsif (exists ($longest_nc_valid{$SJ_chain})) {
						print DEFAULT "valid($longest_nc_valid{$SJ_chain})";
					} else {
						print DEFAULT "non_valid";
					}
					print DEFAULT "\t";
					if (exists ($substring_nc{$SJ_chain})) {
						print DEFAULT "$_," for @{$substring_nc{$SJ_chain}};
					} else {
						print DEFAULT "NA";
					}
					print DEFAULT "\t";
					if (exists $unannotated_isoforms{$SJ_chain} and @{$unannotated_isoforms{$SJ_chain}[2]}>0) {
						print DEFAULT "$_," for @{$unannotated_isoforms{$SJ_chain}[1]};
					} else {
						print DEFAULT "NA";
					}
					print DEFAULT "\t";
					if (exists $unannotated_isoforms{$SJ_chain} and @{$unannotated_isoforms{$SJ_chain}[2]}>0) {
						print DEFAULT "$_," for @{$unannotated_isoforms{$SJ_chain}[2]};
					} else {
						print DEFAULT "NA";
					}
					if (exists $unannotated_isoforms{$SJ_chain}) {
						print DEFAULT "\t$unannotated_isoforms{$SJ_chain}[3]\t$unannotated_isoforms{$SJ_chain}[4]";
					} else {
						print DEFAULT "\tNA\tNA";
					}

					for my $sample (@samples_sort) {
						print DEFAULT "\t";
						print DEFAULT "$_," for @{$read_count_isoform{$SJ_chain}{$sample}};
					}
					print DEFAULT "\n";
				}
			}
			

			if (!defined $raw) {


			my $m = 0;
			my $largest_diff;
			while (1){
				$m ++;
				$largest_diff = 0;
				
				while (my ($ism_SJ_chain, $sample_ref) = each %ism_mt1_chain_count) {
					my $total_count = 0;
					while (my ($sample, $chains_count_ref) = each %{$sample_ref}) {
						for my $chains_string_freq_ref (@{$chains_count_ref}) {
							my ($chains_string, $count) = @{$chains_string_freq_ref};
							$total_count += $count;
							my @chains = split ':', $chains_string;
							my $total_read_count_fsm = 0;
							$total_read_count_fsm += $read_count_isoform{$_}{$sample}[2] for @chains;
							if ($total_read_count_fsm > 0) {
								$read_count_isoform{$_}{$sample}[3] += sprintf("%.2f",$count/$total_read_count_fsm*$read_count_isoform{$_}{$sample}[2]) for @chains;
							} else {
								$read_count_isoform{$_}{$sample}[3] += sprintf("%.2f",$count/@chains) for @chains;
							}
							print DEFAULT "special_ISM_read_assigned:$ism_SJ_chain\t$sample\t",scalar(@chains), "\t";
							print DEFAULT "$_($count)" for @chains;
							print DEFAULT "\n";
						}
						
					}
					printf DEFAULT "read_count_summary_in_EM\t$chr\tISM\t$n:$ism_SJ_chain\tEM\t%g\t$m\n", $total_count;
				}

				for my $cat ('nic', 'nnc') {
					for my $chain (@{$cat_SJ_chains_sort{$cat}}) {
						if (defined $SJ_chain_cat{$cat}{$chain}[1] and scalar(@{$SJ_chain_cat{$cat}{$chain}[1]}) > 1) {
							my @chains_nc = map {$nc_valid_longest[$_]} @{$SJ_chain_cat{$cat}{$chain}[1]};
							my $total_count = 0;
							for my $sample (@samples_sort) {
								next if $read_count_isoform{$chain}{$sample}[0] == 0;
								$total_count += $read_count_isoform{$chain}{$sample}[0];
								my $total_read_count_nc = 0;
								$total_read_count_nc += $read_count_isoform{$_}{$sample}[2] for @chains_nc;
								if ($total_read_count_nc > 0) {
									$read_count_isoform{$_}{$sample}[3] += sprintf("%.2f",$read_count_isoform{$chain}{$sample}[0]/$total_read_count_nc*$read_count_isoform{$_}{$sample}[2]) for @chains_nc;
								} else {
									$read_count_isoform{$_}{$sample}[3] += sprintf("%.2f",$read_count_isoform{$chain}{$sample}[0]/@chains_nc) for @chains_nc;
								}
							}
							printf DEFAULT "read_count_summary_in_EM\t$chr\t$cat\t$n:$chain\tEM\t%g\t$m\n", $total_count;
						}
					}
				}
				my @possible_fsm_num_sort = sort {$a<=>$b} keys %possible_fsm_filtered;
				for my $possible_fsm_num(@possible_fsm_num_sort) {
					if ($possible_fsm_num>1){
						while (my ($filtered_SJ_chain, $fsm_chain_ref) = each %{$possible_fsm_filtered{$possible_fsm_num}}){
							my $total_count = 0;
							for my $sample (@samples_sort) {
								next if $read_count_isoform{$filtered_SJ_chain}{$sample}[0] == 0;
								$total_count += $read_count_isoform{$filtered_SJ_chain}{$sample}[0];
								my $total_read_count_fsm = 0;
								$total_read_count_fsm += $read_count_isoform{$_}{$sample}[2] for @{$fsm_chain_ref};
								if ($total_read_count_fsm > 0) {
									$read_count_isoform{$_}{$sample}[3] += sprintf("%.2f",$read_count_isoform{$filtered_SJ_chain}{$sample}[0]/$total_read_count_fsm*$read_count_isoform{$_}{$sample}[2]) for @{$fsm_chain_ref};
								} else {
									$read_count_isoform{$_}{$sample}[3] += sprintf("%.2f",$read_count_isoform{$filtered_SJ_chain}{$sample}[0]/@{$fsm_chain_ref}) for @{$fsm_chain_ref};
								}
							}
							printf DEFAULT "read_count_summary_in_EM\t$chr\tfiltered\t$n:$filtered_SJ_chain\tEM\t%g\t$m\n", $total_count;
						}
						
					}
				}
				for my $chain (keys %read_count_isoform){
					for my $sample (@samples_sort) {
						$read_count_isoform{$chain}{$sample}[2] = $read_count_isoform{$chain}{$sample}[1] + $read_count_isoform{$chain}{$sample}[3];
						$largest_diff = abs($read_count_isoform{$chain}{$sample}[3] - $read_count_isoform{$chain}{$sample}[4]) if $largest_diff < abs($read_count_isoform{$chain}{$sample}[3] - $read_count_isoform{$chain}{$sample}[4]);
						$read_count_isoform{$chain}{$sample}[4] = $read_count_isoform{$chain}{$sample}[3];
						$read_count_isoform{$chain}{$sample}[3] = 0;
					}
				}

				if ($largest_diff < .1){
					print DEFAULT "converge: $n\t$largest_diff\t$m\n";
					last;
				} elsif ($m>=$max_iterate){
					print DEFAULT "not_converge: $n\t$largest_diff\t$m\n";
					last;
				}
			}

			while(my ($fsm_SJ_chain, $chain_info_ref) = each %{$SJ_chain_cat{'fsm'}}){
				my $isSameStrand = $SJ_chain_read{$fsm_SJ_chain}[3];
				my @SJ_IDs = split '_', $fsm_SJ_chain;
				my @SJs = map {$all_SJ_group_sort[$_]} @SJ_IDs;
				if (defined $tmp_output) {
					print DEFAULT "assign_reads\t$fsm_SJ_chain\t";
					print DEFAULT "$read_count_isoform{$fsm_SJ_chain}{$_}[0]," for @samples_sort;
					print DEFAULT "\t";
					printf DEFAULT "%.2f,", $read_count_isoform{$fsm_SJ_chain}{$_}[1] for @samples_sort;
					print DEFAULT "\t";
					printf DEFAULT "%.2f,", $read_count_isoform{$fsm_SJ_chain}{$_}[2] for @samples_sort;
					print DEFAULT "\t";
					
					print DEFAULT "$_," for @{${$chain_info_ref}[-1]};
					print DEFAULT "\t";
					print DEFAULT "$SJ_chain_read{$fsm_SJ_chain}[1],";
					print DEFAULT "$_," for @SJs;
					print DEFAULT "$SJ_chain_read{$fsm_SJ_chain}[2]";
					print DEFAULT "\n";
				}
				
				#my @SJ0_info = split ':', $SJs[0];

				my (%possible_genes, %possible_isoform_names, %total_perfect_match);
				for my $isoform (@{${$chain_info_ref}[-1]}) {
					for my $sample (@samples_sort){
						$total_perfect_match{$sample} += @{$isoform_perfect_match{$isoform}{$sample}} if exists $isoform_perfect_match{$isoform} and exists $isoform_perfect_match{$isoform}{$sample};
					}
				}

				for my $isoform ( @{${$chain_info_ref}[-1]} ){
					my $abu_output = "$isoform\t$isoform_info{$isoform}[-1]\t$isoform_info{$isoform}[0]";
					my $tag = 0;
					for my $sample (@samples_sort){
						if ($total_perfect_match{$sample} > 0){
							if ( exists $isoform_perfect_match{$isoform} and exists $isoform_perfect_match{$isoform}{$sample} ) {
								$abu_output .= sprintf ("\t%.2f", $read_count_isoform{$fsm_SJ_chain}{$sample}[2]*@{$isoform_perfect_match{$isoform}{$sample}}/$total_perfect_match{$sample});
								$tag = 1;
							} else {
								$abu_output .= "\t0";
							}
						} else {
							if ($read_count_isoform{$fsm_SJ_chain}{$sample}[2]>0) {
								$abu_output .= sprintf ("\t%.2f", $read_count_isoform{$fsm_SJ_chain}{$sample}[2]/@{${$chain_info_ref}[-1]});
								$tag = 1;
							} else {
								$abu_output .= "\t0";
							}
						}
					}
					if ($tag == 1){
						print ABU $abu_output."\n";
						#printf DEFAULT "read_count_summary_itself\tNA\t$chr\t$n\tfsm\t$fsm_SJ_chain\t$fsm_SJ_chain\titself\t%g\n", $total_count;
						&gtf_output($chr, $isoform, [$multi_exon_isoform_end{$isoform}{'0'},$multi_exon_isoform_end{$isoform}{'1'}], \@SJs, $strand_symbol{$isSameStrand}, 'annotated_isoform');
					}
					
				}
				if (defined $tsv_compt){
					for my $read_info_ref (@{$SJ_chain_read{$fsm_SJ_chain}[-1]}) {
						my $read_ID = ${$read_info_ref}[0];
						print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tFSM\t";
						print COMPT "$_," for @{${$chain_info_ref}[-1]};
						print COMPT "\n";
					}
				}
				printf DEFAULT "read_count_summary\t$chr\tfsm\t$n:$fsm_SJ_chain\titself\t%g\n", scalar(@{$SJ_chain_read{$fsm_SJ_chain}[-1]});
			}
			while(my ($nc_SJ_chain, $nc_SJ_chain_ID) = each %longest_nc_valid){
				my $isSameStrand = $SJ_chain_read{$nc_SJ_chain}[3];
				my @SJ_IDs = split '_', $nc_SJ_chain;
				my @SJs = map {$all_SJ_group_sort[$_]} @SJ_IDs;
				if (defined $tmp_output) {
					print DEFAULT "assign_reads\t$nc_SJ_chain\t";
					print DEFAULT "$read_count_isoform{$nc_SJ_chain}{$_}[0]," for @samples_sort;
					print DEFAULT "\t";
					printf DEFAULT "%.2f,", $read_count_isoform{$nc_SJ_chain}{$_}[1] for @samples_sort;
					print DEFAULT "\t";
					printf DEFAULT "%.2f,", $read_count_isoform{$nc_SJ_chain}{$_}[2] for @samples_sort;
					print DEFAULT "\t";
					
					if (exists $unannotated_isoforms{$nc_SJ_chain} and @{$unannotated_isoforms{$nc_SJ_chain}[1]} > 0){
						print DEFAULT "$_," for @{$unannotated_isoforms{$nc_SJ_chain}[1]};
					} else {
						print DEFAULT "$n:$nc_SJ_chain_ID\t";
					}
					if (exists $unannotated_isoforms{$nc_SJ_chain}){
						print DEFAULT "$unannotated_isoforms{$nc_SJ_chain}[3]\t$unannotated_isoforms{$nc_SJ_chain}[4]\t";
					} else {
						print DEFAULT "0\t0\t";
					}
					print DEFAULT "$SJ_chain_read{$nc_SJ_chain}[1],";
					print DEFAULT "$_," for @SJs;
					print DEFAULT "$SJ_chain_read{$nc_SJ_chain}[2]";
					print DEFAULT "\n";
				}
				#my @SJ0_info = split ':', $SJs[0];
				

				if (exists $unannotated_isoforms{$nc_SJ_chain} and @{$unannotated_isoforms{$nc_SJ_chain}[1]} > 0){
					my $isoform_ID = join '/', @{$unannotated_isoforms{$nc_SJ_chain}[1]};

					my (%possible_genes, %possible_isoform_names);
					for my $isoform (@{$unannotated_isoforms{$nc_SJ_chain}[1]}) {
						$possible_genes{$isoform_info{$isoform}[0]} ++;
						$possible_isoform_names{$isoform_info{$isoform}[-1]} ++;
					}
					my @possible_genes_sort = sort {$possible_genes{$b} <=> $possible_genes{$a}} keys %possible_genes;
					my @possible_isoform_names_sort = sort {$possible_isoform_names{$b} <=> $possible_isoform_names{$a}} keys %possible_isoform_names;
					my $possible_genes_ID = join ',', @possible_genes_sort;
					my $possible_isoform_name = join ',', @possible_isoform_names_sort;
					print ABU "$isoform_ID\t$possible_isoform_name\t$possible_genes_ID";

					printf ABU "\t%.2f", $read_count_isoform{$nc_SJ_chain}{$_}[2] for @samples_sort;
					print ABU "\n";
					&gtf_output($chr, $isoform_ID, [$SJ_chain_read{$nc_SJ_chain}[1],$SJ_chain_read{$nc_SJ_chain}[2]], \@SJs, $strand_symbol{$isSameStrand}, 'annotated_isoform');
				} else {
					my $isoform_ID = "ESPRESSO:$chr:$n:$nc_SJ_chain_ID";
					print ABU "$isoform_ID\tNA";
					my %possible_genes;
					for my $SJ(@SJs) {
						if (exists $anno_SJ{$chr}{$SJ}){
							$possible_genes{$isoform_info{$_}[0]} ++ for @{$anno_SJ{$chr}{$SJ}[-1]};
						} elsif (exists $anno_SJ_complete{$chr}{$SJ}){
							$possible_genes{$isoform_info{$_}[0]} ++ for @{$anno_SJ_complete{$chr}{$SJ}[-1]};
						}
					}
					my @possible_genes_sort = sort {$possible_genes{$b} <=> $possible_genes{$a}} keys %possible_genes;
					if (@possible_genes_sort > 0) {
						print ABU "\t$possible_genes_sort[0]";
						print ABU ",$possible_genes_sort[$_]" for 1 .. $#possible_genes_sort;
					} else {
						print ABU "\tNA";
					}
					
					printf ABU "\t%.2f", $read_count_isoform{$nc_SJ_chain}{$_}[2] for @samples_sort;
					print ABU "\n";
					&gtf_output($chr, "$isoform_ID", [$SJ_chain_read{$nc_SJ_chain}[1],$SJ_chain_read{$nc_SJ_chain}[2]], \@SJs, $strand_symbol{$isSameStrand}, 'novel_isoform');
				}
				
			}

			my %single_exon_isoform_read_count;

			my @single_exon_isoforms_sort = sort {$single_exon_isoform_end{$chr}{$a}{'1'}-$single_exon_isoform_end{$chr}{$a}{'0'} <=> $single_exon_isoform_end{$chr}{$b}{'1'}-$single_exon_isoform_end{$chr}{$b}{'0'}} keys %{$single_exon_isoform_end{$chr}};
			for my $single_exon_isoform(@single_exon_isoforms_sort){
				$single_exon_isoform_read_count{$single_exon_isoform}{$_} = [0,0,0] for @samples_sort; #direct_assign, last_EM_assign, current_EM_assign
			}
			my %possible_single_exon_isoform;
			my ($total_count1, $total_count2) = (0,0);
			for my $read_ID (@single_exon_reads){
				my $sample = $read_info{$read_ID}{'sample'};
				if (exists $read_info{$read_ID}{'start'} and exists $read_info{$read_ID}{'end'}) {
					for my $single_exon_isoform(@single_exon_isoforms_sort){
						if ( $single_exon_isoform_end{$chr}{$single_exon_isoform}{'0'}-$SJ_dist<=$read_info{$read_ID}{'start'} and abs($single_exon_isoform_end{$chr}{$single_exon_isoform}{'1'}+$SJ_dist >=$read_info{$read_ID}{'end'}) ){	
							push @{$possible_single_exon_isoform{$read_ID}}, $single_exon_isoform;
						}
					}
				}
				if(exists $possible_single_exon_isoform{$read_ID}) {
					$total_count1 ++;
					print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tsingle-exon\t";
					for my $single_exon_isoform (@{$possible_single_exon_isoform{$read_ID}}) {
						$single_exon_isoform_read_count{$single_exon_isoform}{$sample}[0] += sprintf("%.2f", 1/@{$possible_single_exon_isoform{$read_ID}});
						print COMPT "$single_exon_isoform,";
					}
					print COMPT "\n";
				} else {
					$total_count2 ++;
					print COMPT "$read_info{$read_ID}{'ori_ID'}\t$read_info{$read_ID}{'sample'}\tsingle-exon\tNA\n";
					
				}
			}
			if (defined $tmp_output) {
				printf DEFAULT "read_count_summary\t$chr\tone_exon\t$n:total\tEM\t%g\n", $total_count1;
				printf DEFAULT "read_count_summary\t$chr\tone_exon\t$n:total\tNA\t%g\n", $total_count2;
				printf DEFAULT "read_count_summary_one_exon\t$chr\t$n\t%g\n", scalar(@single_exon_reads);
			}
			
			$m = 0;
			for my $single_exon_isoform(@single_exon_isoforms_sort){
				$single_exon_isoform_read_count{$single_exon_isoform}{$_}[1] = $single_exon_isoform_read_count{$single_exon_isoform}{$_}[0] for @samples_sort;
			}
			while (1){
				$m ++;
				$largest_diff = 0;
				while (my ($read_ID, $isoforms_ref) = each %possible_single_exon_isoform){
					my $sample = $read_info{$read_ID}{'sample'};
					my $total_read_count_isoforms= 0;
					$total_read_count_isoforms += $single_exon_isoform_read_count{$_}{$sample}[1] for @{$isoforms_ref};
					if ($total_read_count_isoforms > 0) {
						for my $single_exon_isoform (@{$isoforms_ref}) {
							$single_exon_isoform_read_count{$single_exon_isoform}{$sample}[2] += sprintf("%.2f", 1/$total_read_count_isoforms*$single_exon_isoform_read_count{$single_exon_isoform}{$sample}[1]);
						}
					} else {
						for my $single_exon_isoform (@{$isoforms_ref}) {
							$single_exon_isoform_read_count{$single_exon_isoform}{$sample}[2] += sprintf("%.2f", 1/@{$isoforms_ref});
						}
					}
				}
				printf DEFAULT "read_count_summary_in_EM\t$chr\tone_exon\t$n:total\tEM\t%g\t$m\n", scalar(keys %possible_single_exon_isoform);
				for my $single_exon_isoform (@single_exon_isoforms_sort){
					for my $sample (@samples_sort) {
						$largest_diff = abs($single_exon_isoform_read_count{$single_exon_isoform}{$sample}[2] - $single_exon_isoform_read_count{$single_exon_isoform}{$sample}[1]) if $largest_diff < abs($single_exon_isoform_read_count{$single_exon_isoform}{$sample}[2] - $single_exon_isoform_read_count{$single_exon_isoform}{$sample}[1]);
						$single_exon_isoform_read_count{$single_exon_isoform}{$sample}[1] = $single_exon_isoform_read_count{$single_exon_isoform}{$sample}[2];
						$single_exon_isoform_read_count{$single_exon_isoform}{$sample}[2] = 0;
					}
					
				}


				if ($largest_diff < .1){
					print DEFAULT "single_converge: $n\t$largest_diff\t$m\n";
					last;
				} elsif ($m>=$max_iterate){
					print DEFAULT "single_not_converge: $n\t$largest_diff\t$m\n";
					last;
				}
			}

			while (my ($single_exon_isoform, $sample_ref) = each %single_exon_isoform_read_count){
				my $total_read_count_EM = 0;
				$total_read_count_EM += ${$sample_ref}{$_}[1] for @samples_sort;
				if($total_read_count_EM > 0) {				

					if (defined $tmp_output) {
						print DEFAULT "assign_reads\tNA\tNA\t"; 
						print DEFAULT "${$sample_ref}{$_}[0]," for @samples_sort;
						print DEFAULT "\t";
						printf DEFAULT "%.2f,", ${$sample_ref}{$_}[1] for @samples_sort;
						print DEFAULT "\t";
						print DEFAULT "$single_exon_isoform,\t";
						print DEFAULT "$single_exon_isoform_end{$chr}{$single_exon_isoform}{'0'},";
						print DEFAULT "$single_exon_isoform_end{$chr}{$single_exon_isoform}{'1'}";
						print DEFAULT "\n";
					}
					$single_exon_isoform_total{$single_exon_isoform}{$_} += ${$sample_ref}{$_}[1] for @samples_sort;
				}
			}



			}

		}

		while (my ($single_exon_isoform, $sample_ref) = each %single_exon_isoform_total){
			print ABU "$single_exon_isoform\t$isoform_info{$single_exon_isoform}[-1]\t$isoform_info{$single_exon_isoform}[0]";
			printf ABU "\t%.2f", ${$sample_ref}{$_} for @samples_sort;
			print ABU "\n";
			&gtf_output($chr, $single_exon_isoform, [$single_exon_isoform_end{$chr}{$single_exon_isoform}{'0'},$single_exon_isoform_end{$chr}{$single_exon_isoform}{'1'}], [], $single_exon_isoform_end{$chr}{$single_exon_isoform}{'strand'}, 'annotated_isoform');

		}

		%SJ_read_improved= ();
		%read_filtered= ();
		%read_info= ();
		%SJ_read_order= ();
		%unanno_SJ= ();
	}

	my %total_type;
	while (my ($chr, $type_ref) = each %chr_type) {
		print DEFAULT "$chr";
		for my $type ("fsm", "ism", "nic", "nnc") {
			if (exists $chr_type{$chr}{$type}) {
				print DEFAULT " $chr_type{$chr}{$type}";
				$total_type{$type} += $chr_type{$chr}{$type};
			} else {
				print DEFAULT " NA";
			}
		}
		print DEFAULT "\n";
	}
	for my $type ("fsm", "ism", "nic", "nnc") {
		if (exists $total_type{$type}) {
			print DEFAULT " $total_type{$type}";
		} else {
			print DEFAULT " NA";
		}
	}
	print DEFAULT "\n";
	close DEFAULT if defined $tmp_output;
	close COMPT if defined $tsv_compt;
	close GTF;
	close ABU;

	print  '[', scalar(localtime), "] ESPRESSO finished quantification\n";

	sub gtf_output {
		my ($chr, $isoform_ID, $ends_ref, $SJs_ref, $strand, $type) = @_;
		print GTF "$chr\t$type\ttranscript\t",${$ends_ref}[0]+1,"\t${$ends_ref}[1]\t.\t$strand\t.\ttranscript_id \"$isoform_ID\";\n";
		if (@{$SJs_ref} > 0) {
			my @exons = ([${$ends_ref}[0]+1]);
			for my $SJ(@{$SJs_ref}) {
				my @SJ_info = split ':', $SJ;
				push @{$exons[-1]}, $SJ_info[1];
				push @exons, [$SJ_info[2]+1];
			}
			push @{$exons[-1]}, ${$ends_ref}[1];
			for my $exon_ID (0 .. $#exons) {
				printf GTF "$chr\t$type\texon\t${$exons[$exon_ID]}[0]\t${$exons[$exon_ID]}[1]\t.\t$strand\t.\ttranscript_id \"$isoform_ID\"; exon_number \"%g\";\n", $exon_ID+1;
			}
		} else {
			print GTF "$chr\t$type\texon\t",${$ends_ref}[0]+1,"\t${$ends_ref}[1]\t.\t$strand\t.\ttranscript_id \"$isoform_ID\"; exon_number \"1\";\n";
		}
	}

	sub valid_nc {
		my ($chain, $chr_SJ_reads_ref, $SJ_chain_read_ref, $read_info_ref, $all_SJ_group_sort_ref, $chr_anno_SJ_ref, $SJ_isoform_SJ_ref) = @_;
		my @SJ_IDs = split '_', $chain;
		print DEFAULT "validation_for_nc_chain: $chain";

		my (@SJs, @SJs_valid);
		my (%possible_isoforms, @fsm_unanno, @ism_unanno, %SJ_info_nc);
		for my $SJ_ID (@SJ_IDs) {
			my $SJ = ${$all_SJ_group_sort_ref}[$SJ_ID];
			my ($chr, $start, $end, $strand) = split ':', $SJ;
			$SJ_info_nc{$SJ} = [$start, $end, $strand];
			if(exists ${$chr_anno_SJ_ref}{$SJ}) {
				$possible_isoforms{$_}++ for @{${$chr_anno_SJ_ref}{$SJ}[-1]};
			}
			push @SJs, $SJ;
			print DEFAULT "\t$SJ";
			if ( !exists ${$chr_SJ_reads_ref}{$SJ} ) {
				die "0:$chain\t$SJ_ID\t$SJ";
			} 
		}
		print DEFAULT "\n";
		
		for my $possible_fsm_complete (keys %possible_isoforms) {
			my $comp_result = &comp_minimap_reference_SJ(\%SJ_info_nc, ${$SJ_isoform_SJ_ref}{$possible_fsm_complete});
			if ($comp_result == 1) {
				push @fsm_unanno, $possible_fsm_complete;
			} elsif ($comp_result == 2) {
				push @ism_unanno, $possible_fsm_complete;
			}
		}
		if(@fsm_unanno >= 1) {
			print DEFAULT "unannotated_isoforms $chain: ";
			print DEFAULT "$_," for @fsm_unanno;
			print DEFAULT "\n";

		} elsif(@ism_unanno >= 1) {
			print DEFAULT "unannotated_isoforms_fragment $chain: ";
			print DEFAULT "$_," for @ism_unanno;
			print DEFAULT "\n";
		}
		
		my @reads_info = @{$SJ_chain_read_ref};
		die "no reads loaded for $chain" if scalar(@reads_info) == 0;
		my @valid_read_SJs;
		for my $SJ (@SJs) {
			my ($chr,$start,$end,$strand) = split ':', $SJ;
			
				my @valid_reads = grep {${$chr_SJ_reads_ref}{$SJ}{${$read_info_ref}{${$_}[0]}{'ori_ID'}} >= 1} @reads_info;
				if (@valid_reads >= $read_num_cutoff and @valid_reads/@reads_info >= $read_ratio_cutoff) {
					push @SJs_valid, $SJ;
				}
				printf DEFAULT "\t$SJ(%g/%g)", scalar(@valid_reads), scalar(@reads_info);
				push @valid_read_SJs, scalar(@valid_reads);

		}
		print DEFAULT "\n";
		my @valid_read_SJs_sort = sort {$a <=> $b} @valid_read_SJs;
		if (@SJs_valid == @SJs) {
			print DEFAULT "yes_validated: $chain\n";
			[1,\@fsm_unanno,\@ism_unanno, $valid_read_SJs_sort[0], scalar(@reads_info)];
		} else {
			print DEFAULT "not_validated: $chain\n";
			[0,\@fsm_unanno,\@ism_unanno, $valid_read_SJs_sort[0], scalar(@reads_info)];
		}
	}

	sub comp_SJ_chain{
		my ($SJ_chain_short, $SJ_chain_long) = @_;
		my @SJs_short = split '_', $SJ_chain_short;
		my @SJs_long = split '_', $SJ_chain_long;
		if (@SJs_short > @SJs_long or @SJs_short == 0 or @SJs_long == 0) {
			return 0;
		}
		my @non_x_SJ_IDs = grep {$SJs_short[$_] ne 'x'} (0 .. $#SJs_short);
		my ($matched_1st_non_x_SJ_ID, $match_SJ_num);

		for my $XJ_ID_long ($non_x_SJ_IDs[0] .. $#SJs_long) {
			if (defined $matched_1st_non_x_SJ_ID and defined $SJs_short[$XJ_ID_long-$matched_1st_non_x_SJ_ID+$non_x_SJ_IDs[0]] and $SJs_short[$XJ_ID_long-$matched_1st_non_x_SJ_ID+$non_x_SJ_IDs[0]] eq $SJs_long[$XJ_ID_long]) {
				$match_SJ_num ++;
			} elsif ($SJs_short[$non_x_SJ_IDs[0]] eq $SJs_long[$XJ_ID_long]) {
				$matched_1st_non_x_SJ_ID = $XJ_ID_long;
				if ($#SJs_long-$matched_1st_non_x_SJ_ID < $#SJs_short-$non_x_SJ_IDs[0]) {
					return 0;
				}
				$match_SJ_num ++;
			}
		}
		if ($match_SJ_num == @SJs_long){
			1;
		} elsif ($match_SJ_num == @SJs_short){
			2;
		} elsif ($match_SJ_num == @non_x_SJ_IDs){
			3;
		} else {
			0;
		}
	}

	sub comp_minimap_reference_SJ{
		my ($minimap_SJ_ref, $ref_SJ_ref) = @_;
		my @ref_SJ_sort = sort {${$ref_SJ_ref}{$a}[0] <=> ${$ref_SJ_ref}{$b}[0] or ${$ref_SJ_ref}{$a}[1] <=> ${$ref_SJ_ref}{$b}[1]} keys %{$ref_SJ_ref};
		my @minimap_SJ_sort = sort {${$minimap_SJ_ref}{$a}[1] <=> ${$minimap_SJ_ref}{$b}[1] or ${$minimap_SJ_ref}{$a}[2] <=> ${$minimap_SJ_ref}{$b}[2]} keys %{$minimap_SJ_ref};
		my ($ref_SJ_sort_string, $minimap_SJ_sort_string) = (join('_',@ref_SJ_sort), join('_',@minimap_SJ_sort) );
		my $result = &comp_SJ_chain($minimap_SJ_sort_string, $ref_SJ_sort_string);
		print DEFAULT "$minimap_SJ_sort_string\t$ref_SJ_sort_string\t$result\n";
		return $result;
	}

}

